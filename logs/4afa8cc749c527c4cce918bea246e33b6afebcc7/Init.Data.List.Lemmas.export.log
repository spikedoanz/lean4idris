Getting declarations... 10953 found
(caching disabled)
Checking: List... ok
Checking: List.nil... ok
Checking: List.cons... ok
Checking: Lean.Name... ok
Checking: Lean.Name.anonymous... ok
Checking: String... ok
Checking: ByteArray... ok
Checking: Array... ok
Checking: Array.mk... ok
Checking: UInt8... ok
Checking: Nat... ok
Checking: Nat.zero... ok
Checking: Nat.succ... ok
Checking: BitVec... ok
Checking: Fin... ok
Checking: LT... ok
Checking: LT.mk... ok
Checking: LT.lt... ok
Checking: Nat.le... ok
Checking: Nat.le.refl... ok
Checking: Nat.le.step... ok
Checking: Nat.lt... ok
Checking: instLTNat... ok
Checking: Fin.mk... ok
Checking: outParam... ok
Checking: HPow... ok
Checking: HPow.mk... ok
Checking: HPow.hPow... ok
Checking: Pow... ok
Checking: Pow.mk... ok
Checking: Pow.pow... ok
Checking: instHPow... ok
Checking: NatPow... ok
Checking: NatPow.mk... ok
Checking: NatPow.pow... ok
Checking: instPowNat... ok
Checking: Nat.rec... ok
Checking: PUnit... ok
Checking: PUnit.unit... ok
Checking: PProd... ok
Checking: PProd.mk... ok
Checking: Nat.below... ok
Checking: Nat.brecOn.go... ok
Checking: Nat.brecOn... ok
Checking: Unit... ok
Checking: OfNat... ok
Checking: OfNat.mk... ok
Checking: OfNat.ofNat... ok
Checking: instOfNatNat... ok
Checking: Nat.casesOn... ok
Checking: Unit.unit... ok
Checking: Nat.pow.match_1... ok
Checking: Nat.mul.match_1... ok
Checking: Nat.add.match_1... ok
Checking: Nat.add... ok
Checking: Nat.mul... ok
Checking: Nat.pow... ok
Checking: instNatPowNat... ok
Checking: BitVec.ofFin... ok
Checking: UInt8.ofBitVec... ok
Checking: ByteArray.mk... ok
Checking: ByteArray.IsValidUTF8... ok
Checking: Char... ok
Checking: UInt32... ok
Checking: UInt32.ofBitVec... ok
Checking: Or... ok
Checking: Or.inl... ok
Checking: Or.inr... ok
Checking: And... ok
Checking: And.intro... ok
Checking: Nat.isValidChar... ok
Checking: Fin.val... ok
Checking: BitVec.toFin... ok
Checking: BitVec.toNat... ok
Checking: UInt32.toBitVec... ok
Checking: UInt32.toNat... ok
Checking: UInt32.isValidChar... ok
Checking: Char.mk... ok
Checking: Eq... ok
Checking: Eq.refl... ok
Checking: List.rec... ok
Checking: List.below... ok
Checking: List.brecOn.go... ok
Checking: List.brecOn... ok
Checking: List.casesOn... ok
Checking: List.toByteArray.match_1... ok
Checking: ByteArray.rec... ok
Checking: ByteArray.casesOn... ok
Checking: ByteArray.push.match_1... ok
Checking: List.concat.match_1... ok
Checking: List.concat... ok
Checking: Array.toList... ok
Checking: Array.push... ok
Checking: ByteArray.push... ok
Checking: List.toByteArray.loop... ok
Checking: Array.emptyWithCapacity... ok
Checking: Array.empty... ok
Checking: ByteArray.emptyWithCapacity... ok
Checking: ByteArray.empty... ok
Checking: List.toByteArray... ok
Checking: List.flatten.match_1... ok
Checking: List.append.match_1... ok
Checking: List.append... ok
Checking: List.flatten... ok
Checking: List.length.match_1... ok
Checking: List.map... ok
Checking: List.flatMap... ok
Checking: Char.val... ok
Checking: Decidable... ok
Checking: False... ok
Checking: Not... ok
Checking: Decidable.isFalse... ok
Checking: Decidable.isTrue... ok
Checking: Decidable.rec... ok
Checking: Decidable.casesOn... ok
Checking: ite... ok
Checking: LE... ok
Checking: LE.mk... ok
Checking: LE.le... ok
Checking: instLENat... ok
Checking: dite... ok
Checking: Bool... ok
Checking: Bool.false... ok
Checking: Bool.true... ok
Checking: Nat.ble.match_1... ok
Checking: Nat.ble... ok
Checking: DecidableEq... ok
Checking: Bool.rec... ok
Checking: Bool.casesOn... ok
Checking: Bool.decEq.match_1... ok
Checking: rfl... ok
Checking: Bool.noConfusionType... ok
Checking: Eq.rec... ok
Checking: Eq.ndrec... ok
Checking: Bool.noConfusion... ok
Checking: Bool.decEq... ok
Checking: instDecidableEqBool... ok
Checking: False.rec... ok
Checking: False.elim... ok
Checking: Eq.casesOn... ok
Checking: HEq... ok
Checking: HEq.refl... ok
Checking: _private.Init.Prelude.0.Nat.le_of_ble_eq_true.match_1_1... ok
Checking: _private.Init.Prelude.0.Nat.zero_le.match_1_1... ok
Checking: Nat.zero_le... ok
Checking: Nat.le.below... ok
Checking: Nat.le.below.refl... ok
Checking: Nat.le.below.step... ok
Checking: Nat.le.rec... ok
Checking: Nat.le.brecOn... ok
Checking: Nat.le.below.rec... ok
Checking: Nat.le.below.casesOn... ok
Checking: Eq.symm... ok
Checking: cast... ok
Checking: HEq.rec... ok
Checking: eq_of_heq... ok
Checking: _private.Init.Prelude.0.Nat.succ_le_succ.match_1_4... ok
Checking: HAdd... ok
Checking: HAdd.mk... ok
Checking: HAdd.hAdd... ok
Checking: Add... ok
Checking: Add.mk... ok
Checking: Add.add... ok
Checking: instHAdd... ok
Checking: instAddNat... ok
Checking: Nat.succ_le_succ... ok
Checking: Nat.le_of_ble_eq_true... ok
Checking: absurd... ok
Checking: _private.Init.Prelude.0.Nat.ble_eq_true_of_le.match_1_4... ok
Checking: _private.Init.Prelude.0.Nat.ble_self_eq_true.match_1_1... ok
Checking: Nat.ble_self_eq_true... ok
Checking: _private.Init.Prelude.0.Nat.ble_succ_eq_true.match_1_1... ok
Checking: Nat.ble_succ_eq_true... ok
Checking: Nat.ble_eq_true_of_le... ok
Checking: Nat.not_le_of_not_ble_eq_true... ok
Checking: Nat.decLe... ok
Checking: HMod... ok
Checking: HMod.mk... ok
Checking: HMod.hMod... ok
Checking: Mod... ok
Checking: Mod.mk... ok
Checking: Mod.mod... ok
Checking: instHMod... ok
Checking: namedPattern... ok
Checking: Nat.mod.match_1... ok
Checking: Nat.decLt... ok
Checking: Nat.le.casesOn... ok
Checking: Nat.noConfusionType... ok
Checking: Nat.noConfusion... ok
Checking: Nat.div.go.match_1... ok
Checking: HSub... ok
Checking: HSub.mk... ok
Checking: HSub.hSub... ok
Checking: Sub... ok
Checking: Sub.mk... ok
Checking: Sub.sub... ok
Checking: instHSub... ok
Checking: Nat.pred... ok
Checking: Nat.sub... ok
Checking: instSubNat... ok
Checking: _private.Init.Prelude.0.Nat.le_trans.match_1_6... ok
Checking: Nat.le_trans... ok
Checking: Nat.lt_of_lt_of_le... ok
Checking: And.rec... ok
Checking: And.casesOn... ok
Checking: _private.Init.Prelude.0.Nat.div_rec_lemma.match_1_1... ok
Checking: _private.Init.Prelude.0.Nat.sub_lt.match_1_1... ok
Checking: _private.Init.Prelude.0.Nat.not_succ_le_self.match_1_1... ok
Checking: _private.Init.Prelude.0.Nat.not_succ_le_zero.match_1_5... ok
Checking: _private.Init.Prelude.0.Nat.not_succ_le_zero.match_1_1... ok
Checking: _private.Init.Prelude.0.Nat.not_succ_le_zero.match_1_3... ok
Checking: Nat.not_succ_le_zero... ok
Checking: _private.Init.Prelude.0.Nat.pred_le_pred.match_1_1... ok
Checking: Nat.le_succ... ok
Checking: Nat.pred_le_pred... ok
Checking: Nat.le_of_succ_le_succ... ok
Checking: Nat.not_succ_le_self... ok
Checking: Nat.lt_irrefl... ok
Checking: Nat.lt_succ_of_le... ok
Checking: Nat.le_refl... ok
Checking: _private.Init.Prelude.0.Nat.pred_le.match_1_1... ok
Checking: Nat.pred_le... ok
Checking: Nat.sub_le... ok
Checking: congrArg... ok
Checking: Nat.succ_sub_succ_eq_sub... ok
Checking: Nat.sub_lt... ok
Checking: Nat.div_rec_lemma... ok
Checking: Nat.le_of_lt_succ... ok
Checking: Nat.div_rec_fuel_lemma... ok
Checking: Nat.modCore.go... ok
Checking: Nat.lt_add_one... ok
Checking: Nat.lt_succ_self... ok
Checking: Nat.modCore... ok
Checking: Nat.mod... ok
Checking: Nat.instMod... ok
Checking: _private.Init.Prelude.0.Nat.mod_lt.match_1_3... ok
Checking: Nat.zero_lt_succ... ok
Checking: _private.Init.Prelude.0.Nat.mod_lt.match_1_1... ok
Checking: _private.Init.Prelude.0.Nat.modCore_lt.match_1_1... ok
Checking: Nat.not_lt_zero... ok
Checking: _private.Init.Prelude.0.Nat.modCoreGo_lt.match_1_1... ok
Checking: Or.rec... ok
Checking: Or.casesOn... ok
Checking: _private.Init.Prelude.0.Or.elim.match_1_1... ok
Checking: Or.elim... ok
Checking: id... ok
Checking: Or.resolve_right... ok
Checking: GE.ge... ok
Checking: _private.Init.Prelude.0.Nat.lt_or_ge.match_1_5... ok
Checking: _private.Init.Prelude.0.Nat.lt_or_ge.match_1_3... ok
Checking: Nat.le_succ_of_le... ok
Checking: _private.Init.Prelude.0.Nat.lt_or_ge.match_1_1... ok
Checking: Nat.eq_or_lt_of_le.match_3... ok
Checking: Nat.eq_or_lt_of_le.match_1... ok
Checking: Nat.eq_or_lt_of_le... ok
Checking: Nat.lt_or_ge... ok
Checking: Nat.lt_of_not_le... ok
Checking: Nat.modCoreGo_lt... ok
Checking: Nat.modCore_lt... ok
Checking: Nat.mod_lt... ok
Checking: Fin.Internal.ofNat... ok
Checking: _private.Init.Prelude.0.Nat.pow_pos.match_1_1... ok
Checking: HMul... ok
Checking: HMul.mk... ok
Checking: HMul.hMul... ok
Checking: Mul... ok
Checking: Mul.mk... ok
Checking: Mul.mul... ok
Checking: instHMul... ok
Checking: instMulNat... ok
Checking: _private.Init.Prelude.0.Nat.mul_pos.match_1_1... ok
Checking: _private.Init.Prelude.0.Nat.add_pos_right.match_1_1... ok
Checking: Nat.add_pos_right... ok
Checking: Nat.mul_pos... ok
Checking: Nat.pow_pos... ok
Checking: BitVec.ofNat._proof_1... ok
Checking: BitVec.ofNat... ok
Checking: UInt8.ofNat... ok
Checking: HDiv... ok
Checking: HDiv.mk... ok
Checking: HDiv.hDiv... ok
Checking: Div... ok
Checking: Div.mk... ok
Checking: Div.div... ok
Checking: instHDiv... ok
Checking: Nat.div.go... ok
Checking: Nat.div... ok
Checking: Nat.instDiv... ok
Checking: String.utf8EncodeChar... ok
Checking: List.utf8Encode... ok
Checking: ByteArray.IsValidUTF8.intro... ok
Checking: String.ofByteArray... ok
Checking: Lean.Name.str... ok
Checking: Lean.Name.num... ok
Checking: Lean.SyntaxNodeKind... ok
Checking: Lean.SyntaxNodeKinds... ok
Checking: Repr... ok
Checking: Std.Format... ok
Checking: Std.Format.nil... ok
Checking: Std.Format.line... ok
Checking: Std.Format.align... ok
Checking: Std.Format.text... ok
Checking: Int... ok
Checking: Int.ofNat... ok
Checking: Int.negSucc... ok
Checking: Std.Format.nest... ok
Checking: Std.Format.append... ok
Checking: optParam... ok
Checking: Std.Format.FlattenBehavior... ok
Checking: Std.Format.FlattenBehavior.allOrNone... ok
Checking: Std.Format.FlattenBehavior.fill... ok
Checking: Std.Format.group... ok
Checking: Std.Format.tag... ok
Checking: Repr.mk... ok
Checking: Lean.TSyntax... ok
Checking: Lean.Syntax... ok
Checking: Lean.Syntax.missing... ok
Checking: Lean.SourceInfo... ok
Checking: Substring.Raw... ok
Checking: String.Pos.Raw... ok
Checking: String.Pos.Raw.mk... ok
Checking: Substring.Raw.mk... ok
Checking: Lean.SourceInfo.original... ok
Checking: Lean.SourceInfo.synthetic... ok
Checking: Lean.SourceInfo.none... ok
Checking: Lean.Syntax.node... ok
Checking: Lean.Syntax.atom... ok
Checking: Lean.Syntax.Preresolved... ok
Checking: Lean.Syntax.Preresolved.namespace... ok
Checking: Lean.Syntax.Preresolved.decl... ok
Checking: Lean.Syntax.ident... ok
Checking: Lean.TSyntax.mk... ok
Checking: NatCast... ok
Checking: NatCast.mk... ok
Checking: NatCast.natCast... ok
Checking: Nat.cast... ok
Checking: instNatCastInt... ok
Checking: Inhabited... ok
Checking: Inhabited.mk... ok
Checking: Inhabited.default... ok
Checking: Pi.instInhabited... ok
Checking: instInhabitedNat... ok
Checking: String.Internal.length... ok
Checking: HAppend... ok
Checking: HAppend.mk... ok
Checking: HAppend.hAppend... ok
Checking: Append... ok
Checking: Append.mk... ok
Checking: Append.append... ok
Checking: instHAppendOfAppend... ok
Checking: Std.Format.instAppend... ok
Checking: Std.Format.bracket... ok
Checking: instOfNat... ok
Checking: Repr.reprPrec... ok
Checking: repr... ok
Checking: Std.instInhabitedFormat.default... ok
Checking: Std.instInhabitedFormat... ok
Checking: Lean.Syntax.instRepr.repr... ok
Checking: Lean.Syntax.instRepr... ok
Checking: Lean.TSyntax.raw... ok
Checking: Lean.Syntax.instReprTSyntax.repr... ok
Checking: Lean.Syntax.instReprTSyntax... ok
Checking: Lean.RArray... ok
Checking: Lean.RArray.leaf... ok
Checking: Lean.RArray.branch... ok
Checking: Nat.Linear.Context... ok
Checking: Nat.Linear.Expr... ok
Checking: Nat.Linear.Expr.num... ok
Checking: Nat.Linear.Var... ok
Checking: Nat.Linear.Expr.var... ok
Checking: Nat.Linear.Expr.add... ok
Checking: Nat.Linear.Expr.mulL... ok
Checking: Nat.Linear.Expr.mulR... ok
Checking: Nat.Linear.Expr.rec... ok
Checking: Nat.Linear.Expr.below... ok
Checking: Nat.Linear.Expr.brecOn.go... ok
Checking: Nat.Linear.Expr.brecOn... ok
Checking: Nat.Linear.Expr.casesOn... ok
Checking: Nat.Linear.Expr.denote.match_1... ok
Checking: Lean.RArray.rec... ok
Checking: Lean.RArray.get... ok
Checking: Nat.beq.match_1... ok
Checking: Nat.beq... ok
Checking: Nat.Linear.fixedVar... ok
Checking: Nat.Linear.Var.denote... ok
Checking: Nat.Linear.Expr.denote... ok
Checking: semiOutParam... ok
Checking: MonadReaderOf... ok
Checking: MonadReaderOf.mk... ok
Checking: MonadReaderOf.read... ok
Checking: Exists... ok
Checking: Exists.intro... ok
Checking: Subtype... ok
Checking: Subtype.mk... ok
Checking: Subtype.val... ok
Checking: Nonempty... ok
Checking: Nonempty.intro... ok
Checking: Classical.choice... ok
Checking: Exists.rec... ok
Checking: Exists.casesOn... ok
Checking: Classical.indefiniteDescription.match_1... ok
Checking: Classical.indefiniteDescription._proof_1... ok
Checking: Classical.indefiniteDescription... ok
Checking: Classical.choose... ok
Checking: Exists.choose... ok
Checking: List.length... ok
Checking: Option... ok
Checking: Option.none... ok
Checking: Option.some... ok
Checking: GetElem?... ok
Checking: GetElem... ok
Checking: GetElem.mk... ok
Checking: GetElem?.mk... ok
Checking: GetElem?.getElem?... ok
Checking: Fin.rec... ok
Checking: Fin.casesOn... ok
Checking: True... ok
Checking: True.intro... ok
Checking: _private.Init.Prelude.0.noConfusion_of_Nat.aux.match_1_1... ok
Checking: _private.Init.Prelude.0.noConfusion_of_Nat.aux... ok
Checking: noConfusion_of_Nat... ok
Checking: Nat.ctorIdx... ok
Checking: List.get.match_1... ok
Checking: List.get._proof_1... ok
Checking: List.get... ok
Checking: List.instGetElemNatLtLength... ok
Checking: Ne... ok
Checking: List.ctorIdx... ok
Checking: _private.Init.Prelude.0.Nat.ne_of_beq_eq_false.match_1_1... ok
Checking: Nat.ne_of_beq_eq_false... ok
Checking: List.get?Internal._sparseCasesOn_1... ok
Checking: List.get?Internal.match_1... ok
Checking: List.get?Internal... ok
Checking: panicCore... ok
Checking: panic... ok
Checking: String.instInhabited... ok
Checking: String.Internal.append... ok
Checking: ToString... ok
Checking: ToString.mk... ok
Checking: ToString.toString... ok
Checking: String.ofList._proof_1... ok
Checking: String.ofList... ok
Checking: _private.Init.Data.Repr.0.Nat.toDigitsCore.match_1... ok
Checking: Nat.decEq.match_1... ok
Checking: _private.Init.Prelude.0.Nat.eq_of_beq_eq_true.match_1_1... ok
Checking: Nat.eq_of_beq_eq_true... ok
Checking: Nat.decEq... ok
Checking: instDecidableEqNat... ok
Checking: instDecidableAnd.match_1... ok
Checking: instDecidableOr.match_1... ok
Checking: instDecidableOr._proof_1... ok
Checking: instDecidableOr... ok
Checking: And.right... ok
Checking: instDecidableAnd._proof_1... ok
Checking: And.left... ok
Checking: instDecidableAnd._proof_2... ok
Checking: instDecidableAnd... ok
Checking: BitVec.ofNatLT... ok
Checking: UInt32.size... ok
Checking: _private.Init.Prelude.0.isValidChar_UInt32.match_1_1... ok
Checking: Nat.lt_trans... ok
Checking: Decidable.decide... ok
Checking: _private.Init.Prelude.0.of_decide_eq_true.match_1_1... ok
Checking: _private.Init.Prelude.0.ne_true_of_eq_false.match_1_1... ok
Checking: ne_true_of_eq_false... ok
Checking: _private.Init.Prelude.0.decide_eq_false.match_1_1... ok
Checking: decide_eq_false... ok
Checking: of_decide_eq_true... ok
Checking: _private.Init.Prelude.0.isValidChar_UInt32... ok
Checking: Char.ofNatAux._private_1... ok
Checking: Char.ofNatAux... ok
Checking: Char.ofNat._proof_1... ok
Checking: Char.ofNat._proof_2... ok
Checking: Char.ofNat... ok
Checking: Nat.digitChar... ok
Checking: Nat.toDigitsCore... ok
Checking: Nat.toDigits... ok
Checking: Nat.repr... ok
Checking: instToStringNat... ok
Checking: mkPanicMessageWithDecl... ok
Checking: panicWithPosWithDecl... ok
Checking: List.get!Internal... ok
Checking: List.instGetElem?NatLtLength... ok
Checking: List.reverseAux.match_1... ok
Checking: List.reverseAux... ok
Checking: List.reverse... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getElem?_reverse'.match_1_1... ok
Checking: trivial... ok
Checking: of_eq_true... ok
Checking: Eq.trans... ok
Checking: GetElem.getElem... ok
Checking: List.instAppend... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.sub_le_sub_right.match_1_1... ok
Checking: Nat.sub_le_sub_right... ok
Checking: Nat.succ_le_of_lt... ok
Checking: Eq.mp... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.succ_sub.match_1_1... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.le.dest.match_1_3... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.add_comm.match_1_1... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.zero_add.match_1_1... ok
Checking: Nat.zero_add... ok
Checking: Eq.mpr... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.succ_add.match_1_1... ok
Checking: Nat.succ_add... ok
Checking: Nat.add_comm... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.le.dest.match_1_1... ok
Checking: Nat.le.dest... ok
Checking: Nat.recAux... ok
Checking: Iff... ok
Checking: Iff.intro... ok
Checking: propext... ok
Checking: eq_true... ok
Checking: eq_self... ok
Checking: congr... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.add_assoc.match_1_1... ok
Checking: Nat.add_assoc... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.add_sub_add_right._simp_1_1... ok
Checking: Nat.add_sub_add_right... ok
Checking: Nat.add_sub_add_left... ok
Checking: Nat.sub_zero... ok
Checking: Nat.add_sub_cancel_left... ok
Checking: Nat.add_succ... ok
Checking: Nat.succ_sub... ok
Checking: Nat.sub_lt_left_of_lt_add... ok
Checking: List.length_append... ok
Checking: List.getElem_append_right._proof_1... ok
Checking: List.append_assoc... ok
Checking: List.reverseAux_eq_append... ok
Checking: List.reverse_cons... ok
Checking: List.length_reverse... ok
Checking: Nat.le_refl._simp_1... ok
Checking: Nat.lt_add_one._simp_1... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.sub_self.match_1_1... ok
Checking: Nat.succ_sub_succ... ok
Checking: Nat.sub_self... ok
Checking: GetElem?.toGetElem... ok
Checking: Nat.zero_lt_succ._simp_1... ok
Checking: Eq.propIntro... ok
Checking: Nat.succ.inj... ok
Checking: Nat.succ.injEq... ok
Checking: LawfulGetElem... ok
Checking: autoParam... ok
Checking: Lean.Name.mkStr4... ok
Checking: Lean.Name.mkStr1... ok
Checking: Lean.mkAtom... ok
Checking: ByteArray.size.match_1... ok
Checking: Array.size... ok
Checking: ByteArray.size... ok
Checking: String.bytes... ok
Checking: String.utf8ByteSize... ok
Checking: String.rawEndPos... ok
Checking: String.toRawSubstring... ok
Checking: LawfulGetElem.getElem?_def._autoParam... ok
Checking: GetElem?.getElem!... ok
Checking: Option.rec... ok
Checking: Option.casesOn... ok
Checking: GetElem?.match_1... ok
Checking: LawfulGetElem.getElem!_def._autoParam... ok
Checking: LawfulGetElem.mk... ok
Checking: LawfulGetElem.getElem?_def... ok
Checking: _private.Init.Core.0.dif_pos.match_1_1... ok
Checking: dif_pos... ok
Checking: getElem?_pos... ok
Checking: _private.Init.Core.0.dif_neg.match_1_1... ok
Checking: dif_neg... ok
Checking: _private.Init.GetElem.0.List.getElem?_eq_none_iff.match_1_1... ok
Checking: Nat.zero_le._simp_1... ok
Checking: Iff.mpr... ok
Checking: iff_true... ok
Checking: Nat.casesAuxOn... ok
Checking: List.getElem?_eq_getElem... ok
Checking: eq_false... ok
Checking: eq_false'... ok
Checking: Option.ctorIdx... ok
Checking: _private.Init.Prelude.0.Nat.le_antisymm.match_1_1... ok
Checking: Nat.lt_of_le_of_lt... ok
Checking: Nat.le_antisymm... ok
Checking: Nat.le_zero_eq... ok
Checking: Iff.refl... ok
Checking: Iff.rfl... ok
Checking: iff_self... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.le_of_add_le_add_left.match_1_1... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.le_add_right.match_1_1... ok
Checking: Nat.le_add_right... ok
Checking: Nat.le.intro... ok
Checking: implies_congr... ok
Checking: iff_of_true... ok
Checking: iff_true_intro... ok
Checking: imp_self... ok
Checking: imp_self._simp_1... ok
Checking: Nat.add_left_cancel... ok
Checking: Nat.le_of_add_le_add_left... ok
Checking: Nat.le_of_add_le_add_right... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.add_le_add_left.match_1_1... ok
Checking: Nat.add_le_add_left... ok
Checking: Nat.add_le_add_right... ok
Checking: Nat.add_le_add_iff_right... ok
Checking: _private.Init.GetElem.0.List.getElem?_eq_none_iff._simp_1_3... ok
Checking: List.getElem?_eq_none_iff... ok
Checking: List.getElem?_eq_none_iff._simp_1... ok
Checking: Or.resolve_left... ok
Checking: Nat.ge_of_not_lt... ok
Checking: flip... ok
Checking: GT.gt... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.not_le_of_gt.match_1_1... ok
Checking: Eq.subst... ok
Checking: Nat.not_le_of_gt... ok
Checking: Nat.not_lt... ok
Checking: Nat.not_lt._simp_1... ok
Checking: List.instLawfulGetElemNatLtLength... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.sub_eq_zero_of_le.match_1_1... ok
Checking: Nat.zero_sub... ok
Checking: Nat.sub_self_add... ok
Checking: Nat.sub_eq_zero_of_le... ok
Checking: Nat.le_add_left... ok
Checking: Nat.le_add_left._simp_1... ok
Checking: GetElem.getElem.congr_simp... ok
Checking: Nat.lt_of_succ_lt_succ... ok
Checking: Nat.add_le_add_iff_right._simp_1... ok
Checking: List.getElem_append_right... ok
Checking: List.getElem_append_left... ok
Checking: List.getElem?_append_left... ok
Checking: Nat.lt_of_succ_le... ok
Checking: Nat.add_lt_add_left... ok
Checking: Nat.lt_add_of_pos_right... ok
Checking: Nat.succ_pos... ok
Checking: List.getElem?_reverse'... ok
Checking: Fin.noConfusionType... ok
Checking: Fin.noConfusion... ok
Checking: Fin.mk.noConfusion... ok
Checking: Fin.mk.injEq... ok
Checking: Bool.and.match_1... ok
Checking: Bool.and... ok
Checking: DecidablePred... ok
Checking: Bool.instDecidableForallOfDecidablePred.match_3... ok
Checking: Bool.instDecidableForallOfDecidablePred._proof_1... ok
Checking: Bool.instDecidableForallOfDecidablePred._proof_2... ok
Checking: Bool.instDecidableForallOfDecidablePred.match_1... ok
Checking: Bool.instDecidableForallOfDecidablePred._proof_3... ok
Checking: Bool.instDecidableForallOfDecidablePred... ok
Checking: instDecidableIff._proof_1... ok
Checking: Iff.mp... ok
Checking: instDecidableIff._proof_2... ok
Checking: instDecidableIff._proof_3... ok
Checking: instDecidableIff._proof_4... ok
Checking: instDecidableIff... ok
Checking: instDecidableForall._proof_1... ok
Checking: instDecidableForall... ok
Checking: Bool.and_eq_false_imp... ok
Checking: Acc... ok
Checking: Acc.intro... ok
Checking: Acc.below... ok
Checking: Acc.below.intro... ok
Checking: Acc.rec... ok
Checking: Acc.brecOn... ok
Checking: HEq.rfl... ok
Checking: ForInStep... ok
Checking: ForInStep.done... ok
Checking: ForInStep.yield... ok
Checking: ForInStep.rec... ok
Checking: ForInStep.casesOn... ok
Checking: ForInStep.noConfusionType... ok
Checking: ForInStep.noConfusion... ok
Checking: ForInStep.done.noConfusion... ok
Checking: ForInStep.done.inj... ok
Checking: ReaderT... ok
Checking: ST.Ref... ok
Checking: NonemptyType... ok
Checking: NonemptyType.type... ok
Checking: instInhabitedNonemptyType... ok
Checking: ST.RefPointed... ok
Checking: ST.Ref.mk... ok
Checking: StateRefT'... ok
Checking: List.getLast?.match_1... ok
Checking: List.foldr... ok
Checking: Id... ok
Checking: Id.run... ok
Checking: Bind... ok
Checking: Bind.mk... ok
Checking: Bind.bind... ok
Checking: Monad... ok
Checking: Applicative... ok
Checking: Functor... ok
Checking: Functor.mk... ok
Checking: Pure... ok
Checking: Pure.mk... ok
Checking: Seq... ok
Checking: Seq.mk... ok
Checking: SeqLeft... ok
Checking: SeqLeft.mk... ok
Checking: SeqRight... ok
Checking: SeqRight.mk... ok
Checking: Applicative.mk... ok
Checking: Monad.mk... ok
Checking: Monad.toBind... ok
Checking: Function.comp... ok
Checking: Function.const... ok
Checking: Id.instMonad... ok
Checking: List.foldlM.match_1... ok
Checking: Pure.pure... ok
Checking: Applicative.toPure... ok
Checking: Monad.toApplicative... ok
Checking: List.foldlM... ok
Checking: List.foldrM... ok
Checking: LawfulMonad... ok
Checking: LawfulApplicative... ok
Checking: LawfulFunctor... ok
Checking: Functor.mapConst... ok
Checking: Functor.map... ok
Checking: LawfulFunctor.mk... ok
Checking: Applicative.toFunctor... ok
Checking: SeqLeft.seqLeft... ok
Checking: Applicative.toSeqLeft... ok
Checking: Seq.seq... ok
Checking: Applicative.toSeq... ok
Checking: SeqRight.seqRight... ok
Checking: Applicative.toSeqRight... ok
Checking: LawfulApplicative.mk... ok
Checking: LawfulMonad.mk... ok
Checking: List.foldlM_cons... FAIL
Checking: LawfulMonad.bind_pure_comp... ok
Checking: LawfulFunctor.id_map... ok
Checking: LawfulApplicative.toLawfulFunctor... ok
Checking: LawfulMonad.toLawfulApplicative... ok
Checking: bind_pure... ok
Checking: LawfulMonad.pure_bind... ok
Checking: <anonymous>... ok
Checking: <anonymous>... ok
Checking: Quot.liftOn... ok
Checking: <anonymous>... ok
Checking: Quot.sound... ok
Checking: funext... ok
Checking: LawfulMonad.bind_assoc... ok
Checking: List.foldlM_append... ok
Checking: List.foldrM_cons... ok
Checking: LawfulApplicative.map_pure... ok
Checking: List.foldrM_pure... ok
Checking: _auto._@.Init.Control.Lawful.Basic.156091895._hygCtx._hyg.78... ok
Checking: _auto._@.Init.Control.Lawful.Basic.156091895._hygCtx._hyg.100... ok
Checking: _auto._@.Init.Control.Lawful.Basic.156091895._hygCtx._hyg.140... ok
Checking: _auto._@.Init.Control.Lawful.Basic.156091895._hygCtx._hyg.172... ok
Checking: _auto._@.Init.Control.Lawful.Basic.156091895._hygCtx._hyg.204... ok
Checking: forall_congr... ok
Checking: implies_true... ok
Checking: LawfulMonad.mk'... ok
Checking: Id.instLawfulMonad... ok
Checking: List.foldr_eq_foldrM... ok
Checking: List.foldrM_append... ok
Checking: List.foldr_append... ok
Checking: List.foldr_flatten... ok
Checking: Lean.Meta.EtaStructMode... ok
Checking: Lean.Meta.EtaStructMode.all... ok
Checking: Lean.Meta.EtaStructMode.notClasses... ok
Checking: Lean.Meta.EtaStructMode.none... ok
Checking: Lean.Meta.DSimp.Config... ok
Checking: Lean.Meta.DSimp.Config.mk... ok
Checking: Option.SomeLtNone.lt.match_1... ok
Checking: Option.SomeLtNone.lt... ok
Checking: List.Sublist... ok
Checking: List.Sublist.slnil... ok
Checking: List.Sublist.cons... ok
Checking: List.Sublist.cons₂... ok
Checking: List.filter.match_1... ok
Checking: List.filter... ok
Checking: _private.Init.Data.List.Lemmas.0.List.filter_sublist.match_1_1... ok
Checking: List.filter.eq_2... ok
Checking: _private.Init.Data.List.Lemmas.0.List.filter.match_1.splitter... ok
Checking: _private.Init.Data.List.Lemmas.0.List.filter_sublist._simp_1_5... ok
Checking: _private.Init.Data.List.Lemmas.0.List.filter_sublist._simp_1_4... ok
Checking: List.filter_sublist... ok
Checking: IntCast... ok
Checking: IntCast.mk... ok
Checking: IntCast.rec... ok
Checking: IntCast.recOn... ok
Checking: String.toRawSubstring'... ok
Checking: List.replicate.match_1... ok
Checking: List.replicate... ok
Checking: List.getLast.match_1... ok
Checking: List.getLast._proof_1... ok
Checking: List.noConfusionType... ok
Checking: List.noConfusion... ok
Checking: List.getLast._proof_2... ok
Checking: List.getLast... ok
Checking: List.head.match_1... ok
Checking: List.head... ok
Checking: _private.Init.Data.List.Lemmas.0.List.reverse_eq_nil_iff.match_1_1... ok
Checking: true_and... ok
Checking: false_and... ok
Checking: List.append_eq_nil_iff... ok
Checking: List.append_eq_nil_iff._simp_1... ok
Checking: mt... ok
Checking: Ne.symm... ok
Checking: Nat.ne_of_lt... ok
Checking: Nat.ne_of_gt... ok
Checking: Nat.succ_ne_self... ok
Checking: List.cons_ne_self... ok
Checking: List.cons_ne_self._simp_1... ok
Checking: and_false... ok
Checking: List.reverse_eq_nil_iff... ok
Checking: List.reverse_eq_nil_iff._simp_1... ok
Checking: not_false_eq_true... ok
Checking: List.getLast_eq_head_reverse._proof_1... ok
Checking: List.head_reverse._proof_1... ok
Checking: List.head.congr_simp... ok
Checking: List.hasDecEq.match_5... ok
Checking: List.hasDecEq._proof_1... ok
Checking: List.hasDecEq._proof_2... ok
Checking: List.hasDecEq._proof_3... ok
Checking: List.hasDecEq.match_3... ok
Checking: decEq... ok
Checking: List.hasDecEq.match_1... ok
Checking: List.hasDecEq._proof_4... ok
Checking: List.hasDecEq._proof_5... ok
Checking: List.hasDecEq._proof_6... ok
Checking: List.hasDecEq... ok
Checking: instDecidableEqList... ok
Checking: Classical.propDecidable.match_1... ok
Checking: Subtype.property... ok
Checking: Classical.choose_spec... ok
Checking: _private.Init.Classical.0.Classical.em.match_1_1... FAIL
Checking: Iff.symm... ok
Checking: Iff.of_eq... ok
Checking: iff_iff_eq... ok
Checking: eq_iff_iff... ok
Checking: eq_iff_iff._simp_1... ok
Checking: iff_false... ok
Checking: instDecidableEqOfIff.match_1... ok
Checking: instDecidableEqOfIff._proof_1... ok
Checking: instDecidableEqOfIff... ok
Checking: instDecidableNot... ok
Checking: instDecidableTrue... ok
Checking: not_false... ok
Checking: instDecidableFalse... ok
Checking: not_true_eq_false... ok
Checking: _private.Init.Classical.0.Classical.em.match_1_3... ok
Checking: Classical.em... FAIL
Checking: Classical.propDecidable._proof_1... ok
Checking: Classical.propDecidable... ok
Checking: List.getLast.congr_simp... ok
Checking: _private.Init.Data.List.Lemmas.0.List.cons_ne_nil.match_1_1... ok
Checking: List.cons_ne_nil... ok
Checking: List.head?... ok
Checking: _private.Init.Data.List.Lemmas.0.List.head_append_of_ne_nil.match_1_1... ok
Checking: List.head_append_of_ne_nil... ok
Checking: List.getLast_cons... ok
Checking: Option.noConfusionType... ok
Checking: Option.noConfusion... ok
Checking: Option.some.noConfusion... ok
Checking: Option.some.injEq... ok
Checking: List.head_eq_iff_head?_eq_some... ok
Checking: _private.Init.Data.List.Lemmas.0.List.head_reverse._simp_1_1... ok
Checking: List.getLast?... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getLast?_eq_getElem?.match_1_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getLast?_eq_getElem?.match_1_3... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getLast?_eq_some_getLast.match_1_1... ok
Checking: List.getLast?_eq_some_getLast... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getLast_eq_getElem.match_1... ok
Checking: List.getLast_eq_getElem._proof_3... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getLast_eq_getElem.match_1_1... ok
Checking: List.getLast_eq_getElem... ok
Checking: List.getLast?_eq_getElem?... ok
Checking: List.getLast?_concat... ok
Checking: List.getLast?_reverse... ok
Checking: List.reverseAux_reverseAux_nil... ok
Checking: List.reverse_reverse... ok
Checking: List.head?_reverse... ok
Checking: List.head_reverse... ok
Checking: List.getLast_eq_head_reverse... ok
Checking: Membership... ok
Checking: Membership.mk... ok
Checking: Membership.mem... ok
Checking: List.Mem... ok
Checking: List.Mem.head... ok
Checking: List.Mem.tail... ok
Checking: List.instMembership... ok
Checking: List.length_replicate... ok
Checking: _private.Init.Data.List.Lemmas.0.List.mem_replicate.match_1_1... ok
Checking: List.Mem.rec... ok
Checking: List.Mem.casesOn... ok
Checking: _private.Init.Data.List.Lemmas.0.List.not_mem_nil.match_1_1... ok
Checking: List.not_mem_nil... ok
Checking: List.not_mem_nil._simp_1... ok
Checking: List.cons.noConfusion... ok
Checking: true_or... ok
Checking: or_true... ok
Checking: _private.Init.Data.List.Lemmas.0.List.mem_cons.match_1_1... ok
Checking: List.mem_cons... ok
Checking: List.mem_cons._simp_1... ok
Checking: Nat.succ_ne_zero... ok
Checking: _private.Init.Data.List.Lemmas.0.List.mem_replicate._simp_1_3... ok
Checking: or_iff_left_of_imp... ok
Checking: or_iff_left_iff_imp... ok
Checking: or_iff_left_iff_imp._simp_1... ok
Checking: _private.Init.SimpLemmas.0.and_imp.match_1_1... ok
Checking: and_imp... ok
Checking: and_imp._simp_1... ok
Checking: List.mem_replicate... ok
Checking: List.eq_of_mem_replicate... ok
Checking: _private.Init.Data.List.Lemmas.0.List.eq_replicate_iff.match_1_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.eq_replicate_of_mem.match_1_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.eq_replicate_of_mem.match_1_3... ok
Checking: _private.Init.Data.List.Lemmas.0.List.forall_mem_cons.match_1_3... ok
Checking: _private.Init.Data.List.Lemmas.0.List.forall_mem_cons.match_1_1... ok
Checking: List.forall_mem_cons... ok
Checking: List.length_cons... ok
Checking: List.replicate.eq_2... ok
Checking: List.eq_replicate_of_mem... ok
Checking: List.eq_replicate_iff... ok
Checking: _private.Init.Data.List.Lemmas.0.List.mem_reverseAux.match_1_3... ok
Checking: _private.Init.Data.List.Lemmas.0.List.mem_reverseAux.match_1_1... ok
Checking: List.reverseAux.eq_2... ok
Checking: Or.imp... ok
Checking: Or.imp_right... ok
Checking: Or.imp_left... ok
Checking: or_assoc... ok
Checking: Or.symm... ok
Checking: Or.comm... ok
Checking: or_comm... ok
Checking: or_left_comm... ok
Checking: List.mem_reverseAux... ok
Checking: _private.Init.Data.List.Lemmas.0.List.mem_reverse._simp_1_1... ok
Checking: False.casesOn... ok
Checking: _private.Init.SimpLemmas.0.or_false.match_1_1... ok
Checking: or_false... ok
Checking: List.mem_reverse... ok
Checking: List.reverse_replicate... ok
Checking: List.head_replicate... ok
Checking: List.getLast_replicate... ok
Checking: Option.isSome.match_1... ok
Checking: Option.isNone... ok
Checking: Option.isNone_none... ok
Checking: Bool.or'... ok
Checking: Option.or.match_1... ok
Checking: Option.or... ok
Checking: Option.or_eq_right_of_none... ok
Checking: BEq... ok
Checking: BEq.mk... ok
Checking: BEq.beq... ok
Checking: List.elem... ok
Checking: List.contains... ok
Checking: List.filterMap.match_1... ok
Checking: List.filterMap... ok
Checking: List.any.match_1... ok
Checking: cond.match_1... ok
Checking: Bool.or... ok
Checking: List.any... ok
Checking: Option.any... ok
Checking: _private.Init.Data.List.Lemmas.0.List.filterMap.match_1.splitter... ok
Checking: Bool.false_or... ok
Checking: List.elem_eq_contains... ok
Checking: Bool.true_or... ok
Checking: List.contains_cons... ok
Checking: List.contains_filterMap... ok
Checking: Min... ok
Checking: Min.mk... ok
Checking: Min.min... ok
Checking: Option.instBEq.beq._sparseCasesOn_2... ok
Checking: Option.lt.match_1... ok
Checking: Option.lt... ok
Checking: instLTOption... ok
Checking: Option.min.match_1... ok
Checking: Option.min... ok
Checking: Option.instMin... ok
Checking: Option.not_lt_none... ok
Checking: Option.not_lt_none._simp_1... ok
Checking: Option.min_none_right... ok
Checking: Option.some_lt_some... ok
Checking: Option.some_lt_some._simp_1... ok
Checking: Option.min_eq_right_of_lt... ok
Checking: Std.Format.rec... ok
Checking: Std.Format.casesOn... ok
Checking: Std.Format.ctorIdx... ok
Checking: _private.Init.Data.Format.Basic.0.Std.Format.isNil._sparseCasesOn_1... ok
Checking: _private.Init.Data.Format.Basic.0.Std.Format.isNil.match_1... ok
Checking: Std.Format.isNil... ok
Checking: Option.getD.match_1... ok
Checking: Option.getD... ok
Checking: instInhabitedOption... ok
Checking: Lean.Syntax.getTailInfo?... ok
Checking: Lean.Syntax.getTailInfo... ok
Checking: Int.rec... ok
Checking: Int.recOn... ok
Checking: instInhabitedForall... ok
Checking: Lean.ParserDescr... ok
Checking: Lean.ParserDescr.const... ok
Checking: Lean.ParserDescr.unary... ok
Checking: Lean.ParserDescr.binary... ok
Checking: Lean.ParserDescr.node... ok
Checking: Lean.ParserDescr.trailingNode... ok
Checking: Lean.ParserDescr.symbol... ok
Checking: Lean.ParserDescr.nonReservedSymbol... ok
Checking: Lean.ParserDescr.cat... ok
Checking: Lean.ParserDescr.parser... ok
Checking: Lean.ParserDescr.nodeWithAntiquot... ok
Checking: Lean.ParserDescr.sepBy... ok
Checking: Lean.ParserDescr.sepBy1... ok
Checking: Lean.ParserDescr.unicodeSymbol... ok
Checking: Lean.TrailingParserDescr... ok
Checking: term_\/_... ok
Checking: StateCpsT... FAIL
Checking: StateCpsT.runK... ok
Checking: StateCpsT.run'... ok
Checking: Task.Priority... ok
Checking: Task.Priority.max... ok
Checking: List.range'.match_1... ok
Checking: List.range'... ok
Checking: List.range'_zero... ok
Checking: Lean.Meta.Omega.OmegaConfig... ok
Checking: Lean.Meta.Omega.OmegaConfig.mk... ok
Checking: ReaderT.instFunctorOfMonad... ok
Checking: ReaderT.pure... ok
Checking: ReaderT.instApplicativeOfMonad... ok
Checking: _private.Init.Data.List.Control.0.List.mapA.match_1... ok
Checking: _private.Init.Data.List.Control.0.List.anyM.match_1... ok
Checking: List.allM... ok
Checking: Prod... ok
Checking: Prod.mk... ok
Checking: StateT... ok
Checking: Prod.rec... ok
Checking: Prod.casesOn... ok
Checking: StateT.bind.match_1... ok
Checking: StateT.bind... ok
Checking: _private.Init.Data.Nat.Div.Basic.0.Nat.div_mul_le_self.match_1_1... ok
Checking: Decidable.byCases.match_1... ok
Checking: Decidable.byCases... ok
Checking: Decidable.em... ok
Checking: _private.Init.Core.0.if_pos.match_1_1... ok
Checking: if_pos... ok
Checking: _private.Init.Core.0.if_neg.match_1_1... ok
Checking: if_neg... ok
Checking: ite_congr... ok
Checking: ite_cond_eq_false... ok
Checking: Nat.div.go.eq_1... ok
Checking: ite_cond_eq_true... ok
Checking: and_self... ok
Checking: _private.Init.Data.Nat.Div.Basic.0.Nat.div.go.fuel_congr.match_1_1... ok
Checking: _private.Init.Data.Nat.Div.Basic.0.Nat.div.go.fuel_congr... ok
Checking: Nat.div_eq... ok
Checking: Nat.lt_irrefl._simp_1... ok
Checking: and_true... ok
Checking: Nat.div_zero... ok
Checking: WellFounded... ok
Checking: WellFounded.intro... ok
Checking: WellFounded.fixF... ok
Checking: WellFounded.rec... ok
Checking: WellFounded.apply... ok
Checking: WellFounded.fix... ok
Checking: WellFoundedRelation... ok
Checking: WellFoundedRelation.mk... ok
Checking: InvImage... ok
Checking: WellFoundedRelation.rel... ok
Checking: Acc.recOn... ok
Checking: InvImage.accAux... ok
Checking: InvImage.accessible... ok
Checking: InvImage.wf... ok
Checking: WellFoundedRelation.wf... ok
Checking: invImage._proof_1... ok
Checking: invImage... ok
Checking: SizeOf... ok
Checking: SizeOf.mk... ok
Checking: _private.Init.WF.0.Nat.lt_wfRel.match_1... ok
Checking: Acc.inv... ok
Checking: Nat.lt_wfRel._proof_3... ok
Checking: Nat.lt_wfRel... ok
Checking: measure... ok
Checking: SizeOf.sizeOf... ok
Checking: sizeOfWFRel... ok
Checking: instSizeOfNat... ok
Checking: Lean.opaqueId... ok
Checking: Nat.div.inductionOn._unary._proof_1... TIMEOUT
Checking: Nat.div.inductionOn._unary._proof_2... ok
Checking: Nat.div.inductionOn._unary... ok
Checking: Nat.div.inductionOn... ok
Checking: Nat.mod.inductionOn... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.zero_mul.match_1_1... ok
Checking: Nat.mul_succ... ok
Checking: Nat.zero_mul... ok
Checking: Nat.add_right_comm... ok
Checking: Nat.succ_mul... ok
Checking: Nat.add_sub_cancel... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.le_of_sub_le_sub_right.match_1_1... ok
Checking: Nat.le_of_sub_le_sub_right... ok
Checking: Nat.sub_le_sub_iff_right... ok
Checking: _private.Init.Data.Nat.Div.Basic.0.Nat.le_div_iff_mul_le._simp_1_3... ok
Checking: false_iff... ok
Checking: Nat.gt_of_not_le... ok
Checking: Nat.not_le... ok
Checking: _private.Init.Data.Nat.Div.Basic.0.Nat.le_div_iff_mul_le._simp_1_2... ok
Checking: Nat.le_div_iff_mul_le... ok
Checking: Nat.div_mul_le_self... ok
Checking: Lean.Grind.Config... ok
Checking: Lean.Grind.Config.mk... ok
Checking: Lean.Grind.Config.rec... ok
Checking: Lean.Grind.Config.casesOn... ok
Checking: _private.Init.Grind.Config.0.Lean.Grind.instBEqConfig.beq.match_1... ok
Checking: instBEqOfDecidableEq... ok
Checking: Lean.Grind.instBEqConfig.beq... ok
Checking: Lean.Name.mkStr2... ok
Checking: Lean.binderPred∈_... ok
Checking: LawfulBEq... ok
Checking: ReflBEq... ok
Checking: ReflBEq.mk... ok
Checking: LawfulBEq.mk... ok
Checking: LawfulBEq.eq_of_beq... ok
Checking: _private.Init.Core.0.beq_of_eq.match_1_1... ok
Checking: ReflBEq.rfl... ok
Checking: BEq.rfl... ok
Checking: beq_of_eq... ok
Checking: LawfulBEq.toReflBEq... ok
Checking: beq_iff_eq... ok
Checking: beq_iff_eq._simp_1... ok
Checking: instLawfulBEqBool... ok
Checking: Bool.beq_to_eq... ok
Checking: Nat.Linear.Poly... ok
Checking: Nat.Linear.Poly.denote.match_1... ok
Checking: Nat.Linear.Poly.denote... ok
Checking: Prod.fst... ok
Checking: Prod.snd... ok
Checking: Nat.Linear.Poly.denote_eq... ok
Checking: Nat.Linear.Poly.cancelAux.match_3... ok
Checking: Nat.Linear.Poly.cancelAux.match_1... ok
Checking: cond... ok
Checking: Nat.blt... ok
Checking: Nat.Linear.Poly.cancelAux... ok
Checking: _private.Init.Data.Nat.Linear.0.Nat.Linear.Poly.cancelAux.match_1.splitter... ok
Checking: List.append_nil... ok
Checking: _private.Init.Data.Nat.Linear.0.Nat.Linear.Poly.cancelAux.match_1.eq_2... ok
Checking: _private.Init.Data.Nat.Linear.0.Nat.Linear.Poly.denote_append.match_1_1... ok
Checking: Nat.Linear.Poly.denote_append... ok
Checking: Nat.Linear.Poly.denote_reverse... ok
Checking: _private.Init.Core.0.Bool.of_not_eq_true.match_1_1... ok
Checking: Bool.of_not_eq_true... ok
Checking: Nat.blt_eq... ok
Checking: _private.Init.Data.Nat.Linear.0.Nat.Linear.eq_of_not_blt_eq_true... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.mul_le_mul_left.match_1_1... ok
Checking: Nat.add_left_comm... ok
Checking: Nat.left_distrib... ok
Checking: Nat.mul_le_mul_left... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.mul_comm.match_1_1... ok
Checking: Nat.mul_zero... ok
Checking: Nat.mul_comm... ok
Checking: Nat.mul_le_mul_right... ok
Checking: Nat.le_of_succ_le... ok
Checking: Nat.le_of_lt... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.sub_ne_zero_of_lt.match_1_1... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.sub_ne_zero_of_lt._simp_1_3... ok
Checking: Nat.sub_ne_zero_of_lt... ok
Checking: Nat.sub_succ... ok
Checking: Nat.succ_pred... ok
Checking: Nat.add_sub_of_le... ok
Checking: Nat.sub_add_cancel... ok
Checking: Nat.eq_add_of_sub_eq... ok
Checking: Nat.add_sub_assoc... ok
Checking: Nat.pred_succ... ok
Checking: Nat.pred_mul... ok
Checking: Nat.sub_sub... ok
Checking: Nat.mul_sub_right_distrib... ok
Checking: Nat.Linear.Poly.of_denote_eq_cancelAux... ok
Checking: Char.rec... ok
Checking: Char.casesOn... ok
Checking: _private.Init.Prelude.0.Char.ext.match_1_1... ok
Checking: Char.ext... ok
Checking: Char.val_ne_of_ne... ok
Checking: Lean.Meta.TransparencyMode... ok
Checking: Lean.Meta.TransparencyMode.all... ok
Checking: Lean.Meta.TransparencyMode.default... ok
Checking: Lean.Meta.TransparencyMode.reducible... ok
Checking: Lean.Meta.TransparencyMode.instances... ok
Checking: Lean.Meta.TransparencyMode.rec... ok
Checking: Lean.Meta.TransparencyMode.casesOn... ok
Checking: Lean.Meta.TransparencyMode.ctorIdx... ok
Checking: Lean.Meta.Simp.Config... ok
Checking: Lean.Meta.Simp.Config.mk... ok
Checking: Lean.Meta.Simp.Config.eta... ok
Checking: Lean.Grind.Config.canonHeartbeats... ok
Checking: Lean.instInhabitedSyntax... ok
Checking: Lean.instInhabitedTSyntax... ok
Checking: List.appendTR... ok
Checking: List.appendTR.eq_1... ok
Checking: HasSubset... ok
Checking: HasSubset.mk... ok
Checking: HasSubset.rec... ok
Checking: HasSubset.casesOn... ok
Checking: Option.pbind.match_1... ok
Checking: Option.pbind._proof_1... ok
Checking: Option.pbind... ok
Checking: Option.pbind_none... ok
Checking: Option.map... ok
Checking: Option.getD_map... ok
Checking: Array.rec... ok
Checking: Array.casesOn... ok
Checking: Array.ext'... ok
Checking: Void.nonemptyType... ok
Checking: Void... ok
Checking: ST.Out... ok
Checking: ST.Out.mk... ok
Checking: ST... ok
Checking: HEq.elim... ok
Checking: Membership.rec... ok
Checking: Membership.casesOn... ok
Checking: Membership.noConfusionType... ok
Checking: instLTFin... ok
Checking: Fin.val_add_one_le_of_lt... ok
Checking: _private.Init.Data.List.Lemmas.0.List.mem_flatten.match_1_1... ok
Checking: _private.Init.PropLemmas.0.exists_const.match_1_1... ok
Checking: Nonempty.rec... ok
Checking: Nonempty.casesOn... ok
Checking: _private.Init.Prelude.0.Nonempty.elim.match_1_1... ok
Checking: Nonempty.elim... ok
Checking: exists_const... ok
Checking: exists_const._simp_1... ok
Checking: instNonemptyOfInhabited... ok
Checking: instInhabitedList... ok
Checking: _private.Init.SimpLemmas.0.false_or.match_1_1... ok
Checking: false_or... ok
Checking: _private.Init.Data.List.Lemmas.0.List.mem_append._simp_1_1... ok
Checking: List.mem_append... ok
Checking: List.mem_append._simp_1... ok
Checking: _private.Init.Core.0.And.symm.match_1_1... ok
Checking: And.symm... ok
Checking: And.comm... ok
Checking: and_comm... ok
Checking: _private.Init.PropLemmas.0.and_or_left.match_1_1... ok
Checking: And.imp... ok
Checking: And.imp_right... ok
Checking: and_or_left... ok
Checking: or_and_right... ok
Checking: _private.Init.Data.List.Lemmas.0.List.mem_flatten._simp_1_3... ok
Checking: _private.Init.PropLemmas.0.exists_or.match_1_1... ok
Checking: _private.Init.PropLemmas.0.exists_or.match_1_3... ok
Checking: exists_or... ok
Checking: _private.Init.Data.List.Lemmas.0.List.mem_flatten._simp_1_4... ok
Checking: _private.Init.PropLemmas.0.exists_eq_left.match_1_1... ok
Checking: exists_eq_left... ok
Checking: exists_eq_left._simp_1... ok
Checking: List.mem_flatten... ok
Checking: List.exists_of_mem_flatten... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.zero_lt_of_ne_zero.match_1_1... ok
Checking: Nat.zero_lt_of_ne_zero... ok
Checking: MonadFunctor... ok
Checking: MonadFunctor.mk... ok
Checking: MonadFunctor.rec... ok
Checking: PSigma... ok
Checking: PSigma.mk... ok
Checking: PSigma.rec... ok
Checking: PSigma.casesOn... ok
Checking: PSigma.lex.match_1... ok
Checking: ST.Out.rec... ok
Checking: ST.Out.casesOn... ok
Checking: _private.Init.System.ST.0.ST.bind.match_1... ok
Checking: ST.bind... ok
Checking: ST.pure... ok
Checking: instMonadST... ok
Checking: Classical.inhabited_of_nonempty... ok
Checking: ST.Ref.h... ok
Checking: _private.Init.System.ST.0.ST.Prim.inhabitedFromRef... ok
Checking: ST.Prim.Ref.get... ok
Checking: instInhabitedST... ok
Checking: instInhabitedPUnit... ok
Checking: ST.Prim.Ref.set... ok
Checking: ST.Prim.Ref.modify... ok
Checking: ForM... ok
Checking: ForM.mk... ok
Checking: ForM.rec... ok
Checking: Lean.interpolatedStrLitKind... ok
Checking: emptyRelation... ok
Checking: HDiv.ctorIdx... ok
Checking: Option.pfilter.match_1... ok
Checking: Option.pfilter... ok
Checking: Option.pfilter_none... ok
Checking: MonadFunctorT... ok
Checking: MonadFunctorT.mk... ok
Checking: MonadFunctorT.rec... ok
Checking: MonadFunctorT.casesOn... ok
Checking: MonadFunctorT.noConfusionType... ok
Checking: MonadFunctorT.noConfusion... ok
Checking: MonadFunctorT.mk.noConfusion... ok
Checking: Int.casesOn... ok
Checking: Int.ctorIdx... ok
Checking: PULift... ok
Checking: PULift.up... ok
Checking: Int.ctorElimType... ok
Checking: PULift.down... ok
Checking: Int.ctorElim... ok
Checking: MonadWithReader... ok
Checking: MonadWithReader.mk... ok
Checking: Pow.rec... ok
Checking: Lean.Syntax.TSepArray... ok
Checking: Lean.Syntax.TSepArray.mk... ok
Checking: Lean.Syntax.TSepArray.rec... ok
Checking: Lean.Syntax.TSepArray.casesOn... ok
Checking: Lean.Syntax.TSepArray.noConfusionType... ok
Checking: Lean.Syntax.TSepArray.noConfusion... ok
Checking: Lean.Syntax.TSepArray.mk.noConfusion... ok
Checking: Zero... ok
Checking: Zero.mk... ok
Checking: Lean.Loop... ok
Checking: Lean.Loop.mk... ok
Checking: Lean.Loop.rec... ok
Checking: Lean.Loop.casesOn... ok
Checking: HomogeneousPow... ok
Checking: HomogeneousPow.mk... ok
Checking: Int.negOfNat.match_1... ok
Checking: PartialEquivBEq... ok
Checking: PartialEquivBEq.mk... ok
Checking: Bool.ctorIdx... ok
Checking: Bool.not_eq_true... ok
Checking: Bool.eq_iff_iff... ok
Checking: Std.Symm... ok
Checking: Std.Symm.mk... ok
Checking: Std.Symm.symm... ok
Checking: BEq.symm... ok
Checking: PartialEquivBEq.symm... ok
Checking: instSymmEqBoolBeqTrueOfPartialEquivBEq... ok
Checking: BEq.comm... ok
Checking: Lean.Macro.Context... ok
Checking: Lean.Macro.MethodsRefPointed... ok
Checking: Lean.Macro.MethodsRef... ok
Checking: Lean.MacroScope... ok
Checking: Lean.Macro.Context.mk... ok
Checking: Lean.Macro.Context.maxRecDepth... ok
Checking: Bool.eq_and_self... ok
Checking: Nat.mul_pred... ok
Checking: instLEBitVec... ok
Checking: instLEUInt32... ok
Checking: UInt32.ofNat... ok
Checking: UInt32.instOfNat... ok
Checking: inferInstanceAs... ok
Checking: instDecidableLeBitVec... ok
Checking: UInt32.decLe... ok
Checking: Char.isUpper... ok
Checking: Char.isLower... ok
Checking: Char.isAlpha... ok
Checking: instDecidableEqChar.match_1... ok
Checking: UInt32.rec... ok
Checking: UInt32.casesOn... ok
Checking: UInt32.decEq.match_1... ok
Checking: BitVec.rec... ok
Checking: BitVec.casesOn... ok
Checking: BitVec.decEq.match_1... ok
Checking: instDecidableEqFin.match_1... ok
Checking: _private.Init.Prelude.0.Fin.eq_of_val_eq.match_1_1... ok
Checking: Fin.eq_of_val_eq... ok
Checking: Fin.val_eq_of_eq... ok
Checking: instDecidableEqFin._proof_1... ok
Checking: instDecidableEqFin... ok
Checking: BitVec.decEq._proof_1... ok
Checking: BitVec.noConfusionType... ok
Checking: BitVec.noConfusion... ok
Checking: BitVec.decEq._proof_2... ok
Checking: BitVec.decEq... ok
Checking: instDecidableEqBitVec... ok
Checking: UInt32.decEq._proof_1... ok
Checking: UInt32.noConfusionType... ok
Checking: UInt32.noConfusion... ok
Checking: UInt32.decEq._proof_2... ok
Checking: UInt32.decEq... ok
Checking: instDecidableEqUInt32... ok
Checking: _private.Init.Prelude.0.Char.val_eq_of_eq.match_1_1... ok
Checking: Char.val_eq_of_eq... ok
Checking: Char.ne_of_val_ne... ok
Checking: instDecidableEqChar... ok
Checking: Lean.isLetterLike... ok
Checking: Lean.isIdFirst... ok
Checking: HPow.rec... ok
Checking: HPow.recOn... ok
Checking: PUnit.rec... ok
Checking: PUnit.recOn... ok
Checking: Subsingleton... ok
Checking: Subsingleton.intro... ok
Checking: Iff.trans... ok
Checking: Decidable.or_iff_not_imp_left... ok
Checking: Decidable.or_iff_not_imp_right... ok
Checking: List.getLast!.match_1... ok
Checking: List.getLast!._proof_1... ok
Checking: List.getLast!... ok
Checking: Bool.not... ok
Checking: Bool.not_false... ok
Checking: Bool.not_true... ok
Checking: Bool.not_eq_not... ok
Checking: Nat.shiftLeft.match_1... ok
Checking: Nat.shiftLeft... ok
Checking: List.Perm... ok
Checking: List.Perm.cons... ok
Checking: List.Perm.swap... ok
Checking: List.Perm.trans... ok
Checking: List.Perm.nil... ok
Checking: Array.toListLitAux.match_1... ok
Checking: _private.Init.Meta.Defs.0.Lean.version.getMinor... ok
Checking: Lean.version.minor... ok
Checking: Std.Format.FlattenBehavior.rec... ok
Checking: Std.Format.FlattenBehavior.casesOn... ok
Checking: Std.Format.FlattenBehavior.ctorIdx... ok
Checking: Std.Format.FlattenBehavior.ctorElimType... ok
Checking: Std.Format.FlattenBehavior.ctorElim... ok
Checking: Std.Format.FlattenBehavior.fill.elim... ok
Checking: Lean.Syntax.rec_2... ok
Checking: Lean.Syntax.rec_1... ok
Checking: Lean.Syntax.rec... ok
Checking: Lean.Syntax.casesOn... ok
Checking: Lean.Syntax.ctorIdx... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.structEq._sparseCasesOn_3... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.isLit?.match_1... ok
Checking: String.rec... ok
Checking: String.casesOn... ok
Checking: String.decEq.match_3... ok
Checking: UInt8.rec... ok
Checking: UInt8.casesOn... ok
Checking: UInt8.decEq.match_1... ok
Checking: UInt8.decEq._proof_1... ok
Checking: UInt8.noConfusionType... ok
Checking: UInt8.noConfusion... ok
Checking: UInt8.decEq._proof_2... ok
Checking: UInt8.decEq... ok
Checking: instDecidableEqUInt8... ok
Checking: String.decEq.match_1... ok
Checking: String.decEq._proof_1... ok
Checking: ByteArray.data... ok
Checking: String.decEq._proof_2... ok
Checking: String.decEq... ok
Checking: instDecidableEqString... ok
Checking: String.Internal.trim... ok
Checking: Lean.Syntax.isToken... ok
Checking: CoeOTC... ok
Checking: CoeOTC.mk... ok
Checking: CoeOTC.rec... ok
Checking: CoeOTC.casesOn... ok
Checking: CoeOTC.noConfusionType... ok
Checking: CoeOTC.noConfusion... ok
Checking: CoeOTC.mk.noConfusion... ok
Checking: List.foldl.match_1... ok
Checking: List.foldl... ok
Checking: List.foldlM_pure... ok
Checking: List.foldl_eq_foldlM... ok
Checking: List.id_run_foldlM... FAIL
Checking: Lean.Meta.Omega.OmegaConfig.rec... ok
Checking: Lean.Meta.Omega.OmegaConfig.casesOn... ok
Checking: Lean.Meta.Omega.OmegaConfig.noConfusionType... ok
Checking: Lean.Meta.Omega.OmegaConfig.noConfusion... ok
Checking: Lean.Meta.Omega.OmegaConfig.mk.noConfusion... ok
Checking: ShiftRight... ok
Checking: ShiftRight.mk... ok
Checking: ShiftRight.ctorIdx... ok
Checking: List.Lex... ok
Checking: List.Lex.nil... ok
Checking: List.Lex.rel... ok
Checking: List.Lex.cons... ok
Checking: List.Lex.below... ok
Checking: List.Lex.below.nil... ok
Checking: List.Lex.below.rel... ok
Checking: List.Lex.below.cons... ok
Checking: List.Lex.below.rec... ok
Checking: List.Lex.below.casesOn... ok
Checking: CoeDep... ok
Checking: CoeDep.mk... ok
Checking: CoeDep.rec... ok
Checking: CoeDep.casesOn... ok
Checking: CoeDep.noConfusionType... ok
Checking: CoeDep.noConfusion... ok
Checking: Lean.Parser.Tactic.rewrites_forbidden... ok
Checking: _private.Init.PropLemmas.0.exists_prop_congr.match_1_1... ok
Checking: _private.Init.PropLemmas.0.exists_prop_congr.match_1_3... ok
Checking: exists_prop_congr... ok
Checking: exists_prop_of_true... ok
Checking: exists_true_left... ok
Checking: exists_true_left._simp_1... ok
Checking: _private.Init.PropLemmas.0.forall_exists_index.match_1_1... ok
Checking: forall_exists_index... ok
Checking: exists_imp... ok
Checking: not_exists... ok
Checking: not_exists._simp_1... ok
Checking: forall_false... ok
Checking: List.mem_dite_nil_left... ok
Checking: DoResultPR... ok
Checking: DoResultPR.pure... ok
Checking: DoResultPR.return... ok
Checking: DoResultPR.rec... ok
Checking: DoResultPR.casesOn... ok
Checking: DoResultPR.noConfusionType... ok
Checking: DoResultPR.noConfusion... ok
Checking: DoResultPR.pure.noConfusion... ok
Checking: DoResultPR.pure.injEq... ok
Checking: Classical.exists_or_forall_not... ok
Checking: MonadState... ok
Checking: MonadState.mk... ok
Checking: MonadState.rec... ok
Checking: MonadState.recOn... ok
Checking: List.filter_cons_of_pos... ok
Checking: or_and_left... ok
Checking: _private.Init.Data.List.Lemmas.0.List.mem_filter._simp_1_1... ok
Checking: _private.Init.SimpLemmas.0.and_congr_right.match_1_1... ok
Checking: and_congr_right... ok
Checking: and_congr_right_iff... ok
Checking: and_congr_right_iff._simp_1... ok
Checking: implies_dep_congr_ctx... ok
Checking: implies_congr_ctx... ok
Checking: or_iff_right_iff_imp... ok
Checking: or_iff_right_iff_imp._simp_1... ok
Checking: _private.Init.Prelude.0.eq_false_of_ne_true.match_1_1... ok
Checking: eq_false_of_ne_true... ok
Checking: List.filter_cons_of_neg... ok
Checking: Bool.false_eq_true... ok
Checking: _private.Init.Data.List.Lemmas.0.List.mem_filter._simp_1_2... ok
Checking: Iff.comm... ok
Checking: iff_or_self... ok
Checking: iff_or_self._simp_1... ok
Checking: imp_false... ok
Checking: imp_false._simp_1... ok
Checking: not_and... ok
Checking: not_and._simp_1... ok
Checking: List.mem_filter... ok
Checking: _private.Init.GetElem.0.List.getElem_mem.match_1_1... ok
Checking: List.getElem_mem... ok
Checking: List.getElem_filter... ok
Checking: List.getElem?_filter... ok
Checking: Max... ok
Checking: Max.mk... ok
Checking: Max.rec... ok
Checking: Max.casesOn... ok
Checking: Max.noConfusionType... ok
Checking: DecidableRel... ok
Checking: minOfLe... ok
Checking: instMinNat... ok
Checking: Array.appendCore.loop.match_1... ok
Checking: Array.getInternal... ok
Checking: Array.extract.loop... ok
Checking: Array.extract... ok
Checking: _private.Init.Prelude.0.of_decide_eq_self_eq_true.match_1_1... ok
Checking: of_decide_eq_self_eq_true... ok
Checking: instLawfulBEq... ok
Checking: List.getLast.eq_3... ok
Checking: Lean.Meta.Omega.OmegaConfig.ctorIdx... ok
Checking: ShiftLeft... ok
Checking: ShiftLeft.mk... ok
Checking: ShiftLeft.rec... ok
Checking: ShiftLeft.recOn... ok
Checking: Lean.Macro.Methods... ok
Checking: EStateM.Result... ok
Checking: EStateM.Result.ok... ok
Checking: EStateM.Result.error... ok
Checking: EStateM... ok
Checking: Lean.Macro.Exception... ok
Checking: Lean.Macro.Exception.error... ok
Checking: Lean.Macro.Exception.unsupportedSyntax... ok
Checking: Lean.Macro.State... ok
Checking: _private.Init.Prelude.0.Lean.Macro.State.mk... ok
Checking: Lean.MacroM... ok
Checking: Lean.Macro.Methods.mk... ok
Checking: Lean.Macro.Methods.rec... ok
Checking: Lean.Macro.Methods.casesOn... ok
Checking: Lean.Grind.Config.splits... ok
Checking: Lean.Parser.Tactic.tacticRfl'... ok
Checking: MonadExcept... ok
Checking: MonadExcept.mk... ok
Checking: Except... ok
Checking: Except.error... ok
Checking: Except.ok... ok
Checking: MonadExcept.tryCatch... ok
Checking: observing... ok
Checking: List.all... ok
Checking: List.filter_cons... ok
Checking: List.length_filter_le... ok
Checking: Setoid... ok
Checking: Equivalence... ok
Checking: Equivalence.mk... ok
Checking: Setoid.mk... ok
Checking: Setoid.r... ok
Checking: Quotient... ok
Checking: Quotient.mk... ok
Checking: HasEquiv... ok
Checking: HasEquiv.mk... ok
Checking: HasEquiv.Equiv... ok
Checking: instHasEquivOfSetoid... ok
Checking: Eq.ndrecOn... ok
Checking: PSigma.fst... ok
Checking: Quot.indep... ok
Checking: PSigma.eta... ok
Checking: Quot.indepCoherent... ok
Checking: <anonymous>... ok
Checking: Quot.liftIndepPr1... ok
Checking: PSigma.snd... ok
Checking: Quot.rec... ok
Checking: apply_eqRec... ok
Checking: Quot.pliftOn._proof_1... ok
Checking: Quot.pliftOn._proof_2... ok
Checking: Quot.pliftOn... ok
Checking: Quotient.pliftOn... ok
Checking: Thunk... ok
Checking: Thunk.mk... ok
Checking: Thunk.rec... ok
Checking: Thunk.casesOn... ok
Checking: Thunk.noConfusionType... ok
Checking: Thunk.noConfusion... ok
Checking: Alternative... ok
Checking: Alternative.mk... ok
Checking: OptionT... ok
Checking: OptionT.mk... ok
Checking: OptionT.bind.match_1... ok
Checking: OptionT.bind... ok
Checking: OptionT.pure... ok
Checking: OptionT.instMonad... ok
Checking: OptionT.fail... ok
Checking: OptionT.orElse._sparseCasesOn_1... ok
Checking: OptionT.orElse.match_1... ok
Checking: OptionT.orElse... ok
Checking: OptionT.instAlternative... ok
Checking: Lean.Quote... ok
Checking: Lean.Quote.mk... ok
Checking: Lean.Quote.ctorIdx... ok
Checking: term_⊂_... ok
Checking: Fin.add.match_1... ok
Checking: _private.Init.Data.Nat.Bitwise.Basic.0.Nat.bitwise._unary._proof_1... TIMEOUT
Checking: inferInstance... ok
Checking: _private.Init.Data.Nat.Div.Basic.0.Nat.div_lt_self.match_1_1... ok
Checking: Nat.strongRecOn... ok
Checking: _private.Init.Data.Nat.Div.Basic.0.Nat.div_le_self.match_1_1... ok
Checking: Nat.div_le_self... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.add_le_of_le_sub.match_1_1... ok
Checking: Nat.add_le_of_le_sub... ok
Checking: Nat.div_lt_self... ok
Checking: Nat.bitwise_rec_lemma... ok
Checking: _private.Init.Data.Nat.Bitwise.Basic.0.Nat.bitwise._unary._proof_2... ok
Checking: Nat.bitwise._unary... ok
Checking: Nat.bitwise... ok
Checking: Nat.lor... ok
Checking: _private.Init.Data.Fin.Basic.0.Fin.mlt.match_1_1... ok
Checking: _private.Init.Data.Fin.Basic.0.Fin.mlt... ok
Checking: Fin.lor._proof_1... ok
Checking: Fin.lor... ok
Checking: ForInStep._sizeOf_1... ok
Checking: ForInStep._sizeOf_inst... ok
Checking: ForInStep.done.sizeOf_spec... ok
Checking: Bool.eq_or_not_self... ok
Checking: Lean.Name.rec... ok
Checking: Lean.Name.casesOn... ok
Checking: Lean.Name.ctorIdx... ok
Checking: Lean.Name.ctorElimType... ok
Checking: Lean.Name.ctorElim... ok
Checking: Lean.Name.anonymous.elim... ok
Checking: Lean.Name.str.elim... ok
Checking: Lean.Name.num.elim... ok
Checking: Lean.Name.noConfusionType... ok
Checking: _private.Init.PropLemmas.0.forall_and.match_1_1... ok
Checking: forall_and... ok
Checking: List.beq._sparseCasesOn_1... ok
Checking: List.beq._sparseCasesOn_2... ok
Checking: List.beq.match_1... ok
Checking: List.beq... ok
Checking: List.instBEq... ok
Checking: List.isEmpty... ok
Checking: List.nil_beq_eq... ok
Checking: Option.bind.match_1... ok
Checking: Option.bind... ok
Checking: Option.bind.eq_2... ok
Checking: List.flatMap_nil... FAIL
Checking: List.flatMap_cons... FAIL
Checking: List.flatMap_append... ok
Checking: List.reverse_append... ok
Checking: List.flatMap_reverse... ok
Checking: List.replace.match_1... ok
Checking: List.replace... ok
Checking: List.length_replace... ok
Checking: List.getElem_replace._proof_1... ok
Checking: List.take.match_1... ok
Checking: List.take... ok
Checking: decidable_of_decidable_of_iff._proof_1... ok
Checking: decidable_of_decidable_of_iff... ok
Checking: _private.Init.Data.List.Basic.0.List.mem_of_elem_eq_true.match_1_1... ok
Checking: false_implies... ok
Checking: _private.Init.Data.List.Basic.0.List.filter.match_1.splitter... ok
Checking: List.mem_of_elem_eq_true... ok
Checking: List.elem_eq_true_of_mem... ok
Checking: List.instDecidableMemOfLawfulBEq._proof_1... ok
Checking: List.instDecidableMemOfLawfulBEq... ok
Checking: Option.some.inj... ok
Checking: Option.instBEq.beq._sparseCasesOn_1... ok
Checking: Option.instBEq.beq.match_1... ok
Checking: Option.instBEq.beq... ok
Checking: Option.instBEq... ok
Checking: _private.Init.PropLemmas.0.or_imp.match_1_1... ok
Checking: or_imp... ok
Checking: not_or... ok
Checking: not_or._simp_1... ok
Checking: List.replace_of_not_mem... ok
Checking: getElem?_neg... ok
Checking: Nat.not_lt_zero._simp_1... ok
Checking: _private.Init.Data.Option.Basic.0.Option.instReflBEq.match_1... ok
Checking: Option.instReflBEq... ok
Checking: EquivBEq... ok
Checking: EquivBEq.mk... ok
Checking: EquivBEq.toReflBEq... ok
Checking: instEquivBEqOfLawfulBEq... ok
Checking: ne_eq... ok
Checking: beq_eq_false_iff_ne... ok
Checking: beq_eq_false_iff_ne._simp_1... ok
Checking: _private.Init.Data.Option.Basic.0.Option.instLawfulBEq.match_1... ok
Checking: Option.instLawfulBEq... ok
Checking: List.getElem?_replace... ok
Checking: List.getElem_replace... ok
Checking: List.getElem_replace_of_ne... ok
Checking: Option.isSome... ok
Checking: Option.filter... ok
Checking: Option.get.match_1... ok
Checking: Option.get... ok
Checking: Option.isSome_of_isSome_filter... ok
Checking: true_iff... ok
Checking: Option.isSome_dite... ok
Checking: Option.isSome_dite._simp_1... ok
Checking: Option.get_dite._proof_1... ok
Checking: Option.get.congr_simp... ok
Checking: Option.get_dite... ok
Checking: Eq.mpr_prop... ok
Checking: Eq.mpr_not... ok
Checking: dite_congr... ok
Checking: Option.isSome_ite... ok
Checking: Option.isSome_ite._simp_1... ok
Checking: Option.get_ite... ok
Checking: Option.get_filter... ok
Checking: List.foldl_append... ok
Checking: List.foldl_flatMap... ok
Checking: Classical.axiomOfChoice... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.eq_zero_or_pos.match_1_1... ok
Checking: Nat.eq_zero_or_pos... ok
Checking: Lean.RArray.below... ok
Checking: Lean.RArray.brecOn.go... ok
Checking: Lean.RArray.brecOn... ok
Checking: Lean.RArray.casesOn... ok
Checking: Lean.RArray.getImpl.match_1... ok
Checking: Lean.RArray.getImpl... ok
Checking: Lean.RArray.brecOn.eq... ok
Checking: _private.Init.Data.RArray.0.Lean.RArray.getImpl.match_1.splitter... ok
Checking: Lean.RArray.getImpl.eq_def... ok
Checking: PartialEquivBEq.trans... ok
Checking: _private.Init.Data.Bool.0.Bool.forall_bool'.match_1_1... ok
Checking: Bool.forall_bool'... ok
Checking: Lean.TSyntax.rec... ok
Checking: Lean.TSyntax.casesOn... ok
Checking: Lean.TSyntax.noConfusionType... ok
Checking: Lean.TSyntax.noConfusion... ok
Checking: List.toByteArray.eq_1... ok
Checking: List.brecOn.eq... ok
Checking: _private.Init.Data.ByteArray.Bootstrap.0.List.toByteArray.match_1.splitter... ok
Checking: List.toByteArray.loop.eq_def... ok
Checking: heq_of_eq... ok
Checking: _private.Init.Data.ByteArray.Bootstrap.0.List.toByteArray.match_1.congr_eq_1... ok
Checking: _private.Init.Data.ByteArray.Bootstrap.0.List.toByteArray.match_1.congr_eq_2... ok
Checking: List.toByteArray.loop.induct_unfolding... FAIL
Checking: _private.Init.Data.ByteArray.Bootstrap.0.List.toList_data_toByteArray.match_1_1... ok
Checking: List.concat_eq_append... ok
Checking: _private.Init.Data.ByteArray.Bootstrap.0.List.toList_data_toByteArray.toList_push... ok
Checking: List.toList_data_toByteArray... ok
Checking: Lean.Parser.Category... ok
Checking: Lean.Parser.Category.mk... ok
Checking: Lean.Parser.Category.attr... ok
Checking: Lean.PrettyPrinter.UnexpandM... ok
Checking: Lean.PrettyPrinter.Unexpander... ok
Checking: Lean.Name.below... ok
Checking: Lean.Name.brecOn.go... ok
Checking: Lean.Name.brecOn... ok
Checking: _private.Init.Prelude.0.Lean.Name.beq.match_1... ok
Checking: Lean.Name.beq... ok
Checking: Lean.Name.instBEq... ok
Checking: _private.Init.Prelude.0.Lean.Syntax.getKind.match_1... ok
Checking: Lean.Name.mkSimple... ok
Checking: Lean.identKind... ok
Checking: Lean.Syntax.getKind... ok
Checking: Lean.Syntax.isOfKind... ok
Checking: _private.Init.Prelude.0.Lean.Syntax.setKind.match_1... ok
Checking: Array.getD... ok
Checking: Lean.Syntax.getArg... ok
Checking: Lean.Syntax.getNumArgs... ok
Checking: Lean.Syntax.isNodeOf... ok
Checking: Lean.nullKind... ok
Checking: Lean.Syntax.matchesNull... ok
Checking: ReaderT.bind... ok
Checking: ReaderT.instMonad... ok
Checking: EStateM.Result.rec... ok
Checking: EStateM.Result.casesOn... ok
Checking: EStateM.bind.match_1... ok
Checking: EStateM.map... ok
Checking: EStateM.pure... ok
Checking: EStateM.bind... ok
Checking: EStateM.seqRight... ok
Checking: EStateM.instMonad... ok
Checking: Lean.MonadRef... ok
Checking: Lean.MonadRef.mk... ok
Checking: Lean.MonadRef.getRef... ok
Checking: _private.Init.Prelude.0.Lean.SourceInfo.fromRef.match_1... ok
Checking: Lean.SourceInfo.rec... ok
Checking: Lean.SourceInfo.casesOn... ok
Checking: _private.Init.Prelude.0.Lean.SourceInfo.getPos?.match_1... ok
Checking: Lean.SourceInfo.getPos?... ok
Checking: _private.Init.Prelude.0.Lean.Syntax.getHeadInfo?.loop.match_1... ok
Checking: Lean.Syntax.getHeadInfo?... ok
Checking: Lean.Syntax.getHeadInfo... ok
Checking: Lean.Syntax.getPos?... ok
Checking: Lean.Syntax.getTailPos?... ok
Checking: Lean.SourceInfo.fromRef... ok
Checking: Lean.MonadRef.mkInfoFromRefPos... ok
Checking: Lean.MonadQuotation... ok
Checking: Lean.MonadQuotation.mk... ok
Checking: Lean.MonadQuotation.toMonadRef... ok
Checking: MonadReader... ok
Checking: MonadReader.mk... ok
Checking: MonadReader.read... ok
Checking: readThe... ok
Checking: instMonadReaderOfMonadReaderOf... ok
Checking: ReaderT.read... ok
Checking: instMonadReaderOfReaderTOfMonad... ok
Checking: MonadWithReader.withReader... ok
Checking: MonadWithReaderOf... ok
Checking: MonadWithReaderOf.mk... ok
Checking: MonadWithReaderOf.withReader... ok
Checking: withTheReader... ok
Checking: instMonadWithReaderOfMonadWithReaderOf... ok
Checking: instMonadWithReaderOfReaderT... ok
Checking: Lean.PrettyPrinter.instMonadQuotationUnexpandM... ok
Checking: Lean.MonadQuotation.getCurrMacroScope... ok
Checking: Lean.MonadQuotation.getContext... ok
Checking: Array.mkArray3... ok
Checking: Lean.Syntax.node3... ok
Checking: List.toArray... ok
Checking: MonadExcept.throw... ok
Checking: MonadExceptOf... ok
Checking: MonadExceptOf.mk... ok
Checking: MonadExceptOf.throw... ok
Checking: throwThe... ok
Checking: MonadExceptOf.tryCatch... ok
Checking: tryCatchThe... ok
Checking: instMonadExceptOfMonadExceptOf... ok
Checking: MonadLiftT... ok
Checking: MonadLiftT.mk... ok
Checking: MonadLiftT.monadLift... ok
Checking: liftM... ok
Checking: MonadLift... ok
Checking: MonadLift.mk... ok
Checking: MonadLift.monadLift... ok
Checking: instMonadLiftTOfMonadLift... ok
Checking: ReaderT.instMonadLift... ok
Checking: instMonadLiftT... ok
Checking: ReaderT.instMonadExceptOf... ok
Checking: EStateM.Backtrackable... ok
Checking: EStateM.Backtrackable.mk... ok
Checking: EStateM.throw... ok
Checking: EStateM.Backtrackable.save... ok
Checking: EStateM.tryCatch.match_1... ok
Checking: EStateM.Backtrackable.restore... ok
Checking: EStateM.tryCatch... ok
Checking: EStateM.instMonadExceptOfOfBacktrackable... ok
Checking: EStateM.dummySave... ok
Checking: EStateM.dummyRestore... ok
Checking: EStateM.nonBacktrackable... ok
Checking: unexpandMkArray8... ok
Checking: ForInStep.ctorIdx... ok
Checking: WellFounded.recOn... ok
Checking: _private.Init.Data.List.Control.0.List.filterAuxM.match_1... ok
Checking: List.filterAuxM... ok
Checking: List.filterM... ok
Checking: Option.bind.eq_1... ok
Checking: DoResultBC... ok
Checking: DoResultBC.break... ok
Checking: DoResultBC.continue... ok
Checking: DoResultBC.rec... ok
Checking: DoResultBC.casesOn... ok
Checking: DoResultBC.noConfusionType... ok
Checking: DoResultBC.noConfusion... ok
Checking: DoResultBC.break.noConfusion... ok
Checking: DoResultBC.break.injEq... ok
Checking: PUnit._sizeOf_1... ok
Checking: PUnit._sizeOf_inst... ok
Checking: PUnit.unit.sizeOf_spec... ok
Checking: NonScalar... ok
Checking: NonScalar.mk... ok
Checking: NonScalar.rec... ok
Checking: true_implies... ok
Checking: if_true_right... ok
Checking: Lean.Parser.Tactic.posConfigItem... ok
Checking: Lean.Parser.Tactic.negConfigItem... ok
Checking: Lean.Parser.Tactic.valConfigItem... ok
Checking: Lean.Parser.Tactic.configItem... ok
Checking: Lean.Parser.Tactic.optConfig... ok
Checking: Lean.Parser.Tactic.discharger... ok
Checking: Lean.Parser.Tactic.simpStar... ok
Checking: Lean.Parser.Tactic.simpErase... ok
Checking: Lean.Parser.Tactic.simpPre... ok
Checking: Lean.Parser.Tactic.simpPost... ok
Checking: Lean.Parser.Tactic.simpLemma... ok
Checking: Lean.Parser.Tactic.simpArg... ok
Checking: Lean.Parser.Tactic.simpArgs... ok
Checking: Lean.Parser.Tactic.simpaArgsRest... ok
Checking: Lean.Parser.Tactic.tacticSimpa?!_... ok
Checking: Lean.Parser.Tactic.tacticAdmit... ok
Checking: Subtype.rec... ok
Checking: Subtype.casesOn... ok
Checking: _private.Init.Core.0.Subtype.ext.match_1_1... ok
Checking: Subtype.ext... ok
Checking: Subtype.ext_iff... ok
Checking: prec(_)... ok
Checking: Array.get!Internal... ok
Checking: Array.instGetElemNatLtSize... ok
Checking: decidableGetElem?... ok
Checking: Array.instGetElem?NatLtSize... ok
Checking: LawfulGetElem.getElem!_def... ok
Checking: Array.instLawfulGetElemNatLtSize... ok
Checking: Array.get!Internal_eq_getElem!... ok
Checking: Option._sizeOf_1... ok
Checking: Option._sizeOf_inst... ok
Checking: Option.none.sizeOf_spec... ok
Checking: outOfBounds... ok
Checking: UInt64.size... ok
Checking: Nat.zero_div... ok
Checking: Nat.div_eq_sub_div... ok
Checking: Nat.add_div_right... ok
Checking: Nat.mul_div_right... ok
Checking: Nat.mul_div_left... ok
Checking: Bool.not_eq_eq_eq_not... ok
Checking: Bool.not_eq_eq_eq_not._simp_1... ok
Checking: Bool.not_eq_not._simp_1... ok
Checking: Bool.not_not_eq... ok
Checking: dite_cond_eq_true... ok
Checking: Nat.le_of_not_gt... ok
Checking: of_eq_false... ok
Checking: dite_cond_eq_false... ok
Checking: List.getD_getElem?... ok
Checking: Lean.SourceInfo.ctorIdx... ok
Checking: Lean.SourceInfo.ctorElimType... ok
Checking: Lean.SourceInfo.ctorElim... ok
Checking: Lean.SourceInfo.none.elim... ok
Checking: Eq.substr... ok
Checking: forall_prop_domain_congr... ok
Checking: imp_iff_right... ok
Checking: Decidable.imp_iff_right_iff... ok
Checking: Decidable.imp_iff_left_iff... ok
Checking: Decidable.imp_iff_left_iff._simp_1... ok
Checking: dite_eq_left_iff... ok
Checking: _private.Init.Meta.Defs.0.Lean.Name.getRoot._sparseCasesOn_1... ok
Checking: _private.Init.Meta.Defs.0.Lean.Name.getRoot.match_1... ok
Checking: Lean.Name.getRoot... ok
Checking: List.findIdx.go.match_1... ok
Checking: List.findIdx.go... ok
Checking: List.findIdx... ok
Checking: List.idxOf... ok
Checking: HMul.rec... ok
Checking: HMul.recOn... ok
Checking: Bool.not_and_self... ok
Checking: Nat.Linear.Poly.insert... ok
Checking: Nat.Linear.Poly.norm.go... ok
Checking: Nat.Linear.Poly.norm.go.eq_2... ok
Checking: Applicative.rec... ok
Checking: Applicative.casesOn... ok
Checking: Applicative.noConfusionType... ok
Checking: _private.Init.Data.List.Lemmas.0.List.length_pos_of_mem.match_1_1... ok
Checking: List.length_pos_of_mem... ok
Checking: bne... ok
Checking: HAnd... ok
Checking: HAnd.mk... ok
Checking: HAnd.hAnd... ok
Checking: AndOp... ok
Checking: AndOp.mk... ok
Checking: AndOp.and... ok
Checking: instHAndOfAndOp... ok
Checking: Nat.land... ok
Checking: Nat.instAndOp... ok
Checking: HShiftRight... ok
Checking: HShiftRight.mk... ok
Checking: HShiftRight.hShiftRight... ok
Checking: ShiftRight.shiftRight... ok
Checking: instHShiftRightOfShiftRight... ok
Checking: Nat.shiftRight... ok
Checking: Nat.instShiftRight... ok
Checking: Nat.testBit... ok
Checking: Lean.Parser.Tactic.locationWildcard... ok
Checking: Lean.Parser.Tactic.locationType... ok
Checking: Lean.Parser.Tactic.locationHyp... ok
Checking: Lean.Parser.Tactic.location... ok
Checking: Lean.Parser.Tactic.split... ok
Checking: USize... ok
Checking: _private.Init.Prelude.0.System.Platform.getNumBits._proof_1... ok
Checking: System.Platform.getNumBits... ok
Checking: System.Platform.numBits... ok
Checking: USize.ofBitVec... ok
Checking: USize.toBitVec... ok
Checking: USize.le... ok
Checking: instLEUSize... ok
Checking: EST.Out... ok
Checking: EST.Out.ok... ok
Checking: EST.Out.error... ok
Checking: Relation.TransGen... ok
Checking: Relation.TransGen.single... ok
Checking: Relation.TransGen.tail... ok
Checking: Relation.TransGen.rec... ok
Checking: Relation.TransGen.casesOn... ok
Checking: Acc.transGen... ok
Checking: Lean.Name.mkStr5... ok
Checking: Lean.Parser.Tactic.Conv.convTrace_state... ok
Checking: Quotient.lift... ok
Checking: Equivalence.refl... ok
Checking: Setoid.iseqv... ok
Checking: Setoid.refl... ok
Checking: Quotient.lift₂._proof_1... ok
Checking: Quotient.ind... ok
Checking: Quotient.lift₂._proof_2... ok
Checking: Quotient.lift₂... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.le_sub_of_add_le.match_1_1... ok
Checking: Nat.sub_eq_of_eq_add... ok
Checking: Nat.le_sub_of_add_le... ok
Checking: List.removeAll... ok
Checking: List.IsInfix... ok
Checking: ForIn'... ok
Checking: ForIn'.mk... ok
Checking: Array.Mem... ok
Checking: Array.Mem.mk... ok
Checking: Array.instMembership... ok
Checking: Array.forIn'.loop.match_3... ok
Checking: Array.forIn'.loop._proof_1... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.zero_lt_of_lt.match_1_1... ok
Checking: Nat.zero_lt_of_lt... ok
Checking: Array.forIn'._proof_1... ok
Checking: Array.forIn'.loop._proof_2... ok
Checking: Array.forIn'.loop._proof_3... ok
Checking: Array.Mem.rec... ok
Checking: Array.Mem.casesOn... ok
Checking: _private.Init.Data.Array.Basic.0.Array.mem_def.match_1_1... ok
Checking: Array.mem_def... ok
Checking: Array.getElem_toList... ok
Checking: Array.getElem_mem... ok
Checking: Array.forIn'.loop._proof_4... ok
Checking: Array.forIn'.loop.match_1... ok
Checking: Array.forIn'.loop._proof_5... ok
Checking: Array.forIn'.loop... ok
Checking: Array.forIn'._proof_2... ok
Checking: Array.forIn'... ok
Checking: Array.instForIn'InferInstanceMembership... ok
Checking: NeZero... ok
Checking: Zero.zero... ok
Checking: Zero.toOfNat0... ok
Checking: NeZero.mk... ok
Checking: NeZero.out... ok
Checking: neZero_iff... ok
Checking: Div.rec... ok
Checking: Div.recOn... ok
Checking: String.noConfusionType... ok
Checking: String.noConfusion... ok
Checking: String.ofByteArray.noConfusion... ok
Checking: String.ofByteArray.inj... ok
Checking: Lean.Syntax.below... ok
Checking: Lean.Syntax.below_1... ok
Checking: Lean.Syntax.below_2... ok
Checking: Lean.Syntax.brecOn_1.go... ok
Checking: Lean.Syntax.brecOn_1... ok
Checking: Insert... ok
Checking: Insert.mk... ok
Checking: Insert.insert... ok
Checking: Lean.RArray.getImpl.eq_2... ok
Checking: _private.Init.Data.RArray.0.Lean.RArray.get_eq_def.match_1... ok
Checking: _private.Init.Data.RArray.0.Lean.RArray.get_eq_def.match_1.splitter... ok
Checking: _private.Init.Data.RArray.0.Lean.RArray.get_eq_def... ok
Checking: _private.Init.Data.RArray.0.Lean.RArray.get_eq_getImpl._simp_1_4... ok
Checking: Nat.ble_eq... ok
Checking: _private.Init.Data.RArray.0.Lean.RArray.get_eq_getImpl._simp_1_5... ok
Checking: not_not_intro... ok
Checking: dite_not... ok
Checking: ite_not... ok
Checking: Lean.RArray.get_eq_getImpl... ok
Checking: OptionT.fail.eq_1... ok
Checking: Option.instMembership... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.not_mem_none.match_1_1... ok
Checking: Option.not_mem_none... ok
Checking: Lean.Grind.Config.instances... ok
Checking: PProd.fst... ok
Checking: PProd.snd... ok
Checking: PProd.rec... ok
Checking: PProd.casesOn... ok
Checking: _private.Init.Ext.0.PProd.ext.match_1... ok
Checking: PProd.ext... ok
Checking: PProd.ext_iff... ok
Checking: MonadControlT... ok
Checking: MonadControlT.mk... ok
Checking: MonadControlT.stM... ok
Checking: Nat.lt_of_lt_of_eq... ok
Checking: Nat.add_one_ne... ok
Checking: Decidable.byContradiction... ok
Checking: Decidable.of_not_not... ok
Checking: Decidable.not_not... ok
Checking: Decidable.not_not._simp_1... ok
Checking: Option.isSome_ite'... ok
Checking: imp_intro... ok
Checking: Pow.casesOn... ok
Checking: Pow.noConfusionType... ok
Checking: PSum... ok
Checking: PSum.inl... ok
Checking: PSum.inr... ok
Checking: PSum.rec... ok
Checking: PSum.casesOn... ok
Checking: PSum.noConfusionType... ok
Checking: List.decidableLex.match_13... ok
Checking: List.Lex.rec... ok
Checking: List.Lex.casesOn... ok
Checking: List.decidableLex.match_1... ok
Checking: List.decidableLex._proof_1... ok
Checking: List.decidableLex.match_3... ok
Checking: List.decidableLex._proof_2... ok
Checking: List.decidableLex.match_11... ok
Checking: List.decidableLex.match_7... ok
Checking: List.decidableLex._proof_3... ok
Checking: List.decidableLex.match_5... ok
Checking: List.decidableLex._proof_4... ok
Checking: List.decidableLex.match_9... ok
Checking: List.decidableLex._proof_5... ok
Checking: List.decidableLex... ok
Checking: Lean.Parser.Tactic.simpTraceArgsRest... ok
Checking: Lean.Parser.Tactic.simpTrace... ok
Checking: Fin.elim0.match_1... ok
Checking: Fin.elim0... ok
Checking: Lean.strLitKind... ok
Checking: Lean.Syntax.StrLit... ok
Checking: Lean.mkNode... ok
Checking: Lean.Syntax.mkLit... ok
Checking: instInhabitedBool.default... ok
Checking: instInhabitedBool... ok
Checking: String.Internal.isEmpty... ok
Checking: String.Internal.foldl... ok
Checking: Char.toNat... ok
Checking: String.push.match_1... ok
Checking: ByteArray.append... ok
Checking: ByteArray.IsValidUTF8.rec... ok
Checking: ByteArray.IsValidUTF8.casesOn... ok
Checking: _private.Init.Data.String.Bootstrap.0.String.push.match_2... ok
Checking: _private.Init.Data.ByteArray.Bootstrap.0.ByteArray.ext.match_1_1... ok
Checking: ByteArray.ext... ok
Checking: _private.Init.Data.ByteArray.Bootstrap.0.List.toByteArray_append'.ext.match_1... ok
Checking: _private.Init.Data.ByteArray.Bootstrap.0.List.toByteArray_append'.ext... ok
Checking: _private.Init.Data.ByteArray.Bootstrap.0.ByteArray.toList_data_append'.match_1_1... ok
Checking: ByteArray.toList_data_append'... ok
Checking: List.toByteArray_append'... ok
Checking: String.push._proof_5... ok
Checking: String.push... ok
Checking: String.singleton... ok
Checking: hexDigitRepr... ok
Checking: _private.Init.Data.Repr.0.Char.quoteCore.smallCharToHex... ok
Checking: Char.quoteCore... ok
Checking: String.quote... ok
Checking: Lean.Syntax.mkStrLit... ok
Checking: MonadFinally... ok
Checking: MonadFinally.mk... ok
Checking: MonadFinally.tryFinally'... ok
Checking: StateT.tryFinally.match_1... ok
Checking: StateT.tryFinally.match_3... ok
Checking: StateT.tryFinally... ok
Checking: Option.map_pbind... ok
Checking: _private.Init.Classical.0.Classical.exists_true_of_nonempty.match_1_1... ok
Checking: Classical.exists_true_of_nonempty... ok
Checking: instInhabitedOfMonad... ok
Checking: _private.Init.Meta.Defs.0.Array.mapSepElemsMAux... ok
Checking: Array.mapSepElemsM... ok
Checking: Array.mapSepElems... ok
Checking: EStateM.Result.ctorIdx... ok
Checking: _private.Init.Control.EState.0.EStateM.orElse'._sparseCasesOn_1... ok
Checking: _private.Init.Control.EState.0.EStateM.orElse'.match_1... ok
Checking: EStateM.orElse'... ok
Checking: List.cons.injEq... ok
Checking: NeZero.ne... ok
Checking: neZero_zero_iff_false... ok
Checking: Lean.ParserDescr.rec... ok
Checking: Lean.ParserDescr.casesOn... ok
Checking: Lean.ParserDescr.ctorIdx... ok
Checking: Lean.ParserDescr.ctorElimType... ok
Checking: Lean.ParserDescr.ctorElim... ok
Checking: Lean.ParserDescr.sepBy1.elim... ok
Checking: Lean.Name.mkNum... ok
Checking: Lean.Syntax.structEq... ok
Checking: Lean.Syntax.instBEq... ok
Checking: bne_iff_ne... ok
Checking: Union... ok
Checking: Union.mk... ok
Checking: Union.ctorIdx... ok
Checking: Nat.mul_lt_mul_of_pos_left... ok
Checking: Nat.le_of_mul_le_mul_left... ok
Checking: Lean.Syntax.SepArray... ok
Checking: Lean.Syntax.SepArray.mk... ok
Checking: Sum... ok
Checking: Sum.inl... ok
Checking: Sum.inr... ok
Checking: Sum.rec... ok
Checking: Sum.casesOn... ok
Checking: Sum.ctorIdx... ok
Checking: Sum.ctorElimType... ok
Checking: Sum.ctorElim... ok
Checking: DecidableLT... ok
Checking: List.lt... ok
Checking: List.instLT... ok
Checking: List.decidableLT... ok
Checking: MonadState.casesOn... ok
Checking: MonadState.noConfusionType... ok
Checking: MonadState.noConfusion... ok
Checking: MonadState.mk.noConfusion... ok
Checking: coeNotation... ok
Checking: Lean.MacroScopesView... ok
Checking: Lean.MacroScopesView.mk... ok
Checking: Lean.MacroScopesView.rec... ok
Checking: Lean.MacroScopesView.casesOn... ok
Checking: Lean.MacroScopesView.noConfusionType... ok
Checking: Lean.MacroScopesView.noConfusion... ok
Checking: Lean.MacroScopesView.mk.noConfusion... ok
Checking: Lean.Parser.Attr.grindCases... ok
Checking: Function.comp_def... ok
Checking: Lean.ParserDescr.const.elim... ok
Checking: Lean.ParserDescr.unary.elim... ok
Checking: Lean.ParserDescr.binary.elim... ok
Checking: Lean.ParserDescr.node.elim... ok
Checking: Lean.ParserDescr.trailingNode.elim... ok
Checking: Lean.ParserDescr.symbol.elim... ok
Checking: Lean.ParserDescr.nonReservedSymbol.elim... ok
Checking: Lean.ParserDescr.cat.elim... ok
Checking: Lean.ParserDescr.parser.elim... ok
Checking: Lean.ParserDescr.nodeWithAntiquot.elim... ok
Checking: Lean.ParserDescr.sepBy.elim... ok
Checking: Lean.ParserDescr.unicodeSymbol.elim... ok
Checking: Lean.ParserDescr.noConfusionType... ok
Checking: Lean.ParserDescr.noConfusion... ok
Checking: Lean.ParserDescr.nodeWithAntiquot.noConfusion... ok
Checking: Lean.Name.sizeOf.match_1... ok
Checking: List._sizeOf_1... ok
Checking: List._sizeOf_inst... ok
Checking: Array._sizeOf_1... ok
Checking: Array._sizeOf_inst... ok
Checking: default.sizeOf.match_1... ok
Checking: default.sizeOf... ok
Checking: instSizeOfDefault... ok
Checking: Fin._sizeOf_1... ok
Checking: Fin._sizeOf_inst... ok
Checking: BitVec._sizeOf_1... ok
Checking: BitVec._sizeOf_inst... ok
Checking: UInt8._sizeOf_1... ok
Checking: UInt8._sizeOf_inst... ok
Checking: ByteArray._sizeOf_1... ok
Checking: ByteArray._sizeOf_inst... ok
Checking: String._sizeOf_1... ok
Checking: String._sizeOf_inst... ok
Checking: Lean.Name.sizeOf... ok
Checking: Lean.Parser.Tactic.Conv.simpTrace... ok
Checking: Lean.Parser.Category.rcasesPat... ok
Checking: instReprId... ok
Checking: _private.Init.GetElem.0.getElem?_eq_some_iff.match_1_1... ok
Checking: getElem?_eq_some_iff... ok
Checking: MonadControl... ok
Checking: MonadControl.mk... ok
Checking: MonadControl.rec... ok
Checking: MonadControl.casesOn... ok
Checking: Lean.Macro.Methods.noConfusionType... ok
Checking: DoResultPR.ctorIdx... ok
Checking: DoResultPR.ctorElimType... ok
Checking: DoResultPR.ctorElim... ok
Checking: DoResultPR.pure.elim... ok
Checking: Zero.rec... ok
Checking: Zero.casesOn... ok
Checking: Zero.noConfusionType... ok
Checking: Zero.noConfusion... ok
Checking: Option.merge.match_1... ok
Checking: Option.merge... ok
Checking: Option.merge_none_right... ok
Checking: Bool.or_self... ok
Checking: Option.merge_none_left... ok
Checking: Bool.or_false... ok
Checking: Option.any_merge... ok
Checking: Bool.not_and... ok
Checking: List.not_all_eq_any_not... ok
Checking: Nat.le_of_eq... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.le_antisymm_iff.match_1_1... ok
Checking: Nat.le_antisymm_iff... ok
Checking: StateT.map... ok
Checking: StateT.pure... ok
Checking: StateT.instMonad... ok
Checking: StateT.run... ok
Checking: StateT.ext... ok
Checking: _private.Init.Control.Lawful.Instances.0.StateT.run_map._simp_1_3... ok
Checking: StateT.run_map... FAIL
Checking: id_map'... FAIL
Checking: LawfulApplicative._proof_1... ok
Checking: StateT.run_bind... FAIL
Checking: StateT.run_seq... ok
Checking: LawfulMonad._proof_1... ok
Checking: LawfulMonad._proof_2... ok
Checking: LawfulMonad._proof_3... ok
Checking: StateT.run_seqLeft... ok
Checking: _private.Init.Control.Lawful.Instances.0.StateT.seqLeft_eq._simp_1_1... ok
Checking: StateT.seqLeft_eq... ok
Checking: StateT.run_seqRight... ok
Checking: _private.Init.Control.Lawful.Instances.0.StateT.seqRight_eq._simp_1_1... ok
Checking: bind_congr... ok
Checking: StateT.seqRight_eq... ok
Checking: StateT.instLawfulMonad... ok
Checking: List.cons.sizeOf_spec... ok
Checking: term_∪_... ok
Checking: List.head?_append... ok
Checking: Nat.lt_asymm... ok
Checking: Nat.not_lt_of_lt... ok
Checking: and_iff_left_of_imp... ok
Checking: Array.appendCore.loop... ok
Checking: Array.appendCore... ok
Checking: SDiff... ok
Checking: SDiff.mk... ok
Checking: List.insert... ok
Checking: List.elem_iff... ok
Checking: _private.Init.Prelude.0.decide_eq_true.match_1_1... ok
Checking: decide_eq_true... ok
Checking: decide_eq_true_eq... ok
Checking: decide_eq_true_iff... ok
Checking: List.contains_eq_mem... ok
Checking: Subsingleton.allEq... ok
Checking: Subsingleton.elim... ok
Checking: _private.Init.Core.0.instSubsingletonDecidable.match_1... ok
Checking: instSubsingletonDecidable... ok
Checking: Decidable.decide.congr_simp... ok
Checking: _private.Init.Core.0.decide_true.match_1_1... ok
Checking: decide_true... ok
Checking: List.insert_of_mem... ok
Checking: _private.Init.Data.List.Lemmas.0.List.mem_insert_iff.match_1_1... ok
Checking: _private.Init.Core.0.decide_false.match_1_1... ok
Checking: decide_false... ok
Checking: List.insert_of_not_mem... ok
Checking: List.mem_insert_iff... ok
Checking: MonadWithReaderOf.rec... ok
Checking: MonadWithReaderOf.casesOn... ok
Checking: MonadWithReaderOf.noConfusionType... ok
Checking: MonadWithReaderOf.noConfusion... ok
Checking: Coe... ok
Checking: Coe.mk... ok
Checking: Lean.Meta.Occurrences... ok
Checking: Lean.Meta.Occurrences.all... ok
Checking: Lean.Meta.Occurrences.pos... ok
Checking: Lean.Meta.Occurrences.neg... ok
Checking: Lean.Meta.instCoeListNatOccurrences... ok
Checking: Lean.Meta.Simp.Config.rec... ok
Checking: Lean.Meta.Simp.Config.recOn... ok
Checking: IntCast.casesOn... ok
Checking: IntCast.noConfusionType... ok
Checking: IntCast.noConfusion... ok
Checking: Lean.Parser.Attr.grindGen... ok
Checking: Lean.Parser.Attr.grindEqRhs... ok
Checking: List.decidableBEx.match_1... ok
Checking: List.decidableBEx._proof_1... ok
Checking: List.decidableBEx._proof_2... ok
Checking: List.decidableBEx.match_7... ok
Checking: List.decidableBEx.match_3... ok
Checking: List.decidableBEx._proof_3... ok
Checking: List.decidableBEx.match_5... ok
Checking: List.decidableBEx._proof_4... ok
Checking: List.decidableBEx... ok
Checking: Alternative.toApplicative... ok
Checking: OptionT.seq_eq... FAIL
Checking: List.cons_append_fun... ok
Checking: Array.anyM.loop._proof_1... ok
Checking: Array.anyM.loop._proof_2... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.pred_lt.match_1_1... ok
Checking: Nat.pred_lt... ok
Checking: Nat.ne_zero_of_lt... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.zero_lt_sub_of_lt.match_1_1... ok
Checking: Nat.add_sub_self_left... ok
Checking: Nat.sub_le_succ_sub... ok
Checking: Nat.zero_lt_sub_of_lt... ok
Checking: Nat.sub_succ_lt_self... ok
Checking: Array.anyM.loop._proof_3... ok
Checking: Array.anyM.loop... ok
Checking: Array.anyM... ok
Checking: List.foldrRecOn.match_1... ok
Checking: List.mem_cons_of_mem... ok
Checking: List.mem_cons_self... ok
Checking: List.foldrRecOn... ok
Checking: List.reverseAux_reverseAux... ok
Checking: Equivalence.symm... ok
Checking: Setoid.symm... ok
Checking: Pow.noConfusion... ok
Checking: Pow.mk.noConfusion... ok
Checking: MProd... ok
Checking: MProd.mk... ok
Checking: MProd.rec... ok
Checking: MProd.casesOn... ok
Checking: MProd.noConfusionType... ok
Checking: MProd.noConfusion... ok
Checking: MProd.mk.noConfusion... ok
Checking: Prod.Lex... ok
Checking: Prod.Lex.left... ok
Checking: Prod.Lex.right... ok
Checking: Prod.lex.match_1... ok
Checking: Prod.Lex.rec... ok
Checking: Prod.Lex.casesOn... ok
Checking: Prod.noConfusionType... ok
Checking: Prod.noConfusion... ok
Checking: Prod.mk.noConfusion... ok
Checking: Prod.lexAccessible... ok
Checking: Prod.lex._proof_1... ok
Checking: Prod.lex... ok
Checking: Prod.instWellFoundedRelation... ok
Checking: Array.mkArray2... ok
Checking: Lean.Syntax.node2... ok
Checking: Array.mkArray1... ok
Checking: Lean.Syntax.node1... ok
Checking: unexpandTSyntaxArray... ok
Checking: List.head!... ok
Checking: List.foldl_filterMap.match_1... ok
Checking: List.any_filterMap... ok
Checking: List.range.loop.match_1... ok
Checking: Lean.Meta.Occurrences.rec... ok
Checking: Lean.Meta.Occurrences._sizeOf_1... ok
Checking: Lean.Meta.Occurrences._sizeOf_inst... ok
Checking: Lean.Meta.Occurrences.pos.sizeOf_spec... ok
Checking: HAppend.rec... ok
Checking: HAppend.casesOn... ok
Checking: HAppend.noConfusionType... ok
Checking: HAppend.noConfusion... ok
Checking: UInt16... ok
Checking: UInt16.ofBitVec... ok
Checking: UInt16.rec... ok
Checking: UInt16.casesOn... ok
Checking: UInt16.noConfusionType... ok
Checking: UInt16.noConfusion... ok
Checking: MonadReader.rec... ok
Checking: LawfulMonadLiftT... ok
Checking: LawfulMonadLiftT.mk... ok
Checking: LawfulMonadLiftT.monadLift_pure... ok
Checking: List.dropWhile... ok
Checking: List.dropWhile_nil... ok
Checking: Std.Format.instBEqFlattenBehavior.beq... ok
Checking: Std.Format.instBEqFlattenBehavior... ok
Checking: List.findFinIdx?.go.match_1... ok
Checking: Nat.lt_of_add_right_lt... ok
Checking: List.findFinIdx?._proof_1... ok
Checking: _private.Init.Data.List.Basic.0.List.findFinIdx?._simp_2... ok
Checking: List.findFinIdx?._proof_3... ok
Checking: List.findFinIdx?.go... ok
Checking: List.findFinIdx?._proof_4... ok
Checking: List.findFinIdx?... ok
Checking: List.finIdxOf?... ok
Checking: Nat.Linear.Poly.denote_le... ok
Checking: Nat.Linear.hugeFuel... ok
Checking: Nat.Linear.Poly.cancel... ok
Checking: ge_iff_le... ok
Checking: ge_iff_le._simp_1... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.le_add_of_sub_le.match_1_1... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.le_total.match_1_1... ok
Checking: Nat.le_total... ok
Checking: Nat.le_add_of_sub_le... ok
Checking: Nat.Linear.Poly.of_denote_le_cancelAux... ok
Checking: Nat.Linear.Poly.of_denote_le_cancel... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.sub_le_of_le_add.match_1_1... ok
Checking: Nat.sub_le_of_le_add... ok
Checking: Nat.Linear.Poly.denote_le_cancelAux... ok
Checking: Nat.Linear.Poly.denote_le_cancel... ok
Checking: Nat.Linear.Poly.denote_le_cancel_eq... ok
Checking: Fin.val_ne_of_ne... ok
Checking: Lean.Meta.Simp.ConfigCtx... ok
Checking: Lean.Meta.Simp.ConfigCtx.mk... ok
Checking: Lean.Meta.Simp.ConfigCtx.rec... ok
Checking: Lean.Meta.Simp.ConfigCtx.casesOn... ok
Checking: Nat.Linear.Expr.ctorIdx... ok
Checking: Nat.Linear.Expr.ctorElimType... ok
Checking: Nat.Linear.Expr.ctorElim... ok
Checking: Nat.Linear.Expr.num.elim... ok
Checking: Nat.Linear.Expr.var.elim... ok
Checking: Nat.Linear.Expr.add.elim... ok
Checking: Nat.Linear.Expr.mulL.elim... ok
Checking: Nat.Linear.Expr.mulR.elim... ok
Checking: Nat.Linear.Expr.noConfusionType... ok
Checking: Nat.Linear.Expr.noConfusion... ok
Checking: Nat.Linear.Expr.mulR.noConfusion... ok
Checking: Nat.Linear.Expr.mulR.injEq... ok
Checking: Int.neg.match_1... ok
Checking: Int.negOfNat... ok
Checking: Int.neg... ok
Checking: Char.isValidCharNat... ok
Checking: instLTBitVec... ok
Checking: instLTUInt32... ok
Checking: isValidChar... ok
Checking: UInt32.ofNatLT... ok
Checking: _private.Init.Data.Char.Basic.0.Char.isValidUInt32.match_1_1... ok
Checking: Char.isValidUInt32... ok
Checking: _private.Init.Data.Char.Basic.0.Char.isValidChar_of_isValidCharNat.match_1_1... ok
Checking: Zero.ofOfNat0... ok
Checking: Nat.pos_of_ne_zero... ok
Checking: Nat.pos_of_neZero... ok
Checking: Fin.ofNat._proof_1... ok
Checking: Nat.pos_iff_ne_zero... ok
Checking: _private.Init.Data.Nat.Div.Basic.0.Nat.mod_eq_of_lt.match_1_1... ok
Checking: _private.Init.Data.Nat.Div.Basic.0.Nat.modCore_eq_mod.match_1_1... ok
Checking: Nat.modCore.go.eq_1... ok
Checking: _private.Init.Data.Nat.Div.Basic.0.Nat.modCore.go.fuel_congr.match_1_1... ok
Checking: _private.Init.Data.Nat.Div.Basic.0.Nat.modCore.go.fuel_congr... ok
Checking: Nat.modCore_eq... ok
Checking: _private.Init.Data.Nat.Div.Basic.0.Nat.modCore_eq_mod.match_1_3... ok
Checking: Nat.mod.eq_2... ok
Checking: iteInduction... ok
Checking: _private.Init.Data.Nat.Div.Basic.0.Nat.modCore_eq_mod.match_1_8... ok
Checking: Nat.modCore_eq_mod... ok
Checking: Nat.mod_eq... ok
Checking: Nat.mod_eq_of_lt... ok
Checking: Fin.mk.congr_simp... ok
Checking: _private.Init.Data.UInt.BasicAux.0.UInt32.ofNatLT_lt_of_lt._simp_1_7... ok
Checking: UInt32.ofNatLT_lt_of_lt... FAIL
Checking: _private.Init.Data.UInt.BasicAux.0.UInt32.lt_ofNatLT_of_lt._simp_1_7... ok
Checking: UInt32.lt_ofNatLT_of_lt... TIMEOUT
Checking: Char.isValidChar_of_isValidCharNat... ok
Checking: XorOp... ok
Checking: XorOp.mk... ok
Checking: XorOp.rec... ok
Checking: XorOp.casesOn... ok
Checking: XorOp.noConfusionType... ok
Checking: XorOp.noConfusion... ok
Checking: XorOp.mk.noConfusion... ok
Checking: Lean.Macro.Context.ref... ok
Checking: Array.foldlM.loop.match_1... ok
Checking: Array.foldlM.loop._proof_1... ok
Checking: Array.foldlM.loop... ok
Checking: Array.foldlM... ok
Checking: Array.foldl... ok
Checking: _private.Init.Data.Array.Basic.0.Array.unzip.match_1... ok
Checking: _private.Init.Data.Array.Basic.0.Array.unzip.match_3... ok
Checking: Array.unzip... ok
Checking: Nat.sub_lt_right_of_lt_add... ok
Checking: Fin.isLt... ok
Checking: Fin.subNat._proof_1... ok
Checking: Fin.subNat... ok
Checking: Lean.Grind.Config.exp... ok
Checking: LT.rec... ok
Checking: DoResultPR.recOn... ok
Checking: Lean.Meta.DSimp.Config.autoUnfold... ok
Checking: Lean.Quote.rec... ok
Checking: Array.toArray_toList... ok
Checking: HasSSubset... ok
Checking: HasSSubset.mk... ok
Checking: HasSSubset.rec... ok
Checking: HasSSubset.casesOn... ok
Checking: HasSSubset.noConfusionType... ok
Checking: HasSSubset.noConfusion... ok
Checking: NatPow.rec... ok
Checking: NatPow.casesOn... ok
Checking: NatPow.noConfusionType... ok
Checking: NatPow.noConfusion... ok
Checking: Lean.Parser.Tactic.Grind.cases... ok
Checking: Lean.Grind.Config.noConfusionType... ok
Checking: List.zipIdx... ok
Checking: List.zipIdx_nil... ok
Checking: Nat.Linear.ExprCnstr... ok
Checking: Nat.Linear.ExprCnstr.mk... ok
Checking: Nat.Linear.ExprCnstr.rec... ok
Checking: Nat.Linear.ExprCnstr.casesOn... ok
Checking: Nat.Linear.ExprCnstr.noConfusionType... ok
Checking: Nat.Linear.ExprCnstr.noConfusion... ok
Checking: Nat.Linear.ExprCnstr.mk.noConfusion... ok
Checking: Inter... ok
Checking: Inter.mk... ok
Checking: Inter.ctorIdx... ok
Checking: Option.isSome_of_isSome_pbind... ok
Checking: _private.Init.Data.Option.Basic.0.Option.some_get.match_1_1... ok
Checking: Option.some_get... ok
Checking: Option.isSome_get_of_isSome_pbind._proof_1... ok
Checking: Option.isSome_get_of_isSome_pbind... ok
Checking: Inv... ok
Checking: Inv.mk... ok
Checking: Inv.rec... ok
Checking: Inv.casesOn... ok
Checking: Lean.Meta.ApplyConfig... ok
Checking: Lean.Meta.ApplyNewGoals... ok
Checking: Lean.Meta.ApplyNewGoals.nonDependentFirst... ok
Checking: Lean.Meta.ApplyNewGoals.nonDependentOnly... ok
Checking: Lean.Meta.ApplyNewGoals.all... ok
Checking: Lean.Meta.ApplyConfig.mk... ok
Checking: Lean.Meta.ApplyConfig.rec... ok
Checking: Pure.rec... ok
Checking: Pure.recOn... ok
Checking: Option.pelim.match_1... ok
Checking: Option.pelim... ok
Checking: Option.elim.match_1... ok
Checking: Option.elim... ok
Checking: Option.pelim_eq_elim... ok
Checking: Lean.MonadNameGenerator... ok
Checking: Lean.NameGenerator... ok
Checking: Lean.NameGenerator.mk... ok
Checking: Lean.MonadNameGenerator.mk... ok
Checking: Lean.MonadNameGenerator.getNGen... ok
Checking: CoeTail... ok
Checking: CoeTail.mk... ok
Checking: Lean.Parser.Tactic.mleftMacro... ok
Checking: Option.pmap.match_1... ok
Checking: Option.pmap._proof_1... ok
Checking: Option.pmap... ok
Checking: Option.isNone_pmap... ok
Checking: Char.lt... ok
Checking: Char.instLT... ok
Checking: instDecidableLtBitVec... ok
Checking: UInt32.decLt... ok
Checking: Char.instDecidableLt... ok
Checking: Ne.intro... ok
Checking: Array.mkArray7... ok
Checking: Lean.Syntax.node7... ok
Checking: Array.mkArray0... ok
Checking: unexpandGetElem!... ok
Checking: Nonempty.recOn... ok
Checking: Lean.MonadRef.rec... ok
Checking: instSizeOfForallUnit... ok
Checking: Thunk._sizeOf_1... ok
Checking: Thunk._sizeOf_inst... ok
Checking: Thunk.mk.sizeOf_spec... ok
Checking: List.Perm.below... ok
Checking: List.Perm.below.nil... ok
Checking: List.Perm.below.cons... ok
Checking: List.Perm.below.swap... ok
Checking: List.Perm.below.trans... ok
Checking: List.Perm.below.rec... ok
Checking: List.partition.loop.match_1... ok
Checking: String.Internal.atEnd... ok
Checking: List.zipWithM._sparseCasesOn_1... ok
Checking: List.zipWithM.match_1... ok
Checking: HAnd.rec... ok
Checking: HAnd.casesOn... ok
Checking: HAnd.noConfusionType... ok
Checking: HAnd.noConfusion... ok
Checking: Option.isEqSome.match_1... ok
Checking: Option.isEqSome... ok
Checking: Option.isEqSome_eq_beq_some... ok
Checking: Array.replicate... ok
Checking: Option.guard... ok
Checking: Option.guard_pos... ok
Checking: List.foldl_filterMap... ok
Checking: Lean.choiceKind... ok
Checking: Bool.coe_iff_coe... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.lt_pred_iff.match_1_5... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.lt_pred_iff.match_1_1... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.lt_pred_iff.match_1_3... ok
Checking: Nat.succ_lt_succ... ok
Checking: Nat.succ_lt_succ_iff... ok
Checking: Nat.lt_pred_iff... ok
Checking: Lean.Meta.TransparencyMode.ctorElimType... ok
Checking: Lean.Meta.TransparencyMode.ctorElim... ok
Checking: Lean.Meta.TransparencyMode.reducible.elim... ok
Checking: CoeTail.rec... ok
Checking: CoeTail.casesOn... ok
Checking: List.concat_ne_nil... ok
Checking: List.concat_ne_nil._simp_1... ok
Checking: List.getLast_concat._proof_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getLast_concat.match_1_1... ok
Checking: List.getLast_concat... ok
Checking: _private.Init.Data.List.Lemmas.0.List.ne_nil_of_mem.match_1_1... ok
Checking: List.ne_nil_of_mem... ok
Checking: _private.Init.Data.List.Lemmas.0.List.head?_eq_some_head.match_1_1... ok
Checking: List.head?_eq_some_head... ok
Checking: List.insert_eq... ok
Checking: List.head?_insert... ok
Checking: List.head_insert... ok
Checking: Lean.Grind.ConfigInteractive... ok
Checking: Lean.Grind.ConfigInteractive.mk... ok
Checking: Lean.Grind.ConfigInteractive.rec... ok
Checking: Bool._sizeOf_1... ok
Checking: Bool._sizeOf_inst... ok
Checking: Lean.Grind.Config._sizeOf_1... ok
Checking: Lean.Grind.Config._sizeOf_inst... ok
Checking: Lean.Grind.ConfigInteractive._sizeOf_1... ok
Checking: Lean.Grind.ConfigInteractive._sizeOf_inst... ok
Checking: Lean.Grind.ConfigInteractive.mk.sizeOf_spec... ok
Checking: Lean.ParserDescr.sepBy1.noConfusion... ok
Checking: Lean.instQuoteStringStrLitKind... ok
Checking: Lean.Grind.NoopConfig... ok
Checking: Lean.Grind.NoopConfig.mk... ok
Checking: Lean.Grind.NoopConfig.rec... ok
Checking: Lean.Grind.NoopConfig.recOn... ok
Checking: UInt8.ofBitVec.noConfusion... ok
Checking: UInt8.ofBitVec.injEq... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.setTailInfo.match_1... ok
Checking: Lean.Syntax.setTailInfoAux... ok
Checking: Lean.Syntax.setTailInfo... ok
Checking: Bind.rec... ok
Checking: Bind.recOn... ok
Checking: DoResultBC.ctorIdx... ok
Checking: Fin.ofNat... ok
Checking: Fin.instOfNat... ok
Checking: NeZero.rec... ok
Checking: NeZero.casesOn... ok
Checking: _private.Init.Data.NeZero.0.instNeZeroNatHAdd.match_5... ok
Checking: _private.Init.Data.NeZero.0.instNeZeroNatHAdd_1.match_1... ok
Checking: _private.Init.Data.NeZero.0.instNeZeroNatHAdd_1.match_3... ok
Checking: instNeZeroNatHAdd_1... ok
Checking: Nat.instNeZeroSucc... ok
Checking: Fin.zero_eta... TIMEOUT
Checking: PNonScalar... ok
Checking: PNonScalar.mk... ok
Checking: Bool.instLT... ok
Checking: Bool.instLE... ok
Checking: Bool.instDecidableLt... ok
Checking: Bool.instDecidableLe... ok
Checking: Bool.le_of_lt_or_eq... ok
Checking: Std.LawfulLeftIdentity... ok
Checking: Std.LeftIdentity... ok
Checking: Std.LeftIdentity.mk... ok
Checking: Std.LawfulLeftIdentity.mk... ok
Checking: List.instDecidablePairwise.match_1... ok
Checking: Classical.byCases... ok
Checking: Std.IdempotentOp... ok
Checking: Std.IdempotentOp.mk... ok
Checking: Std.IdempotentOp.rec... ok
Checking: Lean.Parser.Attr.grindEqBoth... ok
Checking: Lean.Parser.Attr.grindEq... ok
Checking: Lean.Parser.Attr.grindEqBwd... ok
Checking: Lean.Parser.Attr.grindBwd... ok
Checking: Lean.Parser.Attr.grindFwd... ok
Checking: Lean.Parser.Attr.grindRL... ok
Checking: Lean.Parser.Attr.grindLR... ok
Checking: Lean.Parser.Attr.grindUsr... ok
Checking: Lean.Parser.Attr.grindCasesEager... ok
Checking: Lean.Parser.Attr.grindIntro... ok
Checking: Lean.Parser.Attr.grindExt... ok
Checking: Lean.Parser.Attr.grindSym... ok
Checking: Lean.Parser.Attr.grindInj... ok
Checking: Lean.Parser.Attr.grindDef... ok
Checking: Lean.Parser.Attr.grindMod... ok
Checking: Lean.Parser.Tactic.grindLemma... ok
Checking: CoeHTC... ok
Checking: CoeHTC.mk... ok
Checking: instCoeHTC... ok
Checking: Subtype.noConfusionType... ok
Checking: Subtype.noConfusion... ok
Checking: Substring.Raw.rec... ok
Checking: String.Pos.Raw.rec... ok
Checking: String.Pos.Raw._sizeOf_1... ok
Checking: String.Pos.Raw._sizeOf_inst... ok
Checking: Substring.Raw._sizeOf_1... ok
Checking: Substring.Raw._sizeOf_inst... ok
Checking: Lean.SourceInfo._sizeOf_1... ok
Checking: Lean.SourceInfo._sizeOf_inst... ok
Checking: Lean.instSizeOfName... ok
Checking: Lean.Syntax._sizeOf_1... ok
Checking: Lean.Syntax._sizeOf_inst... ok
Checking: Lean.Syntax.ident.sizeOf_spec... ok
Checking: Option.merge.eq_3... ok
Checking: _private.Init.Data.List.BasicAux.0.List.append_cancel_right.match_1_1... ok
Checking: Nat.Linear.PolyCnstr... ok
Checking: Nat.Linear.PolyCnstr.mk... ok
Checking: Nat.Linear.PolyCnstr.eq... ok
Checking: Nat.Linear.Poly.isNum?._sparseCasesOn_1... ok
Checking: Nat.Linear.Poly.isZero.match_1... ok
Checking: Nat.Linear.Poly.isZero... ok
Checking: Nat.Linear.PolyCnstr.lhs... ok
Checking: Nat.Linear.Poly.isNonZero... ok
Checking: Nat.Linear.PolyCnstr.rhs... ok
Checking: Nat.Linear.PolyCnstr.isUnsat... ok
Checking: Nat.Linear.PolyCnstr.norm.match_1... ok
Checking: Nat.Linear.Poly.norm... ok
Checking: Nat.Linear.Expr.toPoly.go.match_1... ok
Checking: Nat.Linear.Expr.toPoly.go... ok
Checking: Nat.Linear.Expr.toPoly... ok
Checking: Nat.Linear.Expr.toNormPoly... ok
Checking: Nat.Linear.ExprCnstr.lhs... ok
Checking: Nat.Linear.ExprCnstr.rhs... ok
Checking: Nat.Linear.ExprCnstr.eq... ok
Checking: Nat.Linear.ExprCnstr.toNormPoly... ok
Checking: Nat.Linear.ExprCnstr.denote... ok
Checking: Nat.Linear.PolyCnstr.denote... ok
Checking: Nat.Linear.PolyCnstr.rec... ok
Checking: Nat.Linear.PolyCnstr.casesOn... ok
Checking: Bool.or_eq_true... ok
Checking: Bool.and_eq_true... ok
Checking: _private.Init.Data.Nat.Linear.0.Nat.Linear.PolyCnstr.eq_false_of_isUnsat.match_1_4... ok
Checking: _private.Init.Data.Nat.Linear.0.Nat.Linear.Poly.isZero.match_1.splitter... ok
Checking: _private.Init.Data.Nat.Linear.0.Nat.Linear.Poly.isZero.match_1.eq_2... ok
Checking: Nat.Linear.Poly.of_isZero... ok
Checking: _private.Init.Data.Nat.Linear.0.Nat.Linear.Poly.of_isNonZero.match_1_1... ok
Checking: gt_iff_lt... ok
Checking: gt_iff_lt._simp_1... ok
Checking: Nat.instLawfulBEq... ok
Checking: Nat.beq_refl... ok
Checking: Nat.mul_one... ok
Checking: Nat.Linear.Poly.of_isNonZero... ok
Checking: Nat.not_le._simp_1... ok
Checking: _private.Init.Data.Nat.Linear.0.Nat.Linear.PolyCnstr.eq_false_of_isUnsat.match_1_6... ok
Checking: Nat.Linear.PolyCnstr.eq_false_of_isUnsat... ok
Checking: Nat.Linear.Poly.of_denote_eq_cancel... ok
Checking: Nat.add_right_cancel... ok
Checking: Nat.Linear.Poly.denote_eq_cancelAux... ok
Checking: Nat.Linear.Poly.denote_eq_cancel... ok
Checking: Nat.Linear.Poly.denote_eq_cancel_eq... ok
Checking: _private.Init.Data.Nat.Linear.0.Nat.Linear.Poly.denote_norm_go.match_1_1... ok
Checking: _private.Init.Data.Nat.Linear.0.Nat.Linear.Poly.denote_insert.match_1_1... ok
Checking: Nat.right_distrib... ok
Checking: Nat.Linear.Poly.denote_insert... ok
Checking: Nat.Linear.Poly.denote_norm_go... ok
Checking: _private.Init.Data.Nat.Linear.0.Nat.Linear.Expr.toPoly.go.match_1.splitter... ok
Checking: Bool.dcond.match_1... ok
Checking: Bool.dcond... ok
Checking: Nat.Linear.Expr.toPoly.go.induct... FAIL
Checking: _private.Init.Data.Nat.Basic.0.Nat.mul_assoc.match_1_1... ok
Checking: Nat.mul_assoc... ok
Checking: Nat.Linear.Expr.denote_toPoly_go... ok
Checking: Nat.one_mul... ok
Checking: Nat.Linear.Expr.denote_toPoly... ok
Checking: Nat.Linear.ExprCnstr.denote_toNormPoly... ok
Checking: Nat.Linear.ExprCnstr.eq_false_of_isUnsat... ok
Checking: eagerReduce... ok
Checking: List.append_cancel_right... ok
Checking: List.append_cancel_right_eq... ok
Checking: Std.Commutative... ok
Checking: Std.Commutative.mk... ok
Checking: Std.Commutative.rec... ok
Checking: Bool.cond_eq_ite... ok
Checking: Option.pfilter_some... ok
Checking: Option.isSome_pfilter_iff_get... ok
Checking: Option.isSome_of_isSome_pfilter... ok
Checking: Lean.Parser.Tactic.DecideConfig... ok
Checking: Lean.Parser.Tactic.DecideConfig.mk... ok
Checking: Lean.Parser.Tactic.DecideConfig.rec... ok
Checking: Lean.Parser.Tactic.DecideConfig.casesOn... ok
Checking: Lean.Parser.Tactic.DecideConfig.noConfusionType... ok
Checking: Lean.Parser.Tactic.DecideConfig.noConfusion... ok
Checking: Lean.Parser.Tactic.suggestions... ok
Checking: _private.Init.Data.Nat.Div.Basic.0.Nat.mod_zero.match_1_1... ok
Checking: Nat.mod_zero... ok
Checking: OrElse... ok
Checking: OrElse.mk... ok
Checking: MonadStateOf... ok
Checking: MonadStateOf.mk... ok
Checking: CoeOut... ok
Checking: CoeOut.mk... ok
Checking: Fin.coeToNat... ok
Checking: Array.noConfusionType... ok
Checking: Array.noConfusion... ok
Checking: Array.mk.noConfusion... ok
Checking: Array.mk.injEq... ok
Checking: Bool.or_and_distrib_right... ok
Checking: MonadEval... ok
Checking: MonadEval.mk... ok
Checking: MonadEval.ctorIdx... ok
Checking: unexpandEqNDRec... ok
Checking: Lean.Syntax.Ident... ok
Checking: Lean.Name.hasMacroScopes.match_1... ok
Checking: Lean.Name.hasMacroScopes... ok
Checking: _private.Init.Prelude.0.Lean.extractMacroScopesAux.match_1... ok
Checking: _private.Init.Prelude.0.Lean.extractImported.match_1... ok
Checking: _private.Init.Prelude.0.Lean.assembleParts.match_1... ok
Checking: Lean.Name.mkStr... ok
Checking: Lean.instInhabitedName... ok
Checking: _private.Init.Prelude.0.Lean.assembleParts... ok
Checking: Lean.instInhabitedMacroScopesView... ok
Checking: _private.Init.Prelude.0.Lean.extractImported... ok
Checking: _private.Init.Prelude.0.Lean.extractMainModule... ok
Checking: _private.Init.Prelude.0.Lean.extractMacroScopesAux... ok
Checking: Lean.extractMacroScopes... ok
Checking: Lean.MacroScopesView.ctx... ok
Checking: _private.Init.Prelude.0.Lean.MacroScopesView.review.match_1... ok
Checking: Lean.MacroScopesView.scopes... ok
Checking: Lean.MacroScopesView.name... ok
Checking: Lean.Name.appendCore.match_1... ok
Checking: Lean.Name.appendCore... ok
Checking: Lean.MacroScopesView.imported... ok
Checking: Lean.MacroScopesView.review... ok
Checking: Lean.addMacroScope... ok
Checking: Lean.reservedMacroScope... ok
Checking: _private.Init.Meta.Defs.0.Lean.Name.Internal.Meta.toStringWithSep.match_1... ok
Checking: UInt8.size... ok
Checking: UInt8.ofNatLT... ok
Checking: instInhabitedUInt8._proof_1... ok
Checking: instInhabitedUInt8... ok
Checking: String.Internal.getUTF8Byte... ok
Checking: UInt8.toBitVec... ok
Checking: UInt8.le... ok
Checking: instLEUInt8... ok
Checking: Nat.toUInt8... ok
Checking: UInt32.toUInt8... ok
Checking: Char.toUInt8... ok
Checking: UInt8.decLe... ok
Checking: _private.Init.Meta.Defs.0.Lean.isAlphaAscii... ok
Checking: Lean.isIdFirstAscii... ok
Checking: _private.Init.Meta.Defs.0.Lean.Name.needsNoEscapeAsciiRest... ok
Checking: _private.Init.Meta.Defs.0.Lean.Name.needsNoEscapeAscii... ok
Checking: Char.instInhabited... ok
Checking: String.Internal.get... ok
Checking: String.instOfNatRaw... ok
Checking: Substring.Raw.Internal.all... ok
Checking: instInhabitedRaw_1... ok
Checking: Substring.Raw.Internal.drop... ok
Checking: Char.isDigit... ok
Checking: Char.isAlphanum... ok
Checking: Lean.isNumericSubscript... ok
Checking: Lean.isSubScriptAlnum... ok
Checking: Lean.isIdRest... ok
Checking: _private.Init.Meta.Defs.0.Lean.Name.needsNoEscape... ok
Checking: String.Internal.any... ok
Checking: Lean.idEndEscape... ok
Checking: Lean.isIdEndEscape... ok
Checking: Char.toString... ok
Checking: Lean.idBeginEscape... ok
Checking: _private.Init.Meta.Defs.0.Lean.Name.escape... ok
Checking: _private.Init.Meta.Defs.0.Lean.Name.Internal.Meta.escapePart... ok
Checking: _private.Init.Meta.Defs.0.Lean.Name.Internal.Meta.toStringWithSep.maybeEscape... ok
Checking: _private.Init.Meta.Defs.0.Lean.Name.Internal.Meta.toStringWithSep... ok
Checking: _private.Init.Meta.Defs.0.Lean.Name.isInaccessibleUserName._sparseCasesOn_1... ok
Checking: _private.Init.Meta.Defs.0.Lean.Name.isInaccessibleUserName.match_1... ok
Checking: String.Internal.contains... ok
Checking: Lean.Name.isInaccessibleUserName... ok
Checking: _private.Init.Meta.Defs.0.Lean.Name.Internal.Meta.toStringWithToken.maybePseudoSyntax._sparseCasesOn_1... ok
Checking: _private.Init.Meta.Defs.0.Lean.Name.Internal.Meta.toStringWithToken.maybePseudoSyntax.match_1... ok
Checking: String.Internal.isPrefixOf... ok
Checking: _private.Init.Meta.Defs.0.Lean.Name.Internal.Meta.toStringWithToken.maybePseudoSyntax... ok
Checking: _private.Init.Meta.Defs.0.Lean.Name.Internal.Meta.toStringWithToken... ok
Checking: _private.Init.Meta.Defs.0.Lean.Name.Internal.Meta.toString... ok
Checking: Lean.mkCIdentFrom... ok
Checking: Lean.mkCIdentFromRef... ok
Checking: Substring.Raw.casesOn... ok
Checking: Substring.Raw.noConfusionType... ok
Checking: Substring.Raw.noConfusion... ok
Checking: Substring.Raw.mk.noConfusion... ok
Checking: Substring.Raw.mk.inj... ok
Checking: Nat.eq_of_mul_eq_mul_left... ok
Checking: Lean.Syntax.SepArray.rec... ok
Checking: Lean.Syntax.SepArray.casesOn... ok
Checking: Lean.Syntax.SepArray.noConfusionType... ok
Checking: Lean.Syntax.SepArray.noConfusion... ok
Checking: _private.Init.Data.List.Control.0.List.findM?.match_1... ok
Checking: List.findM?... ok
Checking: Thunk.fn... ok
Checking: Thunk.get... ok
Checking: Thunk.map... ok
Checking: Bool.false_and... ok
Checking: Bool.true_and... ok
Checking: Bool.if_false_right... ok
Checking: instCoeTailNatOfNatCast... ok
Checking: List.span.loop... ok
Checking: List.span... ok
Checking: SeqLeft.rec... ok
Checking: SeqLeft.casesOn... ok
Checking: SeqLeft.noConfusionType... ok
Checking: SeqLeft.noConfusion... ok
Checking: Std.Format.FlattenAllowability... ok
Checking: Std.Format.FlattenAllowability.allow... ok
Checking: Std.Format.FlattenAllowability.disallow... ok
Checking: Alternative.rec... ok
Checking: Alternative.casesOn... ok
Checking: Lean.Parser.Tactic.change... ok
Checking: HMod.rec... ok
Checking: HMod.casesOn... ok
Checking: Lean.Parser.Tactic.Conv.convRight... ok
Checking: Option.choice... ok
Checking: Option.choice_eq_some... ok
Checking: Option.choice_eq_default... ok
Checking: Std.Format.FlattenAllowability.rec... ok
Checking: Std.Format.FlattenAllowability.casesOn... ok
Checking: Std.Format.FlattenAllowability.ctorIdx... ok
Checking: _private.Init.Data.Format.Basic.0.Std.Format.instBEqFlattenAllowability.beq._sparseCasesOn_1... ok
Checking: _private.Init.Data.Format.Basic.0.Std.Format.instBEqFlattenAllowability.beq._sparseCasesOn_2... ok
Checking: _private.Init.Data.Format.Basic.0.Std.Format.instBEqFlattenAllowability.beq.match_1... ok
Checking: Std.Format.instBEqFlattenAllowability.beq... ok
Checking: Std.Format.instBEqFlattenAllowability... ok
Checking: Nat.sub_lt_of_lt... ok
Checking: Option.not_isSome... ok
Checking: Option.not_comp_isSome... ok
Checking: ST.Ref.rec... ok
Checking: ST.Ref.casesOn... ok
Checking: ST.Ref.noConfusionType... ok
Checking: ST.Ref.noConfusion... ok
Checking: ST.Ref.mk.noConfusion... ok
Checking: ST.Ref.mk.injEq... ok
Checking: Lean.builtin_command_code_action... ok
Checking: StateT.get... ok
Checking: Option.mem_def... ok
Checking: Option.mem_def._simp_1... ok
Checking: Option.mem_some... ok
Checking: Option.mem_some_iff... ok
Checking: BitVec.sub... ok
Checking: BitVec.instSub... ok
Checking: USize.sub... ok
Checking: LT.casesOn... ok
Checking: LT.noConfusionType... ok
Checking: Int.NonNeg... ok
Checking: Int.NonNeg.mk... ok
Checking: Int.add.match_1... ok
Checking: Int.subNatNat... ok
Checking: Int.add... ok
Checking: Int.instAdd... ok
Checking: Neg... ok
Checking: Neg.mk... ok
Checking: Neg.neg... ok
Checking: Int.instNegInt... ok
Checking: Int.sub... ok
Checking: Int.instSub... ok
Checking: Int.le... ok
Checking: toBoolUsing... ok
Checking: toBoolUsing_eq_true... ok
Checking: imp_congr_left... ok
Checking: Option.forM.match_1... ok
Checking: Option.forM... ok
Checking: Option.instForM... ok
Checking: _private.Init.Data.List.ToArrayImpl.0.List.toArrayAux.match_1... ok
Checking: List.toArrayAux... ok
Checking: Array.toArrayAux_eq... ok
Checking: _private.Init.WF.0.Prod.lex_def.match_1_1... ok
Checking: Prod.lex_def... ok
Checking: Option.map_some... ok
Checking: Option.mem_map_of_mem... ok
Checking: Array.mkArray5... ok
Checking: Std.Format.FlattenBehavior.recOn... ok
Checking: List.dropLast.match_1... ok
Checking: List.intersperse... ok
Checking: List.intersperse_single... ok
Checking: Nat.not_le_eq... ok
Checking: Except.rec... ok
Checking: Except.casesOn... ok
Checking: ExceptT.bindCont.match_1... ok
Checking: PSum.inhabitedLeft... ok
Checking: Lean.Quote.casesOn... ok
Checking: Lean.Quote.noConfusionType... ok
Checking: Lean.Quote.noConfusion... ok
Checking: Lean.Quote.mk.noConfusion... ok
Checking: List.or... ok
Checking: List.or_cons... ok
Checking: Lean.mkNullNode... ok
Checking: Lean.mkOptionalNode... ok
Checking: Lean.Parser.Category.structInstFieldDecl... ok
Checking: Nat.modCore.go.congr_simp... ok
Checking: Lean.Meta.DSimp.Config.proj... ok
Checking: Lean.Meta.ExtractLetsConfig... ok
Checking: Lean.Meta.ExtractLetsConfig.mk... ok
Checking: Lean.Meta.ExtractLetsConfig.rec... ok
Checking: Lean.Meta.ExtractLetsConfig._sizeOf_1... ok
Checking: Lean.Meta.ExtractLetsConfig._sizeOf_inst... ok
Checking: Lean.Meta.ExtractLetsConfig.mk.sizeOf_spec... ok
Checking: ExceptT... ok
Checking: ExceptT.run... ok
Checking: ExceptT.ext... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getLast?_eq_getLast.match_1_1... ok
Checking: List.getLast?_eq_getLast... ok
Checking: List.replicate_zero... ok
Checking: Bool.and_self... ok
Checking: Option.min_none_left... ok
Checking: Bool.and_true... ok
Checking: Bool.and_false... ok
Checking: Option.isSome_min... ok
Checking: Option.isSome_right_of_isSome_min... ok
Checking: Lean.Meta.instInhabitedTransparencyMode.default... ok
Checking: Lean.Meta.instInhabitedTransparencyMode... ok
Checking: Lean.Parser.Tactic.Conv.occsWildcard... ok
Checking: Lean.Parser.Tactic.Conv.occsIndexed... ok
Checking: Lean.Parser.Tactic.Conv.occs... ok
Checking: Lean.Parser.Tactic.Conv.convSeqBracketed... ok
Checking: Lean.Parser.Tactic.Conv.convSeq1Indented... ok
Checking: Lean.Parser.Tactic.Conv.convSeq... ok
Checking: Lean.Parser.Tactic.Conv.conv... ok
Checking: Option.decidableForallMem.match_3... ok
Checking: Lean.Macro.State.ctorIdx... ok
Checking: Bool.ite_eq_true_distrib... ok
Checking: not_congr... ok
Checking: Nat.div_lt_iff_lt_mul... ok
Checking: Nat.div_eq_of_lt_le... ok
Checking: CoeSort... ok
Checking: CoeSort.mk... ok
Checking: CoeSort.rec... ok
Checking: CoeSort.casesOn... ok
Checking: CoeSort.noConfusionType... ok
Checking: Void.instNonempty... ok
Checking: Lean.binderIdent... ok
Checking: Lean.Parser.Tactic.renameI... ok
Checking: List.append_cancel_left... ok
Checking: Lean.Meta.ApplyNewGoals.rec... ok
Checking: Lean.Meta.ApplyNewGoals.casesOn... ok
Checking: Lean.Meta.ApplyNewGoals.ctorIdx... ok
Checking: Lean.Meta.ApplyNewGoals.ctorElimType... ok
Checking: Lean.Meta.ApplyNewGoals.ctorElim... ok
Checking: Lean.Meta.ApplyNewGoals.nonDependentOnly.elim... ok
Checking: Subtype.instBEq... ok
Checking: BEq.refl... ok
Checking: Subtype.instReflBEq... ok
Checking: BitVec.ctorIdx... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.get_eq_getD.match_1_1... ok
Checking: Option.get_eq_getD... ok
Checking: ExceptCpsT... FAIL
Checking: ExceptCpsT.lift... ok
Checking: ExceptCpsT.lift.eq_1... FAIL
Checking: Std.Format.ctorElimType... ok
Checking: Std.Format.ctorElim... ok
Checking: Std.Format.nil.elim... ok
Checking: Std.Format.line.elim... ok
Checking: Std.Format.align.elim... ok
Checking: Std.Format.text.elim... ok
Checking: Std.Format.nest.elim... ok
Checking: Std.Format.append.elim... ok
Checking: Std.Format.group.elim... ok
Checking: Std.Format.tag.elim... ok
Checking: Std.Format.noConfusionType... ok
Checking: Std.Format.noConfusion... ok
Checking: Std.Format.nest.noConfusion... ok
Checking: stx_+... ok
Checking: HEq.ndrecOn... ok
Checking: HEq.subst... ok
Checking: HEq.trans... ok
Checking: heq_of_eq_of_heq... ok
Checking: getElem?_eq_none_iff... ok
Checking: Empty... ok
Checking: Empty.rec... ok
Checking: ForIn'.rec... ok
Checking: ForIn'.recOn... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.exists_ne_none.match_1_1... ok
Checking: Option.ne_none_iff_isSome... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.exists_ne_none.match_1_3... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.some_ne_none.match_1_1... ok
Checking: Option.some_ne_none... ok
Checking: Option.exists_ne_none... ok
Checking: STWorld... ok
Checking: STWorld.mk... ok
Checking: instSTWorldOfMonadLift... ok
Checking: UInt16.ofNat... ok
Checking: Nat.toUInt16... ok
Checking: UInt32.toUInt16... ok
Checking: Lean.NameGenerator.rec... ok
Checking: Lean.NameGenerator.casesOn... ok
Checking: List.zipWith.match_1... ok
Checking: List.zipWith... ok
Checking: _private.Init.Data.List.Basic.0.List.zipWith.match_1.splitter... ok
Checking: _private.Init.Data.List.Basic.0.List.zipWith.match_1.eq_2... ok
Checking: List.zipWith.eq_def... ok
Checking: _auto._@.Init.Data.List.Basic.1499792475._hygCtx._hyg.12... ok
Checking: List.lex.match_1... ok
Checking: List.lex... ok
Checking: List.partition.loop... ok
Checking: List.partition... ok
Checking: _private.Init.Data.List.Lemmas.0.List.partition_eq_filter_filter.aux.match_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.partition_eq_filter_filter.aux... ok
Checking: List.partition_eq_filter_filter... ok
Checking: List.mem_filter._simp_1... ok
Checking: List.mem_partition... ok
Checking: stx_,*... ok
Checking: Lean.bracketedExplicitBinders... ok
Checking: term_×__1... ok
Checking: EST.Out.rec... ok
Checking: EST.Out.casesOn... ok
Checking: instMonadFinallyEST.match_1... ok
Checking: Lean.TSyntax.recOn... ok
Checking: Dvd... ok
Checking: Dvd.mk... ok
Checking: Dvd.dvd... ok
Checking: Nat.instDvd... ok
Checking: Nat.divExact... ok
Checking: Nat.Linear.instBEqExpr.beq._sparseCasesOn_1... ok
Checking: Nat.Linear.instBEqExpr.beq._sparseCasesOn_2... ok
Checking: Nat.Linear.instBEqExpr.beq._sparseCasesOn_3... ok
Checking: Nat.Linear.instBEqExpr.beq._sparseCasesOn_4... ok
Checking: Nat.Linear.instBEqExpr.beq._sparseCasesOn_5... ok
Checking: Nat.Linear.instBEqExpr.beq.match_1... ok
Checking: Nat.Linear.instBEqExpr.beq... ok
Checking: AndOp.rec... ok
Checking: AndOp.casesOn... ok
Checking: AndOp.noConfusionType... ok
Checking: AndOp.noConfusion... ok
Checking: Char.quote... ok
Checking: Int.negSucc.elim... ok
Checking: forall_comm... ok
Checking: MonadLiftT.rec... ok
Checking: MonadLiftT.casesOn... ok
Checking: MonadLiftT.noConfusionType... ok
Checking: MonadLiftT.noConfusion... ok
Checking: Not.elim... ok
Checking: iff_of_false... ok
Checking: iff_false_left... ok
Checking: Lean.isIdBeginEscape... ok
Checking: Lean.Meta.Simp.Config.warnExponents... ok
Checking: Quotient.sound... ok
Checking: CoeHTCT... ok
Checking: CoeHTCT.mk... ok
Checking: forall_const... ok
Checking: ReprTuple... ok
Checking: ReprTuple.mk... ok
Checking: ReprTuple.rec... ok
Checking: StateCpsT.instMonad... ok
Checking: MonadStateOf.set... ok
Checking: StateCpsT.instMonadStateOf.match_1... ok
Checking: StateCpsT.instMonadStateOf... ok
Checking: StateCpsT.runK_bind_set... ok
Checking: USize.ofNat... ok
Checking: Nat.not_le_of_lt... ok
Checking: Option.join... ok
Checking: Option.pbind_join._proof_1... ok
Checking: Option.pbind_join... ok
Checking: Alternative.orElse... ok
Checking: Option.le.match_1... ok
Checking: Option.le... ok
Checking: instLEOption... ok
Checking: Option.none_le... ok
Checking: Option.none_le._simp_1... ok
Checking: Option.not_some_le_none... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.le_none._simp_1_1... ok
Checking: Option.le_none... ok
Checking: Option.le_none._simp_1... ok
Checking: Option.some_le_some... ok
Checking: Option.some_le_some._simp_1... ok
Checking: forall_const._simp_1... ok
Checking: instInhabitedTrue.default... ok
Checking: instInhabitedTrue... ok
Checking: Option.merge_le... ok
Checking: _private.Init.Prelude.0.Lean.Syntax.isIdent.match_1... ok
Checking: Lean.Syntax.getId... ok
Checking: Lean.TSyntax.getId... ok
Checking: LawfulMonadLift... ok
Checking: LawfulMonadLift.mk... ok
Checking: List.range'TR.go.match_1... ok
Checking: List.range'TR.go... ok
Checking: Nat.brecOn.eq... ok
Checking: _private.Init.Data.List.Basic.0.List.range'TR.go.match_1.splitter... ok
Checking: List.range'TR.go.eq_def... ok
Checking: Mul.rec... ok
Checking: Lean.numLitKind... ok
Checking: Lean.Syntax.NumLit... ok
Checking: Lean.Syntax.mkNatLit... ok
Checking: Option.bind_some... ok
Checking: EmptyCollection... ok
Checking: EmptyCollection.mk... ok
Checking: EmptyCollection.ctorIdx... ok
Checking: List.set.match_1... ok
Checking: List.set... ok
Checking: _private.Init.Data.List.Lemmas.0.List.mem_or_eq_of_mem_set.match_1_1... ok
Checking: List.mem_or_eq_of_mem_set... ok
Checking: Option.all... ok
Checking: Option.all_eq_true_iff_get... ok
Checking: HasSSubset.mk.noConfusion... ok
Checking: unexpandMkArray5... ok
Checking: ExceptT.mk... ok
Checking: ExceptT.map... ok
Checking: ExceptT.pure... ok
Checking: ExceptT.bindCont... ok
Checking: ExceptT.bind... ok
Checking: ExceptT.instMonad... ok
Checking: ExceptT.tryCatch... ok
Checking: instMonadExceptOfExceptTOfMonad... ok
Checking: ExceptT.map_throw... FAIL
Checking: List.unzipTR.match_1... ok
Checking: List.unzip.match_1... ok
Checking: List.unzipTR... ok
Checking: List.unzipTR.eq_1... FAIL
Checking: Lean.Parser.Tactic.mpureMacro... ok
Checking: Lean.Name.mkStr3... ok
Checking: Lean.Parser.timeCmd... ok
Checking: List.instReflBEq... ok
Checking: not_not_of_not_imp... ok
Checking: Decidable.of_not_imp... ok
Checking: not_of_not_imp... ok
Checking: _private.Init.PropLemmas.0.not_imp_of_and_not.match_1_1... ok
Checking: not_imp_of_and_not... ok
Checking: Decidable.not_imp_iff_and_not... ok
Checking: Classical.not_imp_iff_and_not... ok
Checking: CoeTail.coe... ok
Checking: _private.Init.Data.List.Lemmas.0.List.length_eq_of_beq.match_1_1... ok
Checking: List.beq_nil_eq... ok
Checking: Eq.to_iff... ok
Checking: Nat.succ_inj... ok
Checking: Nat.add_one_inj... ok
Checking: _private.Init.Data.List.Lemmas.0.List.length_eq_of_beq._simp_1_3... ok
Checking: List.length_eq_of_beq... ok
Checking: Prod.lexLt... ok
Checking: Bind.ctorIdx... ok
Checking: BEq.rec... ok
Checking: ReprAtom... ok
Checking: ReprAtom.mk... ok
Checking: instReprAtomUSize... ok
Checking: Lean.Parser.Tactic.subst... ok
Checking: Std.Format.MonadPrettyFormat... ok
Checking: Std.Format.MonadPrettyFormat.mk... ok
Checking: Std.Format.MonadPrettyFormat.pushOutput... ok
Checking: instFunctorOption... ok
Checking: instMonadOption... ok
Checking: Option.orElse.match_1... ok
Checking: Option.orElse... ok
Checking: instAlternativeOption... ok
Checking: Option.pure_def... FAIL
Checking: EmptyCollection.rec... ok
Checking: EmptyCollection.casesOn... ok
Checking: EmptyCollection.noConfusionType... ok
Checking: EmptyCollection.noConfusion... ok
Checking: EmptyCollection.mk.noConfusion... ok
Checking: Lean.Parser.Tactic.apply... ok
Checking: Quotient.inductionOn₂... ok
Checking: Lean.Grind.GrobnerConfig... ok
Checking: Lean.Grind.GrobnerConfig.mk... ok
Checking: Lean.Grind.GrobnerConfig.rec... ok
Checking: Lean.Grind.NoopConfig._sizeOf_1... ok
Checking: Lean.Grind.NoopConfig._sizeOf_inst... ok
Checking: Lean.Grind.GrobnerConfig._sizeOf_1... ok
Checking: Lean.Grind.GrobnerConfig._sizeOf_inst... ok
Checking: Lean.Grind.GrobnerConfig.mk.sizeOf_spec... ok
Checking: Pure.casesOn... ok
Checking: Pure.noConfusionType... ok
Checking: Nat.div_eq_of_lt... ok
Checking: Decidable.or_iff_not_not_and_not... ok
Checking: Sigma... ok
Checking: Sigma.mk... ok
Checking: Sigma.fst... ok
Checking: Sigma.snd... ok
Checking: Sigma.rec... ok
Checking: Sigma.casesOn... ok
Checking: _private.Init.Ext.0.Sigma.ext.match_1... ok
Checking: HEq.casesOn... ok
Checking: Sigma.ext... ok
Checking: Option.or_none... ok
Checking: Applicative.noConfusion... ok
Checking: List.replace_nil... ok
Checking: Sep... ok
Checking: Sep.mk... ok
Checking: Sep.ctorIdx... ok
Checking: Lean.Parser.Tactic.rotateRight... ok
Checking: Lean.Parser.Tactic.inductionAltLHS... ok
Checking: Lean.Parser.Tactic.inductionAlt... ok
Checking: List.map_id_fun... ok
Checking: List.map_id_fun'... ok
Checking: ToBool... ok
Checking: ToBool.mk... ok
Checking: CoeT... ok
Checking: CoeT.mk... ok
Checking: CoeHTCT.coe... ok
Checking: instCoeTOfCoeHTCT... ok
Checking: Lean.Parser.Tactic.Grind.grindStep... ok
Checking: Lean.Parser.Tactic.Grind.grindSeq1Indented... ok
Checking: Bool.toNat... ok
Checking: Nat.succ_ne_self._simp_1... ok
Checking: Bool.true_eq_false... ok
Checking: Bool.toNat_eq_zero... ok
Checking: Quot.inductionOn... ok
Checking: Quot.exists_rep... ok
Checking: NatCast.ctorIdx... ok
Checking: Lean.Parser.Tactic.contradiction... ok
Checking: CoeTC... ok
Checking: CoeTC.mk... ok
Checking: CoeTC.coe... ok
Checking: Eq.comm... ok
Checking: eq_comm... ok
Checking: List.nil_eq... ok
Checking: List.nil_eq._simp_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.append_eq_cons_iff.match_1_1... ok
Checking: List.append_eq_cons_iff... ok
Checking: List.cons_eq_append_iff... ok
Checking: _private.Init.PropLemmas.0.forall_eq_or_imp._simp_1_1... ok
Checking: _private.Init.PropLemmas.0.forall_eq_or_imp._simp_1_2... ok
Checking: forall_eq... ok
Checking: forall_eq._simp_1... ok
Checking: forall_eq_or_imp... ok
Checking: forall_eq_or_imp._simp_1... ok
Checking: List.flatten_append... ok
Checking: List.flatten_eq_nil_iff... ok
Checking: List.flatten_eq_cons_iff... ok
Checking: List.flatten_eq_nil_iff._simp_1... ok
Checking: List.flatten_eq_singleton_iff... ok
Checking: List.singleton_eq_flatten_iff... ok
Checking: WellFoundedRelation.rec... ok
Checking: Option.some_eq_dite_none_left... ok
Checking: List.append_ne_nil_of_right_ne_nil... ok
Checking: MonadExcept.ofExcept.match_1... ok
Checking: Lean.Meta.Omega.OmegaConfig.splitNatAbs... ok
Checking: Lean.Grind.Config.linarith... ok
Checking: Lean.Grind.instBEqConfig... ok
Checking: StateCpsT.lift... ok
Checking: StateCpsT.runK_bind_lift... ok
Checking: PUnit.casesOn... ok
Checking: PUnit.subsingleton... ok
Checking: PNonScalar.rec... ok
Checking: PNonScalar.casesOn... ok
Checking: PNonScalar.noConfusionType... ok
Checking: List.Pairwise... ok
Checking: List.Pairwise.nil... ok
Checking: List.Pairwise.cons... ok
Checking: List.Pairwise.below... ok
Checking: List.Pairwise.below.cons... ok
Checking: List.Pairwise.below.nil... ok
Checking: instLawfulMonadOption... TIMEOUT
Checking: instLawfulApplicativeOption... ok
Checking: instLawfulFunctorOption... ok
Checking: UInt16.ctorIdx... ok
Checking: Option.isNone_or... ok
Checking: _private.Init.Data.List.Control.0.List.findSomeM?.match_1... ok
Checking: List.findSomeM?... ok
Checking: List.findSome?.match_1... ok
Checking: List.findSome?... ok
Checking: List.findSomeM?_pure... ok
Checking: SMul... ok
Checking: SMul.mk... ok
Checking: SMul.ctorIdx... ok
Checking: Thunk.mk.noConfusion... ok
Checking: Thunk.mk.inj... ok
Checking: Option.filter_filter... ok
Checking: instToStringOption.match_1... ok
Checking: Char.isWhitespace... ok
Checking: addParenHeuristic... ok
Checking: instToStringOption... ok
Checking: Bool.not_or... ok
Checking: List.not_any_eq_all_not... ok
Checking: _private.Init.Control.Lawful.Instances.0.instLawfulMonadEStateM.match_1... ok
Checking: instLawfulMonadEStateM... ok
Checking: ExceptT.map.eq_1... ok
Checking: _private.Init.Data.Nat.Bitwise.Basic.0.Nat.shiftRight_eq_div_pow.match_1_1... ok
Checking: Nat.mod_add_div... ok
Checking: Nat.mod_one... ok
Checking: Nat.div_one... ok
Checking: _private.Init.Data.Nat.Bitwise.Basic.0.Nat.shiftRight_add.match_1_1... ok
Checking: _private.Init.Data.Nat.Bitwise.Basic.0.Nat.shiftRight_add._simp_1_3... ok
Checking: Nat.shiftRight_add... ok
Checking: Nat.div_div_eq_div_mul... ok
Checking: Nat.shiftRight_eq_div_pow... ok
Checking: Nat.shiftRight_eq_zero... ok
Checking: Nat.beq_eq_true_eq... ok
Checking: Lean.Parser.Tactic.Conv.convRfl... ok
Checking: Lean.singletonUnexpander... ok
Checking: LawfulApplicative.seqLeft_eq... ok
Checking: LawfulMonad.bind_map... ok
Checking: seq_eq_bind_map... ok
Checking: LawfulMonadLiftT.monadLift_bind... ok
Checking: monadLift_map... ok
Checking: monadLift_seq... ok
Checking: monadLift_seqLeft... ok
Checking: Lean.Meta.Simp.Config.maxDischargeDepth... ok
Checking: _private.Init.Prelude.0.of_decide_eq_false.match_1_1... ok
Checking: _private.Init.Prelude.0.ne_false_of_eq_true.match_1_1... ok
Checking: ne_false_of_eq_true... ok
Checking: of_decide_eq_false... ok
Checking: eq_false_of_decide... ok
Checking: List.modifyTailIdx.go... ok
Checking: List.modifyTailIdx... ok
Checking: List.modifyTailIdx_succ_cons... FAIL
Checking: Lean.Parser.Tactic.congr... ok
Checking: unexpandMkArray7... ok
Checking: List.map_append... ok
Checking: List.map_reverse... ok
Checking: Lean.Syntax.Preresolved.rec... ok
Checking: Lean.Syntax.Preresolved.casesOn... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.instReprPreresolved.repr.match_1... ok
Checking: Std.Format.paren... ok
Checking: Repr.addAppParen... ok
Checking: reprArg... ok
Checking: _private.Init.Meta.Defs.0.Lean.Name.hasNum.match_1... ok
Checking: instReprNat... ok
Checking: _private.Init.Meta.Defs.0.Lean.Name.hasNum... ok
Checking: instReprString... ok
Checking: Lean.Name.reprPrec... ok
Checking: Lean.Name.instRepr... ok
Checking: Std.ToFormat... ok
Checking: Std.ToFormat.mk... ok
Checking: _private.Init.Data.Repr.0.List.repr._sparseCasesOn_1... ok
Checking: _private.Init.Data.Repr.0.List.repr.match_1... ok
Checking: Std.Format.fill... ok
Checking: Std.Format.bracketFill... ok
Checking: _private.Init.Data.Format.Basic.0.Std.Format.joinSep._sparseCasesOn_1... ok
Checking: _private.Init.Data.Format.Basic.0.Std.Format.joinSep.match_1... ok
Checking: Std.ToFormat.format... ok
Checking: Std.Format.joinSep... ok
Checking: List.repr'... ok
Checking: instReprListOfReprAtom... ok
Checking: instReprAtomString... ok
Checking: Lean.Syntax.instReprPreresolved.repr... ok
Checking: UInt64... ok
Checking: UInt64.ofBitVec... ok
Checking: UInt8.toNat... ok
Checking: BitVec.isLt... ok
Checking: UInt8.toUInt64._proof_1... ok
Checking: UInt8.toUInt64._proof_2... ok
Checking: UInt8.toUInt64... ok
Checking: Lean.Macro.Context.methods... ok
Checking: Lean.Macro.Context.quotContext... ok
Checking: Lean.Macro.Context.currMacroScope... ok
Checking: Lean.Macro.Context.currRecDepth... ok
Checking: Lean.Macro.instMonadRefMacroM... ok
Checking: instInhabitedReaderT... ok
Checking: _private.Init.NotationExtra.0.Lean.expandBracketedBindersAux.loop... ok
Checking: _private.Init.NotationExtra.0.Lean.expandExplicitBindersAux._proof_1... ok
Checking: Lean.expandBracketedBindersAux... ok
Checking: Lean.expandBracketedBinders... ok
Checking: PSum.noConfusion... ok
Checking: PSum.inr.noConfusion... ok
Checking: PSum.inr.injEq... ok
Checking: List.getElem?_replace_of_ne... ok
Checking: Lean.groupKind... ok
Checking: Option.getM.match_1... ok
Checking: Option.mapM... ok
Checking: Option.mapM_none... FAIL
Checking: dbgSleep... ok
Checking: HXor... ok
Checking: HXor.mk... ok
Checking: HXor.hXor... ok
Checking: List.zipWithAll.match_1... ok
Checking: List.zipWithAll... ok
Checking: List.zipWithAll_cons_cons... ok
Checking: Option.isSome_pmap... ok
Checking: Option.get_pmap._proof_1... ok
Checking: Option.get_pmap._proof_2... ok
Checking: Option.get_none_eq_iff_true... ok
Checking: Option.get_none_eq_iff_true._simp_1... ok
Checking: Option.get_pmap... ok
Checking: Option.tryCatch... ok
Checking: instMonadExceptOfUnitOption... ok
Checking: Nat.succ_le_succ_iff... ok
Checking: HAndThen... ok
Checking: HAndThen.mk... ok
Checking: HAndThen.hAndThen... ok
Checking: Quotient.mk'... ok
Checking: List.not_mem_of_not_mem_cons... ok
Checking: term_↔_... ok
Checking: StateRefT'.lift... ok
Checking: StateRefT'.instMonadLift... ok
Checking: _private.Init.Data.Nat.Div.Basic.0.Nat.mul_div_le.match_1_1... ok
Checking: Nat.mul_div_le... ok
Checking: List.head_mem... ok
Checking: _private.Init.Data.List.Lemmas.0.List.flatten_filter_not_isEmpty.match_1_1... ok
Checking: List.flatten_filter_not_isEmpty... ok
Checking: Except.noConfusionType... ok
Checking: Lean.Parser.Tactic.Grind.grind_filterGen>_... ok
Checking: ExceptT.lift... ok
Checking: ExceptT.lift.eq_1... ok
Checking: ReprAtom.rec... ok
Checking: ReprAtom.casesOn... ok
Checking: ReprAtom.noConfusionType... ok
Checking: ReprAtom.noConfusion... ok
Checking: Lean.Parser.Tactic.tacticTry_... ok
Checking: unexpandTSyntax... ok
Checking: Option.pure_apply... FAIL
Checking: CoeT.coe... ok
Checking: Lean.Internal.coeM... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getElem_of_mem.match_1_3... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getElem_of_mem.match_1_1... ok
Checking: List.getElem_of_mem... ok
Checking: _private.Init.Data.List.Lemmas.0.List.mem_iff_getElem.match_1_1... ok
Checking: List.mem_iff_getElem... ok
Checking: forall_imp... ok
Checking: Std.Associative... ok
Checking: Std.Associative.mk... ok
Checking: Bool.or_assoc... ok
Checking: instAssociativeBoolOr... ok
Checking: Nat.zero_lt_one... ok
Checking: Nat.one_pos... ok
Checking: CoeOTC.coe... ok
Checking: instCoeHTCOfCoeOTC... ok
Checking: Lean.Meta.Simp.NormCastConfig... ok
Checking: Lean.Meta.Simp.NormCastConfig.mk... ok
Checking: Lean.Meta.Simp.NormCastConfig.toConfig... ok
Checking: List.any_append... ok
Checking: PEmpty... ok
Checking: PEmpty.rec... ok
Checking: Option.eq_some_unique... ok
Checking: Option.merge_join... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.lt_or_gt_of_ne.match_1_1... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.lt_trichotomy.match_1_3... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.lt_trichotomy.match_1_1... ok
Checking: Nat.lt_trichotomy... ok
Checking: Nat.lt_or_gt_of_ne... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.ne_iff_lt_or_gt.match_1_1... ok
Checking: Nat.ne_iff_lt_or_gt... ok
Checking: Nat.lt_or_gt... ok
Checking: Max.max... ok
Checking: maxOfLe... ok
Checking: Nat.instMax... ok
Checking: Nat.max_def... ok
Checking: True.rec... ok
Checking: True.recOn... ok
Checking: List.map_map... ok
Checking: ForIn... ok
Checking: ForIn.mk... ok
Checking: ForIn.forIn... ok
Checking: ForIn'.forIn'... ok
Checking: instForInOfForIn'... ok
Checking: List.forIn'.loop.match_5... ok
Checking: List.forIn'.loop.match_1... ok
Checking: List.mem_append_right... ok
Checking: List.forIn'._proof_1... ok
Checking: List.forIn'.loop.match_3... ok
Checking: List.append_cons... ok
Checking: List.forIn'._proof_2... ok
Checking: List.forIn'.loop._proof_1... ok
Checking: List.forIn'.loop... ok
Checking: List.forIn'._proof_3... ok
Checking: List.forIn'... ok
Checking: List.instForIn'InferInstanceMembership... ok
Checking: List.forIn_nil... FAIL
Checking: LawfulMonadLift.monadLift_pure... ok
Checking: MonadControlT.ctorIdx... ok
Checking: MonadControl.noConfusionType... ok
Checking: liftM_map... ok
Checking: Std.Irrefl... ok
Checking: Std.Irrefl.mk... ok
Checking: Std.Irrefl.rec... ok
Checking: Std.Irrefl.casesOn... ok
Checking: List.reverse_nil... ok
Checking: HOr... ok
Checking: HOr.mk... ok
Checking: HOr.rec... ok
Checking: Bool.eq_true_imp_eq_false_iff... ok
Checking: ToBool.ctorIdx... ok
Checking: _private.Init.Data.List.Lemmas.0.List.head!_of_head?.match_1_1... ok
Checking: List.head!_of_head?... ok
Checking: Monad.rec... ok
Checking: Monad.casesOn... ok
Checking: Monad.noConfusionType... ok
Checking: Monad.noConfusion... ok
Checking: PSigma.RevLex... ok
Checking: PSigma.RevLex.left... ok
Checking: PSigma.RevLex.right... ok
Checking: PSigma.RevLex.rec... ok
Checking: instReprAtomUInt16... ok
Checking: instCoeHTCTNatOfNatCast... ok
Checking: Fin.add._proof_3... ok
Checking: Fin.add... ok
Checking: boolToSort... ok
Checking: CoeHTCT.rec... ok
Checking: CoeHTCT.casesOn... ok
Checking: Lean.Meta.ApplyNewGoals.nonDependentFirst.elim... ok
Checking: Lean.Parser.Attr.grind!... ok
Checking: _private.Init.Data.List.Lemmas.0.List.eq_nil_of_length_eq_zero.match_1_1... ok
Checking: List.eq_nil_of_length_eq_zero... ok
Checking: List.length_eq_zero_iff... ok
Checking: List.length_pos_iff... ok
Checking: List.head_eq_getElem... ok
Checking: stx_*... ok
Checking: Array.appendList... ok
Checking: Array.instHAppendList... ok
Checking: MonadExceptOf.ctorIdx... ok
Checking: Max.recOn... ok
Checking: EquivBEq.rec... ok
Checking: EquivBEq.recOn... ok
Checking: List.foldr_cons_eq_append'... ok
Checking: List.foldr_cons_nil... ok
Checking: PartialEquivBEq.rec... ok
Checking: PartialEquivBEq.casesOn... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getElem_zero.match_1_1... ok
Checking: List.getElem_zero... ok
Checking: OptionT.lift... ok
Checking: OptionT.instMonadLift... ok
Checking: heq_of_eqRec_eq... ok
Checking: Trans... ok
Checking: Trans.mk... ok
Checking: Union.rec... ok
Checking: Union.casesOn... ok
Checking: Union.noConfusionType... ok
Checking: Union.noConfusion... ok
Checking: Union.mk.noConfusion... ok
Checking: Lean.Parser.Tactic.caseArg... ok
Checking: Lean.Parser.Tactic.case'... ok
Checking: PProd.noConfusionType... ok
Checking: PProd.noConfusion... ok
Checking: PProd.mk.noConfusion... ok
Checking: PProd.mk.inj... ok
Checking: _private.Init.Data.List.Lemmas.0.List.append_inj.match_1_1... ok
Checking: List.cons.inj... ok
Checking: List.append_inj... ok
Checking: List.append_inj'... ok
Checking: List.append_inj_left'... ok
Checking: List.init_eq_of_concat_eq... ok
Checking: List.append_inj_right'... ok
Checking: List.last_eq_of_concat_eq... ok
Checking: List.concat_inj... ok
Checking: Lean.Meta.Simp.NormCastConfig.rec... ok
Checking: Lean.Meta.Simp.NormCastConfig.casesOn... ok
Checking: Lean.Meta.Simp.NormCastConfig.noConfusionType... ok
Checking: Lean.Meta.Simp.NormCastConfig.noConfusion... ok
Checking: Lean.Meta.Simp.NormCastConfig.mk.noConfusion... ok
Checking: Array.recOn... ok
Checking: Lean.Meta.ApplyConfig.casesOn... ok
Checking: _private.Init.PropLemmas.0.exists_idem.match_1_1... ok
Checking: _private.Init.PropLemmas.0.exists_idem.match_1_3... ok
Checking: exists_idem... ok
Checking: And.imp_left... ok
Checking: OptionT.pure.eq_1... ok
Checking: Lean.Parser.Tactic.Conv.letToHave... ok
Checking: _auto._@.Init.Data.Array.Set.3103831426._hygCtx._hyg.9... ok
Checking: Array.set... ok
Checking: List.length_set... ok
Checking: Array.size_set... ok
Checking: Lean.Parser.Category.rec... ok
Checking: Lean.Parser.Category.recOn... ok
Checking: Nat.add_zero... ok
Checking: Nat.add_mul_div_left... ok
Checking: Nat.add_mul_div_right... ok
Checking: Nat.mul_div_cancel... ok
Checking: Nat.div_eq_of_eq_mul_left... ok
Checking: Nat.Linear.Expr.of_cancel_eq... ok
Checking: Option.pfilter_le... ok
Checking: DoResultPRBC... ok
Checking: DoResultPRBC.pure... ok
Checking: DoResultPRBC.return... ok
Checking: DoResultPRBC.break... ok
Checking: DoResultPRBC.continue... ok
Checking: DoResultPRBC.rec... ok
Checking: DoResultPRBC.casesOn... ok
Checking: DoResultPRBC.ctorIdx... ok
Checking: DoResultPRBC.ctorElimType... ok
Checking: DoResultPRBC.ctorElim... ok
Checking: MonadState.modifyGet... ok
Checking: modify... ok
Checking: MonadStateOf.get... ok
Checking: getThe... ok
Checking: MonadStateOf.modifyGet... ok
Checking: instMonadStateOfMonadStateOf... ok
Checking: instMonadStateOfOfMonadLift... ok
Checking: EStateM.get... ok
Checking: EStateM.set... ok
Checking: EStateM.modifyGet.match_1... ok
Checking: EStateM.modifyGet... ok
Checking: EStateM.instMonadStateOf... ok
Checking: Lean.Macro.State.macroScope... ok
Checking: Lean.Macro.State.traceMsgs... ok
Checking: _private.Init.Prelude.0.Lean.Macro.State.expandedMacroDecls... ok
Checking: Lean.Macro.trace... ok
Checking: Option.max... ok
Checking: Option.instMax... ok
Checking: Option.max_some_some... ok
Checking: Lean.Meta.DSimp.Config.rec... ok
Checking: Lean.Parser.Tactic.Grind.grindSeqBracketed... ok
Checking: Lean.Parser.Tactic.Grind.grindSeq... ok
Checking: Lean.Parser.Tactic.Grind.paren... ok
Checking: Fin.sub._proof_1... ok
Checking: Fin.sub... ok
Checking: Fin.instSub... ok
Checking: List.set.eq_1... ok
Checking: OptionT.bind_pure_comp... FAIL
Checking: OptionT.run... ok
Checking: OptionT.ext... ok
Checking: Option.elimM... ok
Checking: _private.Init.Control.Lawful.Instances.0.OptionT.run_bind.match_1_3... ok
Checking: OptionT.run_bind... ok
Checking: OptionT.run_pure... FAIL
Checking: _private.Init.Control.Lawful.Instances.0.OptionT.run_map._simp_1_4... ok
Checking: OptionT.run_map... ok
Checking: _private.Init.Data.Option.Basic.0.Option.map_id.match_1_1... ok
Checking: Option.map_id... ok
Checking: OptionT.seqRight_eq... ok
Checking: List.tailD... ok
Checking: List.tail?... ok
Checking: List.tailD_eq_tail?... ok
Checking: List.nil_zipWithAll... FAIL
Checking: Bool.bne_assoc... TIMEOUT
Checking: _auto._@.Init.Data.Array.Basic.1158329221._hygCtx._hyg.6... ok
Checking: _private.Init.Data.Array.Basic.0.Array.eraseIdx._unary._proof_1... ok
Checking: _auto._@.Init.Data.Array.Basic.2605673588._hygCtx._hyg.9... ok
Checking: _auto._@.Init.Data.Array.Basic.2605673588._hygCtx._hyg.17... ok
Checking: Array.swap._proof_1... ok
Checking: Array.swap... ok
Checking: Array.size_swap... ok
Checking: _private.Init.Data.Array.Basic.0.Array.eraseIdx._unary._proof_2... ok
Checking: _private.Init.Data.Array.Basic.0.Array.eraseIdx._unary._proof_3... ok
Checking: List.dropLast... ok
Checking: Array.pop... ok
Checking: Array.eraseIdx._unary... ok
Checking: Array.eraseIdx... ok
Checking: Array.eraseIdx._unary.induct... ok
Checking: Array.eraseIdx.induct... ok
Checking: _private.Init.Data.Array.Basic.0.Array.eraseIdx._proof_1... ok
Checking: _private.Init.Data.Array.Basic.0.Array.eraseIdx._unary._proof_4... ok
Checking: WellFounded.fixF_eq... ok
Checking: WellFounded.fix_eq... ok
Checking: _private.Init.Data.Array.Basic.0.PSigma.casesOn._arg_pusher... ok
Checking: _private.Init.Data.Array.Basic.0.Array.eraseIdx._unary.eq_def... ok
Checking: _private.Init.Data.Array.Basic.0.Array.eraseIdx.eq_def... ok
Checking: _private.Init.Data.Array.Basic.0.Array.size_pop.match_1_1... ok
Checking: _private.Init.Data.List.Basic.0.List.length_dropLast_cons.match_1_1... ok
Checking: List.length_dropLast_cons... ok
Checking: Array.size_pop... ok
Checking: Array.size_eraseIdx... ok
Checking: MonadWithReaderOf.mk.noConfusion... ok
Checking: MonadExcept.rec... ok
Checking: MonadExcept.casesOn... ok
Checking: List.isPrefixOf.match_1... ok
Checking: List.isPrefixOf... ok
Checking: List.isPrefixOf_nil_left... ok
Checking: ByteArray.noConfusionType... ok
Checking: ByteArray.noConfusion... ok
Checking: EST... ok
Checking: _private.Init.System.ST.0.EST.bind.match_1... ok
Checking: EST.bind... ok
Checking: EST.pure... ok
Checking: instMonadEST... ok
Checking: List.findSome?.eq_2... FAIL
Checking: Fin.pos... ok
Checking: Fin.neg._proof_1... ok
Checking: Fin.neg... ok
Checking: Fin.neg_def... TIMEOUT
Checking: List.eraseRepsBy.loop.match_1... ok
Checking: List.eraseRepsBy.loop... ok
Checking: List.isEmpty_cons... ok
Checking: Nat.mul_div_cancel_left... ok
Checking: Nat.mul_div_mul_left... ok
Checking: Nat.mul_div_mul_right... ok
Checking: CoeFun... ok
Checking: CoeFun.mk... ok
Checking: CoeFun.rec... ok
Checking: CoeFun.casesOn... ok
Checking: CoeFun.noConfusionType... ok
Checking: CoeFun.noConfusion... ok
Checking: CoeFun.mk.noConfusion... ok
Checking: LT.ctorIdx... ok
Checking: tacticSimp_wf... ok
Checking: List.Pairwise.rec... ok
Checking: List.Pairwise.casesOn... ok
Checking: Nat.Linear.ExprCnstr.recOn... ok
Checking: decidable_of_decidable_of_eq._proof_1... ok
Checking: decidable_of_decidable_of_eq... ok
Checking: DoResultPR.pure.inj... ok
Checking: List.contains_nil... ok
Checking: Except.ctorIdx... ok
Checking: Except.ctorElimType... ok
Checking: Except.ctorElim... ok
Checking: Except.ok.elim... ok
Checking: USize.size... ok
Checking: USize.ofNatLT... ok
Checking: HDiv.rec... ok
Checking: HDiv.casesOn... ok
Checking: HDiv.noConfusionType... ok
Checking: Lean.Parser.Tactic.Grind.ac... ok
Checking: List.drop... ok
Checking: List.drop.eq_2... ok
Checking: bne.eq_1... ok
Checking: bne_eq_false_iff_eq... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.filter_eq_some_iff._simp_1_2... ok
Checking: and_iff_left_iff_imp... ok
Checking: iff_self_and... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.filter_eq_some_iff._simp_1_1... ok
Checking: Option.filter_eq_some_iff... ok
Checking: Option.filter_eq_some_iff._simp_1... ok
Checking: Option.mem_filter_iff... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.pelim_filter.match_1_3... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.pelim_filter.match_1_1... ok
Checking: Option.filter_some... ok
Checking: Option.filter_some_neg... ok
Checking: Option.pelim_congr_left... ok
Checking: Option.filter_some_pos... ok
Checking: Option.pelim_filter... ok
Checking: Lean.Meta.TransparencyMode.recOn... ok
Checking: _private.Init.Data.Repr.0.Sigma.repr.match_1... ok
Checking: Sigma.repr... ok
Checking: Lean.Meta.ApplyConfig.approx... ok
Checking: Lean.Meta.DSimp.Config.unfoldPartialApp... ok
Checking: List.drop_zero... ok
Checking: instDecidableEqProd.match_3... ok
Checking: Prod.map... ok
Checking: Prod.map_apply... ok
Checking: Array.take... ok
Checking: Array.take_eq_extract... ok
Checking: _private.Init.Data.List.Lemmas.0.List.ne_nil_of_length_eq_add_one.match_1_1... ok
Checking: List.ne_nil_of_length_eq_add_one... ok
Checking: Bool.eq_or_self... ok
Checking: List.foldlRecOn.match_1... ok
Checking: List.foldlRecOn... ok
Checking: propext_iff... ok
Checking: List.modifyHead... ok
Checking: List.modify... ok
Checking: Nat.instAssociativeHAdd... ok
Checking: List.map_inj_left... ok
Checking: List.map_congr_left... ok
Checking: Lean.Parser.Tactic.grobner... ok
Checking: Prod.swap... ok
Checking: _private.Init.Data.Prod.0.Prod.swap_swap.match_1_1... ok
Checking: Prod.swap_swap... ok
Checking: Prod.swap_swap_eq... FAIL
Checking: _private.Init.Data.Repr.0.Bool.repr.match_1... ok
Checking: Bool.repr... ok
Checking: instReprBool... ok
Checking: Lean.Meta.DSimp.Config.zeta... ok
Checking: Lean.Meta.DSimp.Config.beta... ok
Checking: Lean.Meta.DSimp.Config.eta... ok
Checking: Lean.Meta.EtaStructMode.rec... ok
Checking: Lean.Meta.EtaStructMode.casesOn... ok
Checking: _private.Init.Meta.Defs.0.Lean.Meta.instReprEtaStructMode.repr.match_1... ok
Checking: Lean.Meta.instReprEtaStructMode.repr... ok
Checking: Lean.Meta.instReprEtaStructMode... ok
Checking: Lean.Meta.DSimp.Config.etaStruct... ok
Checking: Lean.Meta.DSimp.Config.iota... ok
Checking: Lean.Meta.DSimp.Config.decide... ok
Checking: Lean.Meta.DSimp.Config.failIfUnchanged... ok
Checking: Lean.Meta.DSimp.Config.zetaDelta... ok
Checking: Lean.Meta.DSimp.Config.index... ok
Checking: Lean.Meta.DSimp.Config.zetaUnused... ok
Checking: Lean.Meta.DSimp.Config.zetaHave... ok
Checking: Lean.Meta.instReprConfig.repr... ok
Checking: Lean.Meta.instReprConfig... ok
Checking: EStateM.instToStringResult.match_1... ok
Checking: EStateM.instToStringResult... ok
Checking: Lean.Parser.Tactic.rcasesPat.clear... ok
Checking: Std.LawfulIdentity... ok
Checking: Std.Identity... ok
Checking: Std.Identity.mk... ok
Checking: Std.LawfulRightIdentity... ok
Checking: Std.RightIdentity... ok
Checking: Std.RightIdentity.mk... ok
Checking: Std.LawfulRightIdentity.mk... ok
Checking: Std.LawfulIdentity.mk... ok
Checking: Std.LawfulIdentity.rec... ok
Checking: Std.LawfulIdentity.casesOn... ok
Checking: Neg.rec... ok
Checking: Neg.recOn... ok
Checking: CoeSort.coe... ok
Checking: Subtype._sizeOf_1... ok
Checking: Subtype._sizeOf_inst... ok
Checking: Subtype.mk.sizeOf_spec... ok
Checking: PSigma.recOn... ok
Checking: forall_congr'... ok
Checking: Prod.RProd... ok
Checking: Prod.RProd.intro... ok
Checking: Prod.RProd.rec... ok
Checking: Prod.RProd.recOn... ok
Checking: _private.Init.Data.List.Lemmas.0.List.filter_filter.match_1_1... ok
Checking: List.filter_filter... ok
Checking: and_congr_left... ok
Checking: and_congr_left_eq... ok
Checking: Squash... ok
Checking: Squash.mk... ok
Checking: Squash.ind... ok
Checking: instSubsingletonSquash... ok
Checking: Lean.Parser.Tactic.refine... ok
Checking: Lean.trustCompiler... ok
Checking: Lean.reduceNat... ok
Checking: Lean.ofReduceNat... ok
Checking: ByteArray.mk.noConfusion... ok
Checking: ByteArray.mk.injEq... ok
Checking: Lean.Macro.Methods.ctorIdx... ok
Checking: _private.Init.PropLemmas.0.exists_false.match_1_1... ok
Checking: exists_false... ok
Checking: exists_false._simp_1... ok
Checking: exists_eq'... ok
Checking: exists_eq'._simp_1... ok
Checking: Option.isSome_iff_exists... ok
Checking: List.filterMap_replicate.match_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.filterMap_replicate.match_1.splitter... ok
Checking: List.forall_none_of_filterMap_eq_nil... ok
Checking: List.filterMap_eq_nil_iff... ok
Checking: List.filterMap_eq_nil_iff._simp_1... ok
Checking: List.mem_replicate._simp_1... ok
Checking: List.filterMap_replicate... ok
Checking: List.filterMap_replicate_of_isSome... ok
Checking: Option.ite_none_right_eq_some... ok
Checking: HasSubset.noConfusionType... ok
Checking: HasSubset.noConfusion... ok
Checking: HasSubset.mk.noConfusion... ok
Checking: Mod.rec... ok
Checking: Mod.casesOn... ok
Checking: Mod.noConfusionType... ok
Checking: Mod.noConfusion... ok
Checking: Mod.mk.noConfusion... ok
Checking: List.filterMap_cons_some... FAIL
Checking: List.filterMap_cons_none... FAIL
Checking: List.filterMap_eq_filter... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.getTrailingSize._sparseCasesOn_1... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.isNatLitAux.match_1... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.structEq._sparseCasesOn_2... ok
Checking: _private.Init.Meta.Defs.0.Lean.expandMacros.match_1... ok
Checking: Nat.lt_of_sub_ne_zero... ok
Checking: Nat.lt_of_sub_pos... ok
Checking: Nat.lt_of_sub_eq_succ... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.isLit?._proof_1... ok
Checking: Lean.Syntax.isLit?... ok
Checking: Lean.nameLitKind... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.decodeNameLit.match_1... ok
Checking: _private.Init.Meta.Defs.0.Substring.Raw.toName._sparseCasesOn_3... ok
Checking: _private.Init.Meta.Defs.0.Substring.Raw.toName.match_3... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.splitNameLitAux... ok
Checking: Substring.Raw.Internal.toString... ok
Checking: String.Internal.front... ok
Checking: String.Internal.dropRight... ok
Checking: String.Internal.drop... ok
Checking: _private.Init.Meta.Defs.0.Substring.Raw.toName.match_1... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.decodeHexLitAux... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.decodeBinLitAux... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.decodeOctalLitAux... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.decodeDecimalLitAux... ok
Checking: Lean.Syntax.decodeNatLitVal?... ok
Checking: Substring.Raw.toName... ok
Checking: Lean.Syntax.decodeNameLit... ok
Checking: Lean.Syntax.isNameLit?... ok
Checking: List.length.eq_1... ok
Checking: BitVec.add... ok
Checking: BitVec.instAdd... ok
Checking: USize.add... ok
Checking: Nat.Linear.Poly.cancelAux.eq_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.append_eq_replicate_iff._simp_1_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.append_eq_replicate_iff._simp_1_2... ok
Checking: List.append_eq_replicate_iff... ok
Checking: List.replicate_eq_append_iff... ok
Checking: Lean.Syntax.getHead?... ok
Checking: ExceptT.run_bind.match_1... ok
Checking: ExceptT.run_bind... FAIL
Checking: Option.lt.eq_2... ok
Checking: Nat.le_of_mul_le_mul_right... ok
Checking: Nat.not_lt_of_le... ok
Checking: Lean.Meta.instInhabitedEtaStructMode.default... ok
Checking: Option.get!.match_1... ok
Checking: Option.get!... ok
Checking: Option.isSome_choice_iff_nonempty... ok
Checking: Option.isSome_choice... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.get_eq_get!.match_1_1... ok
Checking: Option.get_eq_get!... ok
Checking: Option.get!_choice... ok
Checking: List.toList_toArray... ok
Checking: Lean.Meta.Simp.Config.casesOn... ok
Checking: _private.Init.MetaTypes.0.Lean.Meta.Simp.instBEqConfig.beq.match_1... ok
Checking: Lean.Meta.EtaStructMode.ctorIdx... ok
Checking: Lean.Meta.instBEqEtaStructMode.beq... ok
Checking: Lean.Meta.instBEqEtaStructMode... ok
Checking: Lean.Meta.Simp.instBEqConfig.beq... ok
Checking: Lean.Meta.Simp.instBEqConfig... ok
Checking: Lean.Module... ok
Checking: Lean.Module.mk... ok
Checking: Lean.Module.rec... ok
Checking: Lean.Module._sizeOf_1... ok
Checking: Lean.Module._sizeOf_inst... ok
Checking: Lean.Module.mk.sizeOf_spec... ok
Checking: term¬_... ok
Checking: Lean.ParserDescr.node.noConfusion... ok
Checking: forall_prop_decidable._proof_1... ok
Checking: forall_prop_decidable._proof_2... ok
Checking: forall_prop_decidable... ok
Checking: SeqRight.rec... ok
Checking: SeqRight.casesOn... ok
Checking: SeqRight.noConfusionType... ok
Checking: SeqRight.noConfusion... ok
Checking: SeqRight.mk.noConfusion... ok
Checking: EStateM.Backtrackable.rec... ok
Checking: Option.le_min... ok
Checking: Lean.Parser.Tactic.rwRule... ok
Checking: Lean.Parser.Tactic.rwRuleSeq... ok
Checking: Lean.Parser.Tactic.tacticRw_mod_cast___... ok
Checking: some_getElem_eq_getElem?_iff... ok
Checking: HMul.casesOn... ok
Checking: HMul.noConfusionType... ok
Checking: HMul.noConfusion... ok
Checking: Nat.succ_eq_add_one... ok
Checking: Lean.Grind.CutsatConfig... ok
Checking: Lean.Grind.CutsatConfig.mk... ok
Checking: Lean.Grind.CutsatConfig.rec... ok
Checking: Lean.Grind.CutsatConfig._sizeOf_1... ok
Checking: Lean.Grind.CutsatConfig._sizeOf_inst... ok
Checking: Lean.Grind.CutsatConfig.mk.sizeOf_spec... ok
Checking: List.sum... ok
Checking: List.sum_nil... ok
Checking: Lean.Parser.Category.prec... ok
Checking: Std.LawfulIdentity.recOn... ok
Checking: Lean.Grind.CutsatConfig.casesOn... ok
Checking: MonadState.get... ok
Checking: Lean.Macro.instInhabitedState.default... ok
Checking: Lean.Macro.instInhabitedState... ok
Checking: MonadWithReader.rec... ok
Checking: MonadWithReader.casesOn... ok
Checking: MonadWithReader.noConfusionType... ok
Checking: MonadWithReader.noConfusion... ok
Checking: HAppend.recOn... ok
Checking: False.recOn... ok
Checking: True.casesOn... ok
Checking: _private.Init.Data.List.Basic.0.List.dropLast.match_1.splitter... ok
Checking: _private.Init.Data.List.Basic.0.List.dropLast.match_1.eq_3... ok
Checking: List.dropLast.eq_def... ok
Checking: List.dropLast.eq_3... ok
Checking: List.getElem_replicate... ok
Checking: List.getElem?_replicate_of_lt... ok
Checking: Option.isNone_map... ok
Checking: Lean.withAnnotateTerm... ok
Checking: _private.Init.GetElem.0.List.getElem_cons_drop.match_1_1... ok
Checking: Nat.add_one_lt_add_one_iff... ok
Checking: List.getElem_cons_drop... ok
Checking: List.getElem_cons_drop_succ_eq_drop... ok
Checking: Lean.Parser.Category.command... ok
Checking: _private.Init.Data.List.BasicAux.0.List.get.match_1.splitter... ok
Checking: List.get.eq_def... ok
Checking: NatPow.recOn... ok
Checking: Lean.Macro.Exception.rec... ok
Checking: Lean.Macro.Exception.casesOn... ok
Checking: Lean.Macro.Exception.ctorIdx... ok
Checking: HomogeneousPow.pow... ok
Checking: instPowOfHomogeneousPow... ok
Checking: Int.noConfusionType... ok
Checking: Trans.ctorIdx... ok
Checking: HEq.symm... ok
Checking: HEq.comm... ok
Checking: iff_true_left... ok
Checking: iff_true_right... ok
Checking: iff_false_right... ok
Checking: Decidable.not_iff... ok
Checking: Lean.Parser.Syntax.addPrio... ok
Checking: List.rotateRight... ok
Checking: List.rotateRight_nil... TIMEOUT
Checking: List.get.eq_2... ok
Checking: Array.mapFinIdxM.map.match_1... ok
Checking: Array.mapFinIdxM._proof_1... ok
Checking: Array.mapFinIdxM._proof_2... ok
Checking: Array.mapFinIdxM.map... ok
Checking: Array.mapFinIdxM._proof_3... ok
Checking: Array.mapFinIdxM... ok
Checking: Array.mapFinIdx... ok
Checking: PLift... ok
Checking: PLift.up... ok
Checking: PLift.rec... ok
Checking: PLift.casesOn... ok
Checking: PLift.noConfusionType... ok
Checking: PLift.noConfusion... ok
Checking: PLift.up.noConfusion... ok
Checking: _private.Init.Data.List.Lemmas.0.List.forall_mem_nil.match_1_1... ok
Checking: List.forall_mem_nil... ok
Checking: instToStringPUnit... ok
Checking: List.decidableBAll.match_1... ok
Checking: List.decidableBAll._proof_1... ok
Checking: List.decidableBAll.match_5... ok
Checking: List.decidableBAll.match_3... ok
Checking: List.decidableBAll._proof_2... ok
Checking: List.decidableBAll._proof_3... ok
Checking: List.decidableBAll._proof_4... ok
Checking: List.decidableBAll... ok
Checking: Bool.decide_and... ok
Checking: Bool.decide_eq_true... ok
Checking: List.all_eq... ok
Checking: ite_iff_ite... ok
Checking: or_right_comm... ok
Checking: MonadReader.recOn... ok
Checking: List.isEmpty_iff... ok
Checking: List.isEmpty_iff._simp_1... ok
Checking: List.head_append._proof_1... ok
Checking: List.head_append._proof_2... ok
Checking: List.head_append... ok
Checking: List.eraseDupsBy.loop... ok
Checking: List.eraseDupsBy.loop.eq_2... ok
Checking: Nat.Linear.instInhabitedExpr.default... ok
Checking: Nat.Linear.instInhabitedExpr... ok
Checking: _private.Init.Data.Array.Basic.0.Array.ofFn.go.match_1... ok
Checking: Nat.sub_one_lt... ok
Checking: Nat.sub_ne_zero_iff_lt... ok
Checking: _private.Init.Data.Array.Basic.0.Array.ofFn.go._proof_1... ok
Checking: _private.Init.Data.Array.Basic.0.Array.ofFn.go... ok
Checking: Array.ofFn... ok
Checking: Array.range'... ok
Checking: Decidable.not_imp_not... ok
Checking: Std.Format.below... ok
Checking: Std.Format.brecOn.go... ok
Checking: Std.Format.brecOn... ok
Checking: _private.Init.Data.Format.Basic.0.Std.Format.isEmpty.match_1... ok
Checking: Std.Format.isEmpty... ok
Checking: List.dropLast.eq_2... ok
Checking: List.foldlRecOn_cons... ok
Checking: List.ctorElimType... ok
Checking: List.ctorElim... ok
Checking: List.cons.elim... ok
Checking: Nat.mul_eq... ok
Checking: Nat.zero_ne_one... ok
Checking: Nat.zero_ne_one._simp_1... ok
Checking: Bool.toNat_eq_one... ok
Checking: PEmpty.casesOn... ok
Checking: PEmpty.elim.match_1... ok
Checking: PEmpty.elim... ok
Checking: instSubsingletonPEmpty... ok
Checking: Option.getDM... ok
Checking: LawfulMonadLift.rec... ok
Checking: Lean.Quote.quote... ok
Checking: Option.map_congr... ok
Checking: EmptyCollection.emptyCollection... ok
Checking: List.instEmptyCollection... ok
Checking: List.empty_eq... ok
Checking: Bool.true_bne... TIMEOUT
Checking: List.getD... ok
Checking: List.getD.eq_1... ok
Checking: Lean.Parser.Category.casesOn... ok
Checking: Lean.Parser.Category.noConfusionType... ok
Checking: Char.noConfusionType... ok
Checking: Char.noConfusion... ok
Checking: Char.mk.noConfusion... ok
Checking: Char.mk.inj... ok
Checking: Array.isEmpty... ok
Checking: monadLift_self... ok
Checking: iff_iff_implies_and_implies... ok
Checking: Decidable.not_or_of_imp... ok
Checking: Or.neg_resolve_left... ok
Checking: Decidable.imp_iff_not_or... ok
Checking: _private.Init.PropLemmas.0.Decidable.iff_iff_not_or_and_or_not._simp_1_1... ok
Checking: _private.Init.PropLemmas.0.Decidable.iff_iff_not_or_and_or_not._simp_1_2... ok
Checking: Decidable.iff_iff_not_or_and_or_not... ok
Checking: Lean.Meta.ApplyConfig.noConfusionType... ok
Checking: Lean.Meta.ApplyConfig.noConfusion... ok
Checking: Lean.Meta.ApplyConfig.mk.noConfusion... ok
Checking: Quot.indBeta... ok
Checking: withPtrEq... ok
Checking: _private.Init.Util.0.withPtrEqDecEq._proof_1... ok
Checking: _private.Init.Util.0.withPtrEqDecEq.match_1... ok
Checking: of_toBoolUsing_eq_true... ok
Checking: _private.Init.Util.0.withPtrEqDecEq._proof_2... ok
Checking: of_toBoolUsing_eq_false... ok
Checking: _private.Init.Util.0.withPtrEqDecEq._proof_3... ok
Checking: withPtrEqDecEq... ok
Checking: List.all_nil... ok
Checking: Std.Format.FlattenAllowability.ctorElimType... ok
Checking: Std.Format.FlattenAllowability.ctorElim... ok
Checking: Std.Format.FlattenAllowability.allow.elim... ok
Checking: _private.Init.Data.List.Lemmas.0.List.exists_mem_of_length_pos.match_1_1... ok
Checking: List.exists_mem_of_length_pos... ok
Checking: List.exists_mem_of_ne_nil... ok
Checking: MonadEvalT... ok
Checking: MonadEvalT.mk... ok
Checking: congrFun... ok
Checking: Option.map_id'... ok
Checking: Option.map_id_fun'... ok
Checking: Option.map_id_apply'... ok
Checking: ULift... ok
Checking: ULift.up... ok
Checking: List.filterTR.loop... ok
Checking: _private.Init.Data.List.Lemmas.0.List.dropLast_replicate.match_1_1... ok
Checking: List.replicate_succ... FAIL
Checking: List.dropLast_cons_of_ne_nil... ok
Checking: List.replicate_succ_ne_nil... FAIL
Checking: List.replicate_succ_ne_nil._simp_1... ok
Checking: List.dropLast_replicate... ok
Checking: Lean.Parser.Tactic.Grind.grind_filter!_... ok
Checking: List.forall_mem_ne... ok
Checking: Lean.Macro.Exception.noConfusionType... ok
Checking: Lean.Macro.Exception.noConfusion... ok
Checking: Nat.Linear.PolyCnstr.ctorIdx... ok
Checking: Option.guard_congr... ok
Checking: _private.Init.PropLemmas.0.exists_eq_or_imp._simp_1_1... ok
Checking: _private.Init.PropLemmas.0.exists_eq_or_imp._simp_1_2... ok
Checking: exists_eq_or_imp... ok
Checking: exists_eq_or_imp._simp_1... ok
Checking: Bool.decide_or... ok
Checking: List.any_eq... ok
Checking: List.decide_exists_mem... ok
Checking: HomogeneousPow.rec... ok
Checking: HomogeneousPow.casesOn... ok
Checking: Lean.instInhabitedNameGenerator.default... ok
Checking: Lean.instInhabitedNameGenerator... ok
Checking: BEq.recOn... ok
Checking: Std.ToFormat.rec... ok
Checking: Std.ToFormat.casesOn... ok
Checking: Std.ToFormat.noConfusionType... ok
Checking: PUnit.ext... ok
Checking: PUnit.ext_iff... ok
Checking: Sum.noConfusionType... ok
Checking: Sum.noConfusion... ok
Checking: Sum.inl.noConfusion... ok
Checking: Sum.inl.injEq... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getLast_mem.match_1_1... ok
Checking: List.getLast_mem... ok
Checking: exists_prop_decidable.match_1... ok
Checking: exists_prop_decidable._proof_1... ok
Checking: exists_prop_decidable._proof_2... ok
Checking: exists_prop_decidable... ok
Checking: Lean.Meta.EtaStructMode.recOn... ok
Checking: StateT.map.eq_1... ok
Checking: DoResultSBC... ok
Checking: DoResultSBC.pureReturn... ok
Checking: DoResultSBC.break... ok
Checking: DoResultSBC.continue... ok
Checking: DoResultSBC.rec... ok
Checking: DoResultSBC.casesOn... ok
Checking: DoResultSBC.ctorIdx... ok
Checking: DoResultSBC.ctorElimType... ok
Checking: DoResultSBC.ctorElim... ok
Checking: DoResultSBC.pureReturn.elim... ok
Checking: DoResultSBC.break.elim... ok
Checking: DoResultSBC.continue.elim... ok
Checking: DoResultSBC.noConfusionType... ok
Checking: DoResultSBC.noConfusion... ok
Checking: Lean.TSyntaxArray... ok
Checking: Array.instInhabited... ok
Checking: Lean.Parser.Tactic.getConfigItems... ok
Checking: Bool.xor... ok
Checking: Bool.bne_not_self... TIMEOUT
Checking: Bool.xor_not_self... ok
Checking: Bool.and_comm... ok
Checking: Bool.xor_right_comm... TIMEOUT
Checking: List.Mem.recOn... ok
Checking: List.max... ok
Checking: Seq.ctorIdx... ok
Checking: List.append_eq_appendTR... ok
Checking: Std.LawfulCommIdentity... ok
Checking: Std.LawfulCommIdentity.mk... ok
Checking: Std.LawfulCommIdentity.rec... ok
Checking: List.getD_nil... ok
Checking: Coe.coe... ok
Checking: Int.term-[_+1]... ok
Checking: String.ofByteArray.sizeOf_spec... ok
Checking: USize.instOfNat... ok
Checking: withPtrAddr... ok
Checking: List.reverse_eq_iff... ok
Checking: _private.Init.Data.List.Lemmas.0.List.reverse_inj._simp_1_1... ok
Checking: List.reverse_inj... ok
Checking: List.reverse_inj._simp_1... ok
Checking: List.append_singleton_inj... ok
Checking: List.foldl_cons... FAIL
Checking: Inhabited.rec... ok
Checking: Inhabited.casesOn... ok
Checking: List.append_ne_nil_of_left_ne_nil... ok
Checking: Task... ok
Checking: Task.pure... ok
Checking: Task.Priority.default... ok
Checking: Task.get... ok
Checking: Task.map... ok
Checking: iff_false_intro... ok
Checking: _private.Init.SimpLemmas.0.and_not_self.match_1_1... ok
Checking: and_not_self... ok
Checking: not_and_self... ok
Checking: not_and_self_iff... ok
Checking: LawfulFunctor.comp_map... ok
Checking: Functor.map_map... FAIL
Checking: map_inj_of_left_inverse... ok
Checking: Int.instLEInt... ok
Checking: Int.lt... ok
Checking: Int.instLTInt... ok
Checking: Int.NonNeg.rec... ok
Checking: Int.NonNeg.casesOn... ok
Checking: Int.noConfusion... ok
Checking: Int.decNonneg.match_1... ok
Checking: Int.decNonneg._proof_1... ok
Checking: Int.decNonneg... ok
Checking: Int.decLt... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.getTrailingSize._sparseCasesOn_2... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.getSubstring?.match_1... ok
Checking: Substring.Raw.str... ok
Checking: Substring.Raw.startPos... ok
Checking: Substring.Raw.stopPos... ok
Checking: Lean.Syntax.getSubstring?... ok
Checking: List.dropLast_cons_self_replicate... ok
Checking: Lean.SourceInfo.original.elim... ok
Checking: noConfusionTypeEnum... ok
Checking: Lean.Meta.ApplyNewGoals.noConfusionType... ok
Checking: noConfusionEnum._proof_1... ok
Checking: noConfusionEnum... ok
Checking: Lean.Meta.ApplyNewGoals.noConfusion... ok
Checking: Bool.false_bne... TIMEOUT
Checking: Bool.bne_false... TIMEOUT
Checking: Bool.instLawfulIdentityBneFalse... ok
Checking: DoResultPRBC.pure.elim... ok
Checking: DoResultPRBC.return.elim... ok
Checking: DoResultPRBC.break.elim... ok
Checking: DoResultPRBC.continue.elim... ok
Checking: DoResultPRBC.noConfusionType... ok
Checking: DoResultPRBC.noConfusion... ok
Checking: DoResultPRBC.continue.noConfusion... ok
Checking: Prod.lexLtDec... ok
Checking: PSigma.Lex... ok
Checking: PSigma.Lex.left... ok
Checking: PSigma.Lex.right... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getLast_mem_getLast?.match_1_1... ok
Checking: List.getLast_mem_getLast?... ok
Checking: OfNat.ctorIdx... ok
Checking: Lean.ParserDescr._sizeOf_1... ok
Checking: Lean.ParserDescr._sizeOf_inst... ok
Checking: Lean.ParserDescr.parser.sizeOf_spec... ok
Checking: _private.Init.Data.Option.Instances.0.Option.eq_none_of_isNone.match_1_1... ok
Checking: Option.eq_none_of_isNone... ok
Checking: Option.isNone_iff_eq_none... ok
Checking: instReprTupleOfRepr... ok
Checking: Option.isSome_guard... ok
Checking: Nat.succ_lt_of_lt_pred... ok
Checking: Functor.rec... ok
Checking: Functor.casesOn... ok
Checking: Functor.noConfusionType... ok
Checking: Functor.noConfusion... ok
Checking: term_/_... ok
Checking: Std.Format.recOn... ok
Checking: Std.Associative.rec... ok
Checking: Std.Associative.casesOn... ok
Checking: Std.LeftIdentity.rec... ok
Checking: Lean.Parser.Tactic.Grind.grindFilter... ok
Checking: HOrElse... ok
Checking: HOrElse.mk... ok
Checking: HOrElse.ctorIdx... ok
Checking: liftM_bind... ok
Checking: UInt16._sizeOf_1... ok
Checking: UInt16._sizeOf_inst... ok
Checking: UInt16.ofBitVec.sizeOf_spec... ok
Checking: beq_true... ok
Checking: Nat.Linear.PolyCnstr.isValid... ok
Checking: Nat.Linear.PolyCnstr.isValid.eq_1... ok
Checking: List.forM.match_1... ok
Checking: List.forM... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getLast?_flatMap._simp_1_1... ok
Checking: List.reverse_flatMap... ok
Checking: _private.Init.Data.List.Lemmas.0.List.findSome?.match_1.splitter... ok
Checking: List.head?_eq_none_iff... ok
Checking: List.head?_eq_none_iff._simp_1... ok
Checking: List.head?_flatMap... ok
Checking: List.getLast?_flatMap... ok
Checking: List.tail_eq_of_cons_eq... ok
Checking: DoResultSBC.continue.noConfusion... ok
Checking: _private.Init.Data.List.Lemmas.0.List.contains_insert._simp_1_2... ok
Checking: List.contains_eq_any_beq... ok
Checking: List.any_congr... ok
Checking: BEq.trans... ok
Checking: BEq.congr_left... ok
Checking: List.contains_congr... ok
Checking: List.contains_insert... ok
Checking: Option.eq_some_iff_get_eq... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.pfilter_eq_some_iff._simp_1_1... ok
Checking: _private.Init.PropLemmas.0.exists_prop_eq.match_1_1... ok
Checking: exists_prop_eq... ok
Checking: exists_prop_eq._simp_1... ok
Checking: exists_prop_eq'... ok
Checking: exists_prop_eq'._simp_1... ok
Checking: Option.isSome_pfilter_iff... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.pfilter_eq_some_iff._simp_1_2... ok
Checking: Option.get_pfilter... ok
Checking: Option.pfilter_eq_some_iff... ok
Checking: Option.pfilter_congr... ok
Checking: Option.pfilter_pfilter... ok
Checking: ExceptCpsT.run... ok
Checking: ExceptCpsT.instMonad... ok
Checking: ExceptCpsT.run_pure... FAIL
Checking: Option.join_map_eq_map_join... ok
Checking: Int.mul... ok
Checking: Int.instMul... ok
Checking: Nat.toUSize... ok
Checking: Array.usize... ok
Checking: Array.usize.eq_1... ok
Checking: Bool.lt_of_le_of_lt... ok
Checking: ToBool.rec... ok
Checking: ToBool.casesOn... ok
Checking: ToBool.noConfusionType... ok
Checking: Except.noConfusion... ok
Checking: Except.ok.noConfusion... ok
Checking: Except.ok.inj... ok
Checking: Option.isSome_dite'... ok
Checking: Option.isSome_dite'._simp_1... ok
Checking: Option.get_dite'._proof_1... ok
Checking: Option.get_dite'... ok
Checking: StateCpsT.run... ok
Checking: StateCpsT.run_eq... ok
Checking: UInt64.ofNat... ok
Checking: UInt64.instOfNat... ok
Checking: List.partition.loop.eq_1... ok
Checking: List.filterMap_cons... FAIL
Checking: Lean.Meta.ApplyNewGoals._sizeOf_1... ok
Checking: Lean.Meta.ApplyNewGoals._sizeOf_inst... ok
Checking: Lean.Meta.ApplyConfig._sizeOf_1... ok
Checking: Lean.Meta.ApplyConfig._sizeOf_inst... ok
Checking: Lean.Meta.ApplyConfig.mk.sizeOf_spec... ok
Checking: Lean.Syntax.getOptional?... ok
Checking: Lean.Syntax.getOptionalIdent?... ok
Checking: ShiftLeft.ctorIdx... ok
Checking: Bool.and_or_distrib_left... ok
Checking: List.and_any_distrib_left... ok
Checking: List.ne_cons_self... ok
Checking: List.ne_cons_self._simp_1... ok
Checking: _private.Init.SimpLemmas.0.or_self.match_1_1... ok
Checking: or_self... ok
Checking: List.append_eq_singleton_iff... ok
Checking: Nat.eq_self_sub_one... ok
Checking: List.getLast?.eq_1... ok
Checking: Bool.recOn... ok
Checking: Lean.Parser.Tactic.Grind.fail... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.eq_zero_or_eq_succ_pred.match_1_1... ok
Checking: Nat.eq_zero_or_eq_succ_pred... ok
Checking: Bool.not_eq_false... ok
Checking: Bool.not_ite_eq_true_eq_false... ok
Checking: Nat.Linear.instBEqPolyCnstr.beq.match_1... ok
Checking: List.getLastD.match_1... ok
Checking: List.headD... ok
Checking: List.headD.eq_1... ok
Checking: USize.lt... ok
Checking: List.splitAt.go._sparseCasesOn_1... ok
Checking: List.splitAt.go.match_1... ok
Checking: List.splitAt.go... ok
Checking: _private.Init.Data.List.Lemmas.0.List.splitAt.go.match_1.splitter... ok
Checking: _private.Init.Data.List.Lemmas.0.List.splitAt.go.match_1.eq_3... ok
Checking: List.splitAt.go.eq_def... ok
Checking: Lean.SourceInfo.synthetic.elim... ok
Checking: Lean.SourceInfo.noConfusionType... ok
Checking: Lean.SourceInfo.noConfusion... ok
Checking: Lean.SourceInfo.original.noConfusion... ok
Checking: Option.isNone_some... ok
Checking: String.Pos.Raw.casesOn... ok
Checking: String.Pos.Raw.noConfusionType... ok
Checking: String.Pos.Raw.noConfusion... ok
Checking: String.Pos.Raw.mk.noConfusion... ok
Checking: String.Pos.Raw.mk.injEq... ok
Checking: instMonadControlOptionTOfMonad... ok
Checking: List.append_concat... ok
Checking: List.getLast?_eq_head?_reverse... ok
Checking: _private.Init.PropLemmas.0.exists_and_left.match_1_1... ok
Checking: _private.Init.PropLemmas.0.exists_and_left.match_1_3... ok
Checking: exists_and_left... ok
Checking: exists_and_left._simp_1... ok
Checking: List.head?_eq_some_iff... ok
Checking: List.reverse_eq_cons_iff... ok
Checking: List.reverse_eq_cons_iff._simp_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getLast?_eq_some_iff.match_1_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getLast?_eq_some_iff.match_1_3... ok
Checking: List.getLast?_eq_some_iff... ok
Checking: PULift.rec... ok
Checking: PULift.casesOn... ok
Checking: PULift.noConfusionType... ok
Checking: PULift.noConfusion... ok
Checking: PULift.up.noConfusion... ok
Checking: GetElem?.rec... ok
Checking: GetElem?.casesOn... ok
Checking: GetElem?.noConfusionType... ok
Checking: GetElem?.noConfusion... ok
Checking: GetElem?.mk.noConfusion... ok
Checking: Lean.Parser.Attr.grind!?... ok
Checking: MonadExceptOf.rec... ok
Checking: MonadExceptOf.casesOn... ok
Checking: MonadExceptOf.noConfusionType... ok
Checking: MonadExceptOf.noConfusion... ok
Checking: Std.RightIdentity.rec... ok
Checking: Std.RightIdentity.casesOn... ok
Checking: ST.Ref.set... ok
Checking: List.getElem_append._proof_1... ok
Checking: List.getElem_append... ok
Checking: Decidable.recOn... ok
Checking: Lean.Option.hasQuote.match_1... ok
Checking: Lean.mkIdent... ok
Checking: Lean.Syntax.Term... ok
Checking: Array.toListLitAux._proof_1... ok
Checking: Array.getLit._proof_1... ok
Checking: Array.getLit... ok
Checking: Array.toListLitAux._proof_2... ok
Checking: Array.toListLitAux... ok
Checking: Array.toArrayLit._proof_1... ok
Checking: Array.toArrayLit... ok
Checking: Array.toListLitAux.congr_simp... ok
Checking: _private.Init.Data.Array.GetLit.0.Array.toArrayLit_eq.getLit_eq... ok
Checking: _private.Init.Data.Array.GetLit.0.Array.toArrayLit_eq.go... ok
Checking: _private.Init.Data.List.Basic.0.List.drop_eq_nil_of_le.match_1_1... ok
Checking: List.drop_nil... ok
Checking: List.drop_eq_nil_of_le... ok
Checking: Array.toArrayLit_eq... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.mkApp.match_1... ok
Checking: Lean.TSyntaxArray.raw... ok
Checking: Lean.Syntax.mkApp... ok
Checking: Lean.mkCIdent... ok
Checking: Lean.Syntax.mkCApp... ok
Checking: Lean.Option.hasQuote... ok
Checking: ST.Out._sizeOf_1... ok
Checking: ST.Out._sizeOf_inst... ok
Checking: ST.Out.mk.sizeOf_spec... ok
Checking: _private.Init.Data.Nat.Linear.0.Nat.Linear.Poly.denote.match_1.splitter... ok
Checking: Nat.Linear.Poly.insert.eq_def... ok
Checking: EquivBEq.toPartialEquivBEq... ok
Checking: List.getLastD... ok
Checking: List.getLastD_eq_getLast?... ok
Checking: _private.Init.Data.List.Lemmas.0.List.map_eq_nil_iff.match_1_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.map_eq_nil_iff.match_1_3... ok
Checking: List.map_eq_nil_iff... ok
Checking: List.map_eq_nil_iff._simp_1... ok
Checking: List.head_map._proof_1... ok
Checking: List.getElem_cons_length._proof_1... ok
Checking: List.getElem_cons_length... ok
Checking: List.length_map... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getElem?_map.match_1_1... ok
Checking: List.getElem?_map... ok
Checking: List.getElem_map... ok
Checking: List.getLast_map... ok
Checking: List.getLast?_map... ok
Checking: List.getLastD_map... ok
Checking: List.anyM... ok
Checking: iff_and_self... ok
Checking: Lean.ParserDescr.below... ok
Checking: Lean.ParserDescr.brecOn.go... ok
Checking: Lean.ParserDescr.brecOn... ok
Checking: Option.all_map... ok
Checking: MonadFunctor.casesOn... ok
Checking: MonadFunctor.noConfusionType... ok
Checking: Prod.map_id'... FAIL
Checking: Id.ext... ok
Checking: Id.ext_iff... ok
Checking: Decidable.not_or_self... ok
Checking: instForInOfForIn'.eq_1... ok
Checking: _private.Init.PropLemmas.0.Exists.imp.match_1_1... ok
Checking: Exists.imp... ok
Checking: exists_congr... ok
Checking: exists₂_congr... ok
Checking: exists₃_congr... ok
Checking: CoeOut.rec... ok
Checking: CoeOut.casesOn... ok
Checking: List.replace_replicate_ne... ok
Checking: List.append_inj_right... ok
Checking: List.cons_lex_cons... ok
Checking: Lean.Parser.Tactic.done... ok
Checking: List.zipWithM.loop... ok
Checking: Lean.Grind.Config.noConfusion... ok
Checking: Lean.Grind.Config.mk.noConfusion... ok
Checking: Lean.Grind.Config.mk.injEq... ok
Checking: Lean.rawStx.quot... ok
Checking: Lean.Parser.Tactic.rcasesPatMed... ok
Checking: Lean.Parser.Tactic.rcasesPatLo... ok
Checking: UInt8.ofBitVec.sizeOf_spec... ok
Checking: Lean.Grind.NoopConfig.casesOn... ok
Checking: Lean.Grind.NoopConfig.noConfusionType... ok
Checking: Lean.Grind.NoopConfig.noConfusion... ok
Checking: Lean.Grind.NoopConfig.mk.noConfusion... ok
Checking: Lean.firstFrontendMacroScope... ok
Checking: Bool.lt_irrefl... ok
Checking: Bind.casesOn... ok
Checking: Bind.noConfusionType... ok
Checking: Option.instDecidableEq.decEq.match_1... ok
Checking: ForInStep.recOn... ok
Checking: Option.join_min... ok
Checking: term{_}... ok
Checking: Substring.Raw.Internal.get... ok
Checking: Lean.Parser.Tactic.mframeMacro... ok
Checking: Quot.liftBeta... ok
Checking: _private.Init.Data.Nat.Div.Basic.0.Nat.add_mul_mod_self_left.match_1_1... ok
Checking: _private.Init.Data.Nat.Div.Basic.0.Nat.mod_eq_sub_mod.match_1_1... ok
Checking: Nat.mod_eq_sub_mod... ok
Checking: Nat.add_mod_right... ok
Checking: Nat.add_mul_mod_self_left... ok
Checking: _private.Init.Data.List.Basic.0.List.getLast?.match_1.splitter... ok
Checking: List.filter.eq_def... ok
Checking: Option.get!_join... ok
Checking: Nat.Linear.Expr._sizeOf_1... ok
Checking: Nat.Linear.Expr._sizeOf_inst... ok
Checking: Nat.Linear.Expr.mulL.sizeOf_spec... ok
Checking: _private.Init.Meta.Defs.0.Lean.version.getPatch... ok
Checking: Lean.version.patch... ok
Checking: _private.Init.Data.Array.Basic.0.Array.isPrefixOfAux._proof_1... ok
Checking: _private.Init.Data.Array.Basic.0.Array.isPrefixOfAux._proof_2... ok
Checking: _private.Init.Data.Array.Basic.0.Array.isPrefixOfAux._proof_3... ok
Checking: Array.isPrefixOfAux... ok
Checking: Array.forM... ok
Checking: ForM.forM... ok
Checking: Array.instForM... ok
Checking: Array.forM_eq_forM... ok
Checking: StateM... ok
Checking: Lean.Syntax.ctorElimType... ok
Checking: Lean.Syntax.ctorElim... ok
Checking: Lean.Syntax.missing.elim... ok
Checking: Lean.Syntax.node.elim... ok
Checking: Lean.Syntax.atom.elim... ok
Checking: Lean.Syntax.ident.elim... ok
Checking: Lean.Syntax.noConfusionType... ok
Checking: Lean.Syntax.noConfusion... ok
Checking: Lean.Syntax.ident.noConfusion... ok
Checking: Lean.binderPred⊇_... ok
Checking: CoeDep.recOn... ok
Checking: Option.filter_pfilter... ok
Checking: and_congr... ok
Checking: and_congr_right'... ok
Checking: PSigma.SkipLeft... ok
Checking: PSigma.mkSkipLeft... ok
Checking: not_and_of_not_or_not... ok
Checking: Decidable.not_and_iff_not_or_not'... ok
Checking: MonadEval.monadEval... ok
Checking: MonadEvalT.monadEval... ok
Checking: instMonadEvalTOfMonadEval... ok
Checking: Lean.includeStr... ok
Checking: Lean.Parser.Tactic.Grind.nestedTacticCore... ok
Checking: Thunk.recOn... ok
Checking: EStateM.Result.noConfusionType... ok
Checking: EStateM.Result.noConfusion... ok
Checking: EStateM.Result.ok.noConfusion... ok
Checking: EStateM.Result.ok.inj... ok
Checking: instBEqProd... ok
Checking: Nat.Linear.instBEqPolyCnstr.beq... ok
Checking: Nat.Linear.instBEqPolyCnstr.beq.eq_2... ok
Checking: iff_def... ok
Checking: imp.swap... ok
Checking: imp_not_comm... ok
Checking: Decidable.not_imp_symm... ok
Checking: Decidable.not_imp_comm... ok
Checking: Decidable.iff_not_comm... ok
Checking: instDecidableEqOfLawfulBEq.match_1... ok
Checking: List.isEqv.match_1... ok
Checking: List.isEqv... ok
Checking: List.isEqv_cons₂... ok
Checking: _private.Init.Data.List.Lemmas.0.List.mem_filterMap._simp_1_2... ok
Checking: List.mem_filterMap... ok
Checking: term_&&_... ok
Checking: Bind.bindLeft... ok
Checking: Seq.rec... ok
Checking: Seq.casesOn... ok
Checking: Quot.recOn... ok
Checking: eqRec_heq_iff... ok
Checking: Quot.hrecOn._proof_1... ok
Checking: Quot.hrecOn... ok
Checking: Quotient.hrecOn... ok
Checking: Lean.Meta.DSimp.Config.casesOn... ok
Checking: Lean.Meta.DSimp.Config.noConfusionType... ok
Checking: Lean.Meta.DSimp.Config.noConfusion... ok
Checking: Lean.Meta.DSimp.Config.mk.noConfusion... ok
Checking: Lean.Meta.DSimp.Config.mk.injEq... ok
Checking: term_∉_... ok
Checking: Complement... ok
Checking: Complement.mk... ok
Checking: Complement.rec... ok
Checking: Complement.casesOn... ok
Checking: Complement.noConfusionType... ok
Checking: Nat.Linear.instBEqPolyCnstr.beq.eq_def... ok
Checking: Lean.NameGenerator.namePrefix... ok
Checking: List.splitAt.go.eq_2... ok
Checking: Bool.and_self_right... ok
Checking: EST.Out.noConfusionType... ok
Checking: EST.Out.noConfusion... ok
Checking: EST.Out.error.noConfusion... ok
Checking: EST.Out.error.inj... ok
Checking: Nat.lt_add_one_iff... ok
Checking: List.reverseAux.eq_1... ok
Checking: bool.match_1... ok
Checking: ToBool.toBool... ok
Checking: bool... ok
Checking: Lean.Parser.Tactic.tacticExists_,,... ok
Checking: _private.Init.Data.List.Lemmas.0.List.partition.loop.match_1.splitter... ok
Checking: List.partition.loop.eq_def... ok
Checking: List.elem.eq_2... ok
Checking: OptionT.instMonad.eq_1... ok
Checking: Decidable.not_iff_comm... ok
Checking: decidable_of_iff... ok
Checking: Decidable.not_forall_not... ok
Checking: Classical.not_forall_not... ok
Checking: Std.Format.FlattenAllowability.noConfusionType... ok
Checking: Std.Format.FlattenAllowability.noConfusion... ok
Checking: Std.Format.FlattenAllowability.allow.noConfusion... ok
Checking: Lean.RArray._sizeOf_1... ok
Checking: Lean.RArray._sizeOf_inst... ok
Checking: Lean.RArray.branch.sizeOf_spec... ok
Checking: Bool.lt_trans... ok
Checking: Bool.lt_of_lt_of_le... ok
Checking: EST.Out.ok.noConfusion... ok
Checking: Option.map_if... ok
Checking: Option.guard_eq_map... ok
Checking: Lean.Parser.Tactic.clearValueHyp... ok
Checking: instLawfulIdentityOrFalse... ok
Checking: Bool.and_or_inj_right_iff... ok
Checking: MonadFunctorT.monadMap... ok
Checking: MonadFunctor.monadMap... ok
Checking: instMonadFunctorTOfMonadFunctor... ok
Checking: StateT.instMonadFunctor... ok
Checking: StateT.run_monadMap... ok
Checking: unexpandMkArray4... ok
Checking: Lean.Macro.Exception.ctorElimType... ok
Checking: Thunk.fnImpl... ok
Checking: Option.max_none_some... ok
Checking: Bool.and_or_inj_left_iff... ok
Checking: Lean.guardMsgsPositionsArg... ok
Checking: MProd.snd... ok
Checking: Array.findSomeM?.match_4... ok
Checking: MProd.fst... ok
Checking: Array.find?... ok
Checking: Option.guard_eq_filter... ok
Checking: Lean.Parser.Tactic.as_aux_lemma... ok
Checking: List.insert_append_of_mem_left... ok
Checking: Array.mkEmpty... ok
Checking: Array.mkEmpty_eq... ok
Checking: Option.isNone_iff_eq_none._simp_1... ok
Checking: Option.isNone_pbind_iff... ok
Checking: Lean.Parser.Tactic.exposeNames... ok
Checking: One... ok
Checking: One.mk... ok
Checking: One.rec... ok
Checking: One.casesOn... ok
Checking: One.noConfusionType... ok
Checking: One.noConfusion... ok
Checking: One.mk.noConfusion... ok
Checking: Sigma.ctorIdx... ok
Checking: Lean.hygieneInfoKind... ok
Checking: LawfulGetElem.rec... ok
Checking: LawfulGetElem.recOn... ok
Checking: ST.Out.state... ok
Checking: Nat.toUInt32... ok
Checking: instIdempotentOpBoolAnd... ok
Checking: Hashable... ok
Checking: Hashable.mk... ok
Checking: _private.Init.Prelude.0.Lean.Name.hash.match_1... ok
Checking: UInt64.ofNatLT... ok
Checking: _private.Init.Prelude.0.Lean.Name.hash._proof_1... ok
Checking: instInhabitedUInt64._proof_1... ok
Checking: instInhabitedUInt64... ok
Checking: mixHash... ok
Checking: String.hash... ok
Checking: _private.Init.Prelude.0.Lean.Name.hash._proof_2... ok
Checking: Lean.Name.hash... ok
Checking: Lean.instHashableName... ok
Checking: DoResultBC.continue.noConfusion... ok
Checking: DoResultBC.continue.injEq... ok
Checking: rawNatLit... ok
Checking: getElem?_eq_some_getElem_iff... ok
Checking: getElem?_eq_some_getElem_iff._simp_1... ok
Checking: List.getElem?_eq_some_getElem_iff... ok
Checking: Lean.Grind.ConfigInteractive.toConfig... ok
Checking: Task.spawn... ok
Checking: List.map_concat... ok
Checking: List.filterMapM.match_1... ok
Checking: OrOp... ok
Checking: OrOp.mk... ok
Checking: Fin.instOrOp... ok
Checking: Option.isSome_bind... ok
Checking: List.lengthTRAux.match_1... ok
Checking: List.lengthTRAux... ok
Checking: List.length_add_eq_lengthTRAux... ok
Checking: lt_of_lt_of_eq... ok
Checking: Lean.Grind.Config.etaStruct... ok
Checking: Lean.Macro.withFreshMacroScope... ok
Checking: Lean.Parser.Tactic.tacticRepeat_... ok
Checking: Option.beq_none... ok
Checking: Option.self_beq_filter... ok
Checking: LawfulFunctor.rec... ok
Checking: LawfulFunctor.recOn... ok
Checking: Fin.mk.sizeOf_spec... ok
Checking: Except.toBool.match_1... ok
Checking: Except.toBool... ok
Checking: SizeOf.rec... ok
Checking: SizeOf.casesOn... ok
Checking: SizeOf.noConfusionType... ok
Checking: SizeOf.noConfusion... ok
Checking: SizeOf.mk.noConfusion... ok
Checking: Lean.Meta.Rewrite.Config... ok
Checking: Lean.Meta.Rewrite.NewGoals... ok
Checking: Lean.Meta.Rewrite.Config.mk... ok
Checking: Lean.Meta.Rewrite.Config.newGoals... ok
Checking: Substring.Raw.Internal.extract... ok
Checking: List.erase... ok
Checking: exists_eq_left'... ok
Checking: exists_eq_left'._simp_1... ok
Checking: Option.bind_eq_some_iff... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.join_eq_some_iff._simp_1_2... ok
Checking: exists_eq_right... ok
Checking: exists_eq_right._simp_1... ok
Checking: Option.join_eq_some_iff... ok
Checking: HAdd.rec... ok
Checking: HAdd.casesOn... ok
Checking: Decidable.iff_iff_and_or_not_and_not... ok
Checking: Lean.Parser.Tactic.acRfl... ok
Checking: instLawfulIdentityBoolOrFalse... ok
Checking: List.lengthTR... ok
Checking: List.lengthTR.eq_1... ok
Checking: instReprAtomNat... ok
Checking: Except.map.match_1... ok
Checking: Except.mapError... ok
Checking: emptyWf._proof_1... ok
Checking: emptyWf... ok
Checking: List.concat_append... ok
Checking: boolToProp... ok
Checking: HShiftRight.ctorIdx... ok
Checking: Quot.recOnSubsingleton._proof_1... ok
Checking: Quot.recOnSubsingleton... ok
Checking: proof_irrel... ok
Checking: instSubsingleton... ok
Checking: Quotient.recOnSubsingleton₂._proof_1... ok
Checking: Quotient.recOnSubsingleton₂... ok
Checking: Quotient.decidableEq._proof_1... ok
Checking: Quotient.decidableEq.match_1... ok
Checking: Quotient.liftOn₂... ok
Checking: Equivalence.trans... ok
Checking: Setoid.trans... ok
Checking: _private.Init.Core.0.Quotient.rel._proof_1... ok
Checking: _private.Init.Core.0.Quotient.rel... ok
Checking: Quotient.inductionOn... ok
Checking: _private.Init.Core.0.Quotient.rel.refl... ok
Checking: _private.Init.Core.0.Quotient.rel_of_eq... ok
Checking: Quotient.exact... ok
Checking: Quotient.decidableEq._proof_2... ok
Checking: Quotient.decidableEq... ok
Checking: Lean.Name.modifyBase... ok
Checking: Lean.Name.appendAfter... ok
Checking: _private.Init.Data.NeZero.0.instNeZeroNatHAdd.match_1... ok
Checking: _private.Init.Data.NeZero.0.instNeZeroNatHAdd.match_3... ok
Checking: instNeZeroNatHAdd... ok
Checking: List.lookup.match_1... ok
Checking: type_eq_of_heq... ok
Checking: Array.allM... ok
Checking: Lean.Parser.Tactic.dsimpArg... ok
Checking: Lean.Parser.Tactic.dsimpArgs... ok
Checking: Int._sizeOf_1... ok
Checking: Int._sizeOf_inst... ok
Checking: Int.ofNat.sizeOf_spec... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.isSome_filter.match_1_3... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.isSome_filter.match_1_1... ok
Checking: Option.isSome_filter... ok
Checking: Fin.instGetElemFinVal... ok
Checking: Fin.instGetElem?FinVal... ok
Checking: Fin.instLawfulGetElemValOfNat... ok
Checking: CoeHead... ok
Checking: CoeHead.mk... ok
Checking: CoeHead.rec... ok
Checking: CoeHead.recOn... ok
Checking: UInt16.decEq.match_1... ok
Checking: Classical.decidable_of_decidable_not.match_1... ok
Checking: List.isSome_head?... ok
Checking: List.getLast?_isSome... ok
Checking: Lean.Parser.Tactic.mreplaceMacro... ok
Checking: ExceptT.bind.eq_1... ok
Checking: instMaxUInt32... ok
Checking: Lean.Syntax.isAtom... ok
Checking: Bool.or_and_distrib_left... ok
Checking: _private.Init.Data.List.Lemmas.0.List.get_mem.match_1_1... ok
Checking: List.get_mem... ok
Checking: Inhabited.noConfusionType... ok
Checking: Inhabited.noConfusion... ok
Checking: ForInStep.ctorElimType... ok
Checking: ForInStep.ctorElim... ok
Checking: ForInStep.done.elim... ok
Checking: heq_eqRec_iff... ok
Checking: Std.Format.align.noConfusion... ok
Checking: Std.Format.align.injEq... ok
Checking: modifyGetThe... ok
Checking: MonadEval.rec... ok
Checking: List.mem_flatten._simp_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.mem_map.match_1_1... ok
Checking: List.mem_map... ok
Checking: List.mem_map._simp_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.mem_flatMap.match_1_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.mem_flatMap.match_1_3... ok
Checking: List.mem_flatMap... ok
Checking: List.mem_flatMap_of_mem... ok
Checking: List.filterMap_append... ok
Checking: List.filterMap_flatten... ok
Checking: Nat.div.inductionOn._unary.eq_def... ok
Checking: Nat.div.inductionOn.eq_def... ok
Checking: Zero.recOn... ok
Checking: Nat.succ.noConfusion... ok
Checking: Singleton... ok
Checking: Singleton.mk... ok
Checking: Lean.Parser.Tactic.Grind.renameI... ok
Checking: Lean.Meta.ApplyNewGoals.nonDependentOnly.sizeOf_spec... ok
Checking: Neg.casesOn... ok
Checking: Neg.noConfusionType... ok
Checking: Neg.noConfusion... ok
Checking: Neg.mk.noConfusion... ok
Checking: Lean.Meta.Simp.Config.arith... ok
Checking: _private.Init.Data.Repr.0.Prod.reprTuple.match_1... ok
Checking: ReprTuple.reprTuple... ok
Checking: Prod.reprTuple... ok
Checking: List.filter_eq_self... ok
Checking: List.filter_eq_self._simp_1... ok
Checking: List.removeAll_nil... ok
Checking: Lean.Parser.checkTacticFailure... ok
Checking: dite_else_true... ok
Checking: _private.Init.Data.Array.Basic.0.Array.takeWhile.go._unary._proof_1... ok
Checking: _private.Init.Data.Array.Basic.0.Array.takeWhile.go._unary._proof_2... ok
Checking: _private.Init.Data.Array.Basic.0.Array.takeWhile.go._unary... ok
Checking: _private.Init.Data.Array.Basic.0.Array.takeWhile.go... ok
Checking: Array.takeWhile... ok
Checking: Lean.Parser.Tactic.Grind.mbtc... ok
Checking: DoResultBC.continue.inj... ok
Checking: Lean.Parser.Tactic.Conv.argArg... ok
Checking: ToBool.recOn... ok
Checking: term_%_... ok
Checking: instToStringExcept.match_1... ok
Checking: instToStringExcept... ok
Checking: ReaderT.tryFinally... ok
Checking: Lean.Parser.Tactic.Grind.grindRepeat_... ok
Checking: Std.Refl... ok
Checking: Std.Refl.mk... ok
Checking: Std.Refl.rec... ok
Checking: Std.Refl.recOn... ok
Checking: ShiftLeft.casesOn... ok
Checking: Option.wellFounded_lt... ok
Checking: LE.rec... ok
Checking: LE.casesOn... ok
Checking: LE.noConfusionType... ok
Checking: LE.noConfusion... ok
Checking: LE.mk.noConfusion... ok
Checking: Lean.mkAtomFrom... ok
Checking: not_iff_false_intro... ok
Checking: Array.mkArray6... ok
Checking: Lean.Syntax.node6... ok
Checking: Lean.Parser.Tactic.Grind.haveSilent... ok
Checking: Lean.Parser.Tactic.Conv.congr... ok
Checking: sorryAx... ok
Checking: Lean.Meta.ExtractLetsConfig.usedOnly... ok
Checking: Option.or_eq_orElse... ok
Checking: ExceptT.finally._sparseCasesOn_1... ok
Checking: ExceptT.finally._sparseCasesOn_2... ok
Checking: ExceptT.finally.match_1... ok
Checking: ExceptT.finally._sparseCasesOn_5... ok
Checking: ExceptT.finally.match_5... ok
Checking: ExceptT.finally... ok
Checking: List.filterMap_eq_map... ok
Checking: _private.Init.Data.List.Lemmas.0.List.map_filterMap._simp_1_1... ok
Checking: List.filterMap_filterMap... ok
Checking: Option.map_eq_bind... ok
Checking: List.map_filterMap... ok
Checking: Nat.lt_succ... ok
Checking: Lean.TSyntax.instCoeConsSyntaxNodeKindNil... ok
Checking: ByteArray.recOn... ok
Checking: HSMul... ok
Checking: HSMul.mk... ok
Checking: HSMul.rec... ok
Checking: List.IsSuffix... ok
Checking: ToString.rec... ok
Checking: ToString.casesOn... ok
Checking: ToString.noConfusionType... ok
Checking: ToString.noConfusion... ok
Checking: ReaderT.run... ok
Checking: Except.ok.injEq... ok
Checking: Lean.binderPred≥_... ok
Checking: Lean.TSyntax.instCoeIdentTerm... ok
Checking: term_<|_... ok
Checking: Lean.Meta.Simp.Config.contextual... ok
Checking: List.getElem_append_right'._proof_1... ok
Checking: List.getElem_append_right'... ok
Checking: Lean.Grind.Config.mk.inj... ok
Checking: HOr.casesOn... ok
Checking: HOr.noConfusionType... ok
Checking: HOr.noConfusion... ok
Checking: HOr.mk.noConfusion... ok
Checking: MonadLiftT.recOn... ok
Checking: Lean.Parser.Category.grind_filter... ok
Checking: _private.Init.Meta.Defs.0.Lean.mkSepArray.match_1... ok
Checking: Lean.mkSepArray... ok
Checking: Lean.Syntax.SepArray.ofElems... ok
Checking: Sum._sizeOf_1... ok
Checking: Sum._sizeOf_inst... ok
Checking: Sum.inr.sizeOf_spec... ok
Checking: MonadEvalT.rec... ok
Checking: MonadEvalT.casesOn... ok
Checking: MonadEvalT.noConfusionType... ok
Checking: MonadEvalT.noConfusion... ok
Checking: MonadEvalT.mk.noConfusion... ok
Checking: Quotient.liftOn... ok
Checking: Lean.Meta.Simp.Config.noConfusionType... ok
Checking: Lean.Meta.Simp.Config.noConfusion... ok
Checking: Lean.instQuoteProdMkStr1.match_1... ok
Checking: Lean.Syntax.NameLit... ok
Checking: Classical.or_iff_not_imp_left... ok
Checking: _private.Init.Data.List.Lemmas.0.List.mem_of_head?.match_1_1... ok
Checking: List.mem_of_head?... ok
Checking: Option.some_inj... ok
Checking: List.head_of_head?_eq_some... ok
Checking: List.instAssociativeHAppend... ok
Checking: Lean.Parser.Tactic.pushCast... ok
Checking: ite_eq_ite... ok
Checking: Lean.MonadNameGenerator.rec... ok
Checking: Lean.MonadNameGenerator.casesOn... ok
Checking: Std.Identity.toRightIdentity... ok
Checking: List.beq.eq_1... ok
Checking: List.Subset... ok
Checking: ByteArray.mk.inj... ok
Checking: Option.instOrElse... ok
Checking: HShiftLeft... ok
Checking: HShiftLeft.mk... ok
Checking: HShiftLeft.hShiftLeft... ok
Checking: ShiftLeft.shiftLeft... ok
Checking: instHShiftLeftOfShiftLeft... ok
Checking: Nat.instShiftLeft... ok
Checking: Fin.shiftLeft._proof_1... ok
Checking: Fin.shiftLeft... ok
Checking: Bool.cond_eq_ite_iff... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.pfilter_eq_filter._simp_1_7... ok
Checking: Option.pfilter_eq_filter... ok
Checking: Singleton.singleton... ok
Checking: Complement.complement... ok
Checking: Nat.Linear.Expr.var.noConfusion... ok
Checking: Nat.Linear.Expr.var.injEq... ok
Checking: List.length_singleton... FAIL
Checking: NonScalar.ctorIdx... ok
Checking: Bool.and'... ok
Checking: Bool.and'_eq_and... ok
Checking: term!_... ok
Checking: Option.instDecidableEq.decEq._proof_1... ok
Checking: Option.instDecidableEq.decEq._proof_3... ok
Checking: Option.instDecidableEq.decEq._proof_4... ok
Checking: Option.instDecidableEq.decEq._proof_2... ok
Checking: Option.instDecidableEq.decEq._proof_5... ok
Checking: Option.instDecidableEq.decEq... ok
Checking: Option.instDecidableEq... ok
Checking: Option.instDecidableMemOfDecidableEq... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.join_filter.match_1_1... ok
Checking: Option.join_filter... ok
Checking: Bool.not_ite_eq_true_eq_true... ok
Checking: List.foldr_filterMap... ok
Checking: Lean.Meta.instInhabitedOccurrences.default... ok
Checking: Lean.Meta.instInhabitedOccurrences... ok
Checking: PSigma.Lex.rec... ok
Checking: PSigma.Lex.casesOn... ok
Checking: String.Pos.Raw.byteIdx... ok
Checking: Nat.lt_or_eq_of_le... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.le_iff_lt_or_eq.match_1_1... ok
Checking: Nat.le_iff_lt_or_eq... ok
Checking: Option.min_eq_some_iff... ok
Checking: Lean.Parser.Tactic.anchor... ok
Checking: Lean.Parser.Tactic.Grind.grind_ref_... ok
Checking: HasEquiv.rec... ok
Checking: HasEquiv.recOn... ok
Checking: List.flatten_eq_flatMap... ok
Checking: Lean.Syntax.Preresolved.ctorIdx... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.instBEqPreresolved.beq._sparseCasesOn_1... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.instBEqPreresolved.beq._sparseCasesOn_2... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.instBEqPreresolved.beq.match_1... ok
Checking: Lean.Syntax.instBEqPreresolved.beq... ok
Checking: Lean.Syntax.instBEqPreresolved... ok
Checking: Decidable.noConfusionType... ok
Checking: Decidable.noConfusion... ok
Checking: Decidable.isFalse.noConfusion... ok
Checking: Subtype.recOn... ok
Checking: Bool.eq_false_of_le_false... ok
Checking: Lean.Syntax.brecOn.go... ok
Checking: Prod.Lex.instDecidableRelOfDecidableEq.match_1... ok
Checking: PULift.recOn... ok
Checking: Lean.Name.append.match_1... ok
Checking: Lean.Name.append... ok
Checking: Lean.instAppendName... ok
Checking: termIfLet... ok
Checking: not_eq_of_beq_eq_false... ok
Checking: ne_of_beq_false... ok
Checking: PNonScalar.noConfusion... ok
Checking: PNonScalar.mk.noConfusion... ok
Checking: PNonScalar.mk.injEq... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.any_filter.match_1_3... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.any_filter.match_1_1... ok
Checking: Option.any_filter... ok
Checking: Lean.Meta.LiftLetsConfig... ok
Checking: Lean.Meta.LiftLetsConfig.mk... ok
Checking: Lean.Meta.LiftLetsConfig.rec... ok
Checking: Lean.Parser.Tactic.mspecializeMacro... ok
Checking: dite_else_false... ok
Checking: _private.Init.Data.Array.Basic.0.List.mem_toArray._simp_1_1... ok
Checking: List.mem_toArray... ok
Checking: Lean.Loop.ctorIdx... ok
Checking: CoeOut.coe... ok
Checking: instCoeOTCOfCoeOut... ok
Checking: Nat.sub.elim... ok
Checking: Lean.Parser.Tactic.Conv.simpMatch... ok
Checking: List.getElem_set_ne._proof_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getElem_set_ne.match_1_1... ok
Checking: List.getElem_set_ne... ok
Checking: List.getElem?_eq_none... ok
Checking: List.getElem?_set_ne... ok
Checking: Lean.TSyntaxArray.mk... ok
Checking: _private.Init.Data.Array.Basic.0.Array.getEvenElems.match_1... ok
Checking: Array.getEvenElems... ok
Checking: Array.getSepElems... ok
Checking: Lean.Syntax.TSepArray.elemsAndSeps... ok
Checking: Lean.Syntax.TSepArray.getElems... ok
Checking: Lean.Syntax.instCoeOutTSepArrayTSyntaxArray... ok
Checking: List.flatten_flatten... ok
Checking: false_eq_decide_iff... ok
Checking: ToBool.noConfusion... ok
Checking: Nat.sub_one_lt_of_lt... ok
Checking: MonadFunctor.recOn... ok
Checking: PLift.down... ok
Checking: Lean.Meta.Occurrences.neg.sizeOf_spec... ok
Checking: UInt8.lt... ok
Checking: instLTUInt8... ok
Checking: UInt8.decLt... ok
Checking: Subsingleton.rec... ok
Checking: Subsingleton.casesOn... ok
Checking: DoResultPRBC.continue.inj... ok
Checking: List.get_cons_succ... TIMEOUT
Checking: Array.instEmptyCollection... ok
Checking: Lean.Syntax.instEmptyCollectionTSepArray... ok
Checking: List.tail... ok
Checking: _private.Init.Data.List.Lemmas.0.List.tail?_append_of_ne_nil.match_1_1... ok
Checking: List.tail?_append_of_ne_nil... ok
Checking: instLawfulBEqString... ok
Checking: Lean.Name.noConfusion... ok
Checking: Lean.Name.str.noConfusion... ok
Checking: Lean.Name.str.injEq... ok
Checking: _private.Init.Meta.Defs.0.Lean.Name.beq_iff_eq._simp_1_6... ok
Checking: Lean.Name.num.noConfusion... ok
Checking: Lean.Name.num.injEq... ok
Checking: Lean.Name.beq_iff_eq... ok
Checking: _private.Init.Data.Nat.Linear.0.Nat.Linear.Poly.cancelAux.match_3.splitter... ok
Checking: Nat.Linear.Poly.cancelAux.eq_def... ok
Checking: Lean.version.getIsRelease... ok
Checking: Lean.version.isRelease... ok
Checking: Bool.not_inj_iff... ok
Checking: Lean.Syntax.Prio... ok
Checking: Prod.instReflBEq... ok
Checking: Option.left_le_of_merge_le... ok
Checking: List.getLast!_eq_getLast?_getD... ok
Checking: right_eq_dite_iff... ok
Checking: Bool.ctorElimType... ok
Checking: Bool.ctorElim... ok
Checking: Bool.cond_prop... ok
Checking: Std.Antisymm... ok
Checking: Std.Antisymm.mk... ok
Checking: List.le... ok
Checking: List.instLE... ok
Checking: _private.Init.Data.List.BasicAux.0.List.not_lex_antisymm.match_1_1... ok
Checking: List.not_lex_antisymm... ok
Checking: Std.Antisymm.antisymm... ok
Checking: List.le_antisymm... ok
Checking: Inter.inter... ok
Checking: Nat.and_forall_add_one... ok
Checking: Lean.Parser.Tactic.SolveByElim.star... ok
Checking: Lean.Parser.Tactic.SolveByElim.erase... ok
Checking: Lean.Parser.Tactic.SolveByElim.arg... ok
Checking: Lean.Parser.Tactic.SolveByElim.args... ok
Checking: Lean.Parser.Tactic.SolveByElim.using_... ok
Checking: Lean.Parser.Tactic.applyRules... ok
Checking: Array.foldrM.fold... ok
Checking: Array.foldrM... ok
Checking: Array.foldr... ok
Checking: Array.sum... ok
Checking: Lean.Macro.Context.ctorIdx... ok
Checking: Fin.toNat... ok
Checking: Fin.toNat_eq_val... ok
Checking: List.any_cons... ok
Checking: Lean.Macro.State.rec... ok
Checking: List.nil.sizeOf_spec... ok
Checking: UInt16.size... ok
Checking: HPow.casesOn... ok
Checking: HPow.noConfusionType... ok
Checking: HPow.noConfusion... ok
Checking: Nat.Linear.ExprCnstr.toPoly... ok
Checking: Nat.Linear.ExprCnstr.toPoly.eq_1... ok
Checking: Lean.Parser.Tactic.elimTarget... ok
Checking: Lean.Parser.Tactic.Grind.grind_filter(_)... ok
Checking: LT.noConfusion... ok
Checking: LT.mk.noConfusion... ok
Checking: Lean.Name.mkStr7... ok
Checking: Bool.eq_false_iff... ok
Checking: BEq.neq_of_neq_of_beq... ok
Checking: _auto._@.Init.Data.Array.Basic.350506914._hygCtx._hyg.7... ok
Checking: Array.swapAt... ok
Checking: Bool.cond_false_left... ok
Checking: Lean.Parser.Tactic.tacticNorm_cast__... ok
Checking: CoeTail.noConfusionType... ok
Checking: CoeTail.noConfusion... ok
Checking: List.head?_singleton... ok
Checking: Bool.toNat_le... ok
Checking: Bool.eq_not_self_and... ok
Checking: Option.ctorElimType... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.some_get!.match_1_1... ok
Checking: Option.some_get!... ok
Checking: Classical.strongIndefiniteDescription._proof_1... ok
Checking: Classical.strongIndefiniteDescription._proof_2... ok
Checking: Classical.strongIndefiniteDescription... ok
Checking: Classical.epsilon... ok
Checking: _private.Init.PropLemmas.0.Exists.nonempty.match_1_1... ok
Checking: Exists.nonempty... ok
Checking: Classical.epsilon_spec_aux... ok
Checking: Classical.epsilon_spec... ok
Checking: Classical.epsilon_singleton... ok
Checking: Bool.toNat_true... ok
Checking: List.getElem?_concat_length... ok
Checking: Except._sizeOf_1... ok
Checking: Except._sizeOf_inst... ok
Checking: Except.ok.sizeOf_spec... ok
Checking: _private.Init.Data.List.Lemmas.0.List.map_eq_replicate_iff._simp_1_1... ok
Checking: forall_exists_index._simp_1... ok
Checking: forall_apply_eq_imp_iff₂... ok
Checking: forall_apply_eq_imp_iff₂._simp_1... ok
Checking: List.map_eq_replicate_iff... ok
Checking: List.map_const... ok
Checking: _private.Init.Data.List.Lemmas.0.List.head_mem_head?.match_1_1... ok
Checking: List.head_mem_head?... ok
Checking: Bind.kleisliRight... ok
Checking: Prod._sizeOf_1... ok
Checking: Prod._sizeOf_inst... ok
Checking: Prod.mk.sizeOf_spec... ok
Checking: List.isEqv.eq_1... ok
Checking: Lean.Parser.Tactic.Conv.paren... ok
Checking: Nat.add_mul... ok
Checking: Classical.decidableInhabited... ok
Checking: Lean.Macro.Methods.resolveGlobalName... ok
Checking: coeSortNotation... ok
Checking: ULift.rec... ok
Checking: ULift.casesOn... ok
Checking: ULift.noConfusionType... ok
Checking: Option.join_eq_get... ok
Checking: Bool.not_xor... TIMEOUT
Checking: Lean.Macro.instInhabitedMethods.default... ok
Checking: Lean.Macro.instInhabitedMethods... ok
Checking: Lean.Macro.getMethods... ok
Checking: Lean.Macro.resolveGlobalName... ok
Checking: PSum.inl.noConfusion... ok
Checking: PSum.inl.injEq... ok
Checking: Lean.scientificLitKind... ok
Checking: term_++_... ok
Checking: Lean.Grind.GrobnerConfig.casesOn... ok
Checking: Lean.Grind.GrobnerConfig.noConfusionType... ok
Checking: Lean.Grind.GrobnerConfig.noConfusion... ok
Checking: Lean.Grind.GrobnerConfig.mk.noConfusion... ok
Checking: Lean.Grind.GrobnerConfig.mk.injEq... ok
Checking: CoeTC.rec... ok
Checking: CoeTC.casesOn... ok
Checking: CoeTC.noConfusionType... ok
Checking: CoeTC.noConfusion... ok
Checking: CoeTC.mk.noConfusion... ok
Checking: Nat.Linear.Poly.isNum?.match_1... ok
Checking: Array.modifyM... ok
Checking: Array.modify... ok
Checking: Lean.RArray.noConfusionType... ok
Checking: Lean.RArray.noConfusion... ok
Checking: Lean.RArray.branch.noConfusion... ok
Checking: Lean.RArray.branch.inj... ok
Checking: Nat.pred_lt_of_lt... ok
Checking: Nat.Linear.Poly.norm.go.eq_1... ok
Checking: Classical.not_not... ok
Checking: Classical.decidable_of_decidable_not._proof_1... ok
Checking: Classical.decidable_of_decidable_not... ok
Checking: Classical.dite_not... ok
Checking: List.range'_succ... FAIL
Checking: Bool.eq_true_or_eq_false_self... ok
Checking: Lean.Parser.Tactic.grindLemmaMin... ok
Checking: Lean.Parser.Tactic.Grind.thm... ok
Checking: Lean.Parser.Tactic.Grind.use... ok
Checking: ExceptCpsT.instMonadLiftOfMonad... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getElem!_of_getElem?.match_1_1... ok
Checking: getElem!_pos... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getElem!_eq_getElem?_getD.match_1_2... ok
Checking: List.getElem!_eq_getElem?_getD... ok
Checking: List.getElem!_of_getElem?... ok
Checking: _private.Init.Meta.Defs.0.Lean.version.getMajor... ok
Checking: Lean.version.major... ok
Checking: Except.isOk... ok
Checking: Lean.Meta.Simp.Config.suggestions... ok
Checking: StateRefT'.instMonad... ok
Checking: ReaderT.ext... ok
Checking: LawfulFunctor.map_const... ok
Checking: ReaderT.instLawfulFunctor... ok
Checking: LawfulApplicative.seqRight_eq... ok
Checking: LawfulApplicative.pure_seq... ok
Checking: LawfulApplicative.seq_pure... ok
Checking: LawfulApplicative.seq_assoc... ok
Checking: ReaderT.instLawfulApplicative... ok
Checking: ReaderT.instLawfulMonad... ok
Checking: instLawfulMonadStateRefT'... ok
Checking: Lean.Syntax.setKind... ok
Checking: NatCast.rec... ok
Checking: NatCast.casesOn... ok
Checking: NatCast.noConfusionType... ok
Checking: NatCast.noConfusion... ok
Checking: Hashable.rec... ok
Checking: Hashable.casesOn... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.isInterpolatedStrLit?.match_1... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.decodeInterpStrLit.loop... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.decodeInterpStrLit... ok
Checking: Lean.Syntax.isInterpolatedStrLit?... ok
Checking: Lean.Parser.Tactic.Grind.grindTry_... ok
Checking: Acc.below.rec... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.merge_eq_or_eq.match_1_1... ok
Checking: Option.merge_eq_or_eq... ok
Checking: Lean.Meta.Simp.NormCastConfig.recOn... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.lt.match_1.eq_3... ok
Checking: Option.lt.eq_3... ok
Checking: MonadReaderOf.rec... ok
Checking: MonadReaderOf.casesOn... ok
Checking: Fin.ne_of_val_ne... ok
Checking: _private.Init.System.ST.0.ST.Prim.mkRef._proof_1... ok
Checking: ST.Prim.mkRef... ok
Checking: ST.mkRef... ok
Checking: ST.Ref.get... ok
Checking: StateRefT'.run... ok
Checking: Nat.le_add_right_of_le... ok
Checking: Append.rec... ok
Checking: Append.casesOn... ok
Checking: Append.noConfusionType... ok
Checking: List.id_run_foldrM... FAIL
Checking: ExceptT.mk.eq_1... ok
Checking: Sum.inl.sizeOf_spec... ok
Checking: ite_self... ok
Checking: _private.Init.PropLemmas.0.not_forall_of_exists_not.match_1_1... ok
Checking: not_forall_of_exists_not... ok
Checking: Decidable.not_forall... ok
Checking: Classical.not_forall... ok
Checking: Classical.not_forall._simp_1... ok
Checking: Classical.not_not._simp_1... ok
Checking: exists_or_eq_left... ok
Checking: exists_or_eq_left._simp_1... ok
Checking: List.eq_nil_iff_forall_not_mem... ok
Checking: _private.Init.Data.List.Lemmas.0.List.filter_eq_nil_iff._simp_1_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.filter_eq_nil_iff._simp_1_2... ok
Checking: List.filter_eq_nil_iff... ok
Checking: List.filter_eq_nil_iff._simp_1... ok
Checking: List.filter_replicate... ok
Checking: Option.mem_some_self... ok
Checking: WellFoundedRelation.casesOn... ok
Checking: WellFoundedRelation.noConfusionType... ok
Checking: WellFoundedRelation.noConfusion... ok
Checking: HasSSubset.SSubset... ok
Checking: SSuperset... ok
Checking: Lean.guardMsgsFilterAction... ok
Checking: Lean.guardMsgsFilterSeverity... ok
Checking: Lean.guardMsgsFilter... ok
Checking: Lean.guardMsgsWhitespaceArg... ok
Checking: Lean.guardMsgsWhitespace... ok
Checking: Lean.guardMsgsOrderingArg... ok
Checking: Lean.guardMsgsOrdering... ok
Checking: Lean.guardMsgsPositions... ok
Checking: Lean.guardMsgsSpecElt... ok
Checking: Lean.guardMsgsSpec... ok
Checking: CoeHead.ctorIdx... ok
Checking: And.recOn... ok
Checking: List.drop.eq_1... ok
Checking: _private.Init.Data.Array.Basic.0.Array.findIdxM?.match_1... ok
Checking: Array.findIdxM?... ok
Checking: List.head_filterMap_of_eq_some... ok
Checking: Lean.binderPred⊃_... ok
Checking: HShiftRight.rec... ok
Checking: HShiftRight.casesOn... ok
Checking: HSub.rec... ok
Checking: HSub.recOn... ok
Checking: and_self_iff... ok
Checking: Array.filterMapM.match_1... ok
Checking: Array.filterMapM... ok
Checking: Array.filterMap... ok
Checking: dbgTrace... ok
Checking: dbgTraceVal... ok
Checking: Except.bind... ok
Checking: Except.bind.eq_2... ok
Checking: PSum._sizeOf_1... ok
Checking: PSum._sizeOf_inst... ok
Checking: PSum.inl.sizeOf_spec... ok
Checking: Nat.Linear.PolyCnstr.noConfusionType... ok
Checking: CoeHead.casesOn... ok
Checking: CoeHead.noConfusionType... ok
Checking: CoeHead.noConfusion... ok
Checking: CoeHead.mk.noConfusion... ok
Checking: USize.rec... ok
Checking: USize.casesOn... ok
Checking: USize.noConfusionType... ok
Checking: USize.noConfusion... ok
Checking: USize.ofBitVec.noConfusion... ok
Checking: Lean.Syntax.Level... ok
Checking: List.elem.eq_def... ok
Checking: ExceptT.bind_pure_comp... FAIL
Checking: Except.map... ok
Checking: _private.Init.Control.Lawful.Instances.0.ExceptT.run_map._simp_1_2... ok
Checking: ExceptT.run_map... ok
Checking: _private.Init.Control.Lawful.Instances.0.ExceptT.seqLeft_eq.match_1_2... ok
Checking: _private.Init.Control.Lawful.Instances.0.ExceptT.seqLeft_eq._simp_1_4... ok
Checking: ExceptT.seqLeft_eq... ok
Checking: Lean.Module.ctorIdx... ok
Checking: Lean.Parser.Tactic.tacticSimp?!_... ok
Checking: Option.toArray... ok
Checking: Option.decidableForallMem.match_1... ok
Checking: Std.Format.FlattenBehavior._sizeOf_1... ok
Checking: Std.Format.FlattenBehavior._sizeOf_inst... ok
Checking: Std.Format._sizeOf_1... ok
Checking: Std.Format._sizeOf_inst... ok
Checking: Std.Format.line.sizeOf_spec... ok
Checking: Lean.term∃__,_... ok
Checking: List.lookup... ok
Checking: List.lookup_cons... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.not_add_one_le_zero.match_1_1... ok
Checking: Nat.not_add_one_le_zero... ok
Checking: Lean.Parser.Tactic.Grind.showFalse... ok
Checking: Repr.ctorIdx... ok
Checking: STWorld.rec... ok
Checking: STWorld.casesOn... ok
Checking: List.exists_of_mem_flatMap... ok
Checking: Nat.Linear.Poly.isNonZero.eq_1... ok
Checking: HSub.casesOn... ok
Checking: HSub.noConfusionType... ok
Checking: ST.Ref.modify... ok
Checking: List.insert_replicate_self... ok
Checking: Lean.SourceInfo.getTailPos?... ok
Checking: Lean.Parser.Category.prio... ok
Checking: List.all_bne... ok
Checking: StateT.lift... ok
Checking: StateT.instMonadExceptOf... ok
Checking: _private.Init.Data.Repr.0.Decidable.repr.match_1... ok
Checking: Decidable.repr... ok
Checking: instReprDecidable... ok
Checking: List.reverse_eq_append_iff... ok
Checking: Lean.Parser.Tactic.Grind.failIfSuccess... ok
Checking: mkPanicMessage... ok
Checking: Option.map_eq_some_iff... ok
Checking: Lean.Parser.Tactic.mexactMacro... ok
Checking: List.getElem?_insert_zero... ok
Checking: CoeHTC.rec... ok
Checking: CoeHTC.casesOn... ok
Checking: CoeHTC.noConfusionType... ok
Checking: List.foldr.eq_1... ok
Checking: binderNameHint... ok
Checking: forIn_eq_forIn'... FAIL
Checking: Sep.rec... ok
Checking: Sep.recOn... ok
Checking: CoeT.rec... ok
Checking: CoeT.casesOn... ok
Checking: CoeT.noConfusionType... ok
Checking: CoeT.noConfusion... ok
Checking: Lean.Attr.coe... ok
Checking: decide_eq_false_iff_not... ok
Checking: Relation.TransGen.recOn... ok
Checking: heq_of_heq_of_eq... ok
Checking: Lean.Grind.Config.useSorry... ok
Checking: Sep.casesOn... ok
Checking: Sep.noConfusionType... ok
Checking: Sep.noConfusion... ok
Checking: Sep.mk.noConfusion... ok
Checking: liftM_seq... ok
Checking: Lean.Grind.CutsatConfig.noConfusionType... ok
Checking: Lean.Grind.CutsatConfig.noConfusion... ok
Checking: term_⊕_... ok
Checking: Nat.sub_one_add_one... ok
Checking: StateCpsT.runK_bind_modify... ok
Checking: and_congr_right_eq... ok
Checking: Array.countP... ok
Checking: Array.count... ok
Checking: Sub.rec... ok
Checking: Sub.casesOn... ok
Checking: Sub.noConfusionType... ok
Checking: Sub.noConfusion... ok
Checking: Dvd.rec... ok
Checking: Dvd.recOn... ok
Checking: Array.mkArray4... ok
Checking: Lean.Syntax.node4... ok
Checking: unexpandGetElem... ok
Checking: notM... ok
Checking: Task.rec... ok
Checking: Task.casesOn... ok
Checking: Task.noConfusionType... ok
Checking: Task.noConfusion... ok
Checking: Lean.Parser.Tactic.tacticNext_=>_... ok
Checking: or_congr... ok
Checking: or_congr_left... ok
Checking: Option.guard_eq_ite... ok
Checking: List.contains_iff... ok
Checking: instInhabitedRaw... ok
Checking: String.Internal.next... ok
Checking: Char.le... ok
Checking: Char.instLE... ok
Checking: Char.instDecidableLe... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.decodeHexDigit... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.decodeQuotedChar.match_1... ok
Checking: Lean.Syntax.decodeQuotedChar... ok
Checking: MonadExcept.noConfusionType... ok
Checking: MonadExcept.noConfusion... ok
Checking: MonadExcept.mk.noConfusion... ok
Checking: Lean.NameGenerator.noConfusionType... ok
Checking: iff_of_eq... ok
Checking: Lean.Grind.ConfigInteractive.casesOn... ok
Checking: Lean.Grind.ConfigInteractive.noConfusionType... ok
Checking: Lean.Grind.ConfigInteractive.noConfusion... ok
Checking: Lean.Grind.ConfigInteractive.mk.noConfusion... ok
Checking: Lean.Grind.ConfigInteractive.mk.inj... ok
Checking: Lean.charLitKind... ok
Checking: Subsingleton.helim... ok
Checking: Lean.Macro.State.recOn... ok
Checking: Nat.mul_sub_left_distrib... ok
Checking: Lean.Grind.Config.splitMatch... ok
Checking: Mul.ctorIdx... ok
Checking: List.sum_append_nat... ok
Checking: Std.Format.MonadPrettyFormat.rec... ok
Checking: Std.Format.MonadPrettyFormat.casesOn... ok
Checking: Std.Format.MonadPrettyFormat.noConfusionType... ok
Checking: Std.Format.MonadPrettyFormat.noConfusion... ok
Checking: liftM_pure... ok
Checking: LawfulMonadLift.monadLift_bind... ok
Checking: instLawfulMonadLiftTOfLawfulMonadLift... ok
Checking: Bool.not_beq_to_not_eq... ok
Checking: Lean.Meta.Simp.ConfigCtx.recOn... ok
Checking: _private.Init.Data.Array.Basic.0.Array.isEqvAux.match_1... ok
Checking: _private.Init.Data.Array.Basic.0.Array.isEqvAux._proof_1... ok
Checking: _private.Init.Data.Array.Basic.0.Array.isEqvAux._proof_2... ok
Checking: Array.isEqvAux... ok
Checking: _private.Init.Data.Array.Basic.0.Array.isEqv._proof_1... ok
Checking: Array.isEqv... ok
Checking: List.ne_of_not_mem_cons... ok
Checking: List.ne_and_not_mem_of_not_mem_cons... ok
Checking: Std.Format.defWidth... ok
Checking: _private.Init.Data.Format.Basic.0.Std.Format.State... ok
Checking: _private.Init.Data.Format.Basic.0.Std.Format.State.mk... ok
Checking: _private.Init.Data.Format.Basic.0.Std.Format.WorkGroup... ok
Checking: _private.Init.Data.Format.Basic.0.Std.Format.WorkItem... ok
Checking: _private.Init.Data.Format.Basic.0.Std.Format.WorkItem.mk... ok
Checking: _private.Init.Data.Format.Basic.0.Std.Format.WorkGroup.mk... ok
Checking: _private.Init.Data.Format.Basic.0.Std.Format.be... ok
Checking: Std.Format.prettyM... ok
Checking: StateT.set... ok
Checking: StateT.modifyGet... ok
Checking: instMonadStateOfStateTOfMonad... ok
Checking: _private.Init.Data.Format.Basic.0.Std.Format.State.rec... ok
Checking: _private.Init.Data.Format.Basic.0.Std.Format.State.casesOn... ok
Checking: _private.Init.Data.Format.Basic.0.Std.Format.instMonadPrettyFormatStateMState.match_1... ok
Checking: String.Internal.pushn... ok
Checking: _private.Init.Data.Format.Basic.0.Std.Format.State.column... ok
Checking: _private.Init.Data.Format.Basic.0.Std.Format.instMonadPrettyFormatStateMState... ok
Checking: _private.Init.Data.Format.Basic.0.Std.Format.State.out... ok
Checking: Std.Format.pretty... ok
Checking: Int.instInhabited... ok
Checking: Int.default_eq_zero... ok
Checking: Nat.zero_mod... ok
Checking: List.flatten_reverse... ok
Checking: forall_eq'... ok
Checking: forall_eq'._simp_1... ok
Checking: Option.bind_congr... ok
Checking: StateT.run_pure... FAIL
Checking: Task.recOn... ok
Checking: Option.get!_some... ok
Checking: CoeHTCT.noConfusionType... ok
Checking: CoeHTCT.noConfusion... ok
Checking: unexpandUnit... ok
Checking: ForIn'.casesOn... ok
Checking: ForIn'.noConfusionType... ok
Checking: ForIn'.noConfusion... ok
Checking: ForIn'.mk.noConfusion... ok
Checking: Nat.Linear.Expr.toPoly.go.eq_2... ok
Checking: Std.Format.group.noConfusion... ok
Checking: Std.Format.group.inj... ok
Checking: ite_id... ok
Checking: Std.Format.tag.noConfusion... ok
Checking: Std.Format.tag.injEq... ok
Checking: Div.casesOn... ok
Checking: Div.noConfusionType... ok
Checking: Div.noConfusion... ok
Checking: MonadLift.rec... ok
Checking: _private.Init.Data.Array.Basic.0.Array.ext.extAux... ok
Checking: Array.ext... ok
Checking: Array.extLit... ok
Checking: Nat.Linear.Poly.insert.eq_2... ok
Checking: le_of_eq_of_le... ok
Checking: Task.Priority.dedicated... ok
Checking: XorOp.xor... ok
Checking: instHXorOfXorOp... ok
Checking: UInt8.toFin... ok
Checking: NonScalar.casesOn... ok
Checking: NonScalar.noConfusionType... ok
Checking: NonScalar.noConfusion... ok
Checking: NonScalar.mk.noConfusion... ok
Checking: NonScalar.mk.inj... ok
Checking: PProd.ctorIdx... ok
Checking: term‹_›... ok
Checking: Lean.term_Matches_|... ok
Checking: Lean.Parser.Tactic.replace... ok
Checking: Bool.xor_comm... TIMEOUT
Checking: Lean.unbracketedExplicitBinders... ok
Checking: Lean.explicitBinders... ok
Checking: termExists_,_... ok
Checking: Classical.imp_and_neg_imp_iff... ok
Checking: Lean.Syntax.Preresolved.noConfusionType... ok
Checking: Option.getD_join... ok
Checking: Bool.apply_cond... ok
Checking: OfNat.rec... ok
Checking: OfNat.casesOn... ok
Checking: OfNat.noConfusionType... ok
Checking: OfNat.noConfusion... ok
Checking: ST.Prim.Ref.ptrEq... ok
Checking: Array.findIdx?.loop._proof_1... ok
Checking: Array.findIdx?.loop._proof_2... ok
Checking: Array.findIdx?.loop... ok
Checking: Array.findIdx?... ok
Checking: Array.findIdx?.eq_1... ok
Checking: Bool.instDecidableExistsOfDecidablePred.match_1... ok
Checking: Lean.Parser.Tactic.exact?... ok
Checking: Lean.Syntax.node5... ok
Checking: Nat.mul_add... ok
Checking: List.replace_append... ok
Checking: List.replace_append_right... ok
Checking: Lean.Parser.Attr.normCastLabel... ok
Checking: Lean.Parser.Attr.norm_cast... ok
Checking: Array.getInternal.congr_simp... ok
Checking: DoResultSBC.break.noConfusion... ok
Checking: DoResultSBC.break.injEq... ok
Checking: Nat.Linear.Expr.toPoly.eq_1... ok
Checking: Lean.Meta.EtaStructMode._sizeOf_1... ok
Checking: Lean.Meta.EtaStructMode._sizeOf_inst... ok
Checking: Lean.Meta.DSimp.Config._sizeOf_1... ok
Checking: Lean.Meta.DSimp.Config._sizeOf_inst... ok
Checking: Lean.Meta.DSimp.Config.mk.sizeOf_spec... ok
Checking: Lean.Meta.Simp.ConfigCtx.noConfusionType... ok
Checking: Lean.Meta.Simp.ConfigCtx.noConfusion... ok
Checking: Lean.Meta.Simp.ConfigCtx.mk.noConfusion... ok
Checking: Lean.Meta.Simp.ConfigCtx.mk.inj... ok
Checking: Option.ite_none_right_eq_some._simp_1... ok
Checking: Option.mem_ite_none_right... ok
Checking: List.foldl_reverse... ok
Checking: List.foldr_eq_foldl_reverse... ok
Checking: UInt64.rec... ok
Checking: UInt64.casesOn... ok
Checking: UInt64.decEq.match_1... ok
Checking: UInt64.decEq._proof_1... ok
Checking: UInt64.noConfusionType... ok
Checking: UInt64.noConfusion... ok
Checking: UInt64.decEq._proof_2... ok
Checking: UInt64.decEq... ok
Checking: _private.Init.Data.Array.Basic.0.Array.idxOfAux._proof_1... ok
Checking: _private.Init.Data.Array.Basic.0.Array.idxOfAux._proof_2... ok
Checking: Array.idxOfAux... ok
Checking: HAdd.ctorIdx... ok
Checking: iff_self_or... ok
Checking: Lean.reduceCmd... ok
Checking: PNonScalar.mk.inj... ok
Checking: Char.valid... ok
Checking: Lean.Parser.Tactic.Grind.lia... ok
Checking: Insert.rec... ok
Checking: Insert.casesOn... ok
Checking: Insert.noConfusionType... ok
Checking: Insert.noConfusion... ok
Checking: Insert.mk.noConfusion... ok
Checking: Lean.calcFirstStep... ok
Checking: Lean.calcStep... ok
Checking: Lean.calcSteps... ok
Checking: Lean.convCalc_... ok
Checking: _private.Init.Prelude.0.Lean.replaceRef.match_1... ok
Checking: Lean.replaceRef... ok
Checking: Nat.mul_le_mul_left_iff... ok
Checking: getElem!_neg... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getLast!_of_getLast?.match_1_1... ok
Checking: List.getLast!_of_getLast?... ok
Checking: List.getLast!_eq_getElem!... ok
Checking: Lean.Parser.Tactic.rcasesPat.ignore... ok
Checking: Bool.beq_not_self... TIMEOUT
Checking: Nat.le_of_lt_add_one... ok
Checking: Std.Format.instCoeString... ok
Checking: ExceptCpsT.instLawfulMonad... ok
Checking: Lean.Grind.NoopConfig.ctorIdx... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.decodeCharLit.match_1... ok
Checking: Lean.Syntax.decodeCharLit... ok
Checking: _private.Init.PropLemmas.0.exists_prop.match_1_1... ok
Checking: _private.Init.PropLemmas.0.exists_prop.match_1_3... ok
Checking: exists_prop... ok
Checking: exists_prop._simp_1... ok
Checking: List.exists_mem_cons... ok
Checking: Nat.Linear.PolyCnstr.norm... ok
Checking: Nat.Linear.ExprCnstr.toPoly_norm_eq... ok
Checking: imp_not_self... ok
Checking: Decidable.not_imp_self... ok
Checking: Lean.Parser.Tactic.letrec... ok
Checking: Option.isSome_iff_ne_none... ok
Checking: HasEquiv.ctorIdx... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getLast?_tail.match_1_1... ok
Checking: List.getLast?_cons... ok
Checking: List.getLast?_cons_cons... ok
Checking: Nat.elimOffset... ok
Checking: List.getLast?_tail... ok
Checking: Nat.Linear.ExprCnstr.mk.injEq... ok
Checking: Classical.ofNonempty._proof_1... ok
Checking: Classical.ofNonempty... ok
Checking: Void.mk... ok
Checking: Lean.doElemWhile_:_Do_... ok
Checking: Int.instDvd... ok
Checking: Lean.Meta.EtaStructMode.ctorElimType... ok
Checking: Lean.Meta.EtaStructMode.ctorElim... ok
Checking: Lean.Meta.EtaStructMode.notClasses.elim... ok
Checking: LawfulSingleton... ok
Checking: LawfulSingleton.mk... ok
Checking: LawfulSingleton.rec... ok
Checking: LawfulSingleton.recOn... ok
Checking: Int.decLe... ok
Checking: Int.instMax... ok
Checking: Prod.map_snd... FAIL
Checking: Ne.irrefl... ok
Checking: false_of_ne... ok
Checking: ST.Out.noConfusionType... ok
Checking: ST.Out.noConfusion... ok
Checking: List.getLastD_nil... ok
Checking: _auto._@.Init.Data.Array.Basic.487995779._hygCtx._hyg.8... ok
Checking: _private.Init.Data.Array.Basic.0.Array.insertIdx.loop._unary._proof_1... ok
Checking: _private.Init.Data.Array.Basic.0.Array.insertIdx.loop._unary._proof_2... ok
Checking: Fin.val_lt_of_le... ok
Checking: _private.Init.Data.Array.Basic.0.Array.insertIdx.loop._unary._proof_3... ok
Checking: _private.Init.Data.Array.Basic.0.Array.insertIdx.loop._unary._proof_4... ok
Checking: _private.Init.Data.Array.Basic.0.Array.insertIdx.loop._unary._proof_5... ok
Checking: _private.Init.Data.Array.Basic.0.Array.insertIdx.loop._unary._proof_6... ok
Checking: _private.Init.Data.Array.Basic.0.Array.insertIdx.loop._unary._proof_7... ok
Checking: _private.Init.Data.Array.Basic.0.Array.insertIdx.loop._unary... ok
Checking: _private.Init.Data.Array.Basic.0.Array.insertIdx.loop... ok
Checking: List.length_concat... ok
Checking: Array.size_push... ok
Checking: _private.Init.Data.Array.Basic.0.Array.insertIdx._proof_1... ok
Checking: Array.insertIdx... ok
Checking: Array.insertIdxIfInBounds... ok
Checking: List.flatMap_eq_foldl... ok
Checking: List.foldl_flip_cons_eq_append... ok
Checking: List.zipIdx_cons... ok
Checking: Lean.Parser.Category.ctorIdx... ok
Checking: Lean.Parser.Category.toCtorIdx... ok
Checking: MonadReader.casesOn... ok
Checking: MonadReader.noConfusionType... ok
Checking: MonadReader.noConfusion... ok
Checking: MonadReader.mk.noConfusion... ok
Checking: _private.Init.Data.Nat.Linear.0.Nat.Linear.PolyCnstr.eq_true_of_isValid.match_1_4... ok
Checking: Nat.Linear.PolyCnstr.eq_true_of_isValid... ok
Checking: Nat.Linear.ExprCnstr.eq_true_of_isValid... ok
Checking: Lean.ParserDescr.cat.sizeOf_spec... ok
Checking: Lean.Meta.ApplyConfig.mk.inj... ok
Checking: SMul.rec... ok
Checking: SMul.casesOn... ok
Checking: SMul.noConfusionType... ok
Checking: SMul.noConfusion... ok
Checking: SMul.mk.noConfusion... ok
Checking: LawfulMonadLiftT.rec... ok
Checking: term_≍_... ok
Checking: Lean.Grind.ConfigInteractive.ctorIdx... ok
Checking: List.tail_eq_tailD... ok
Checking: List.map_const'... ok
Checking: ReaderT.run_seq... ok
Checking: dite_eq_right_iff... ok
Checking: Option.Rel... ok
Checking: Option.Rel.some... ok
Checking: Option.Rel.none... ok
Checking: Option.Rel.rec... ok
Checking: Option.Rel.casesOn... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.rel_some_some.match_1_1... ok
Checking: Option.rel_some_some... ok
Checking: Nat.repeat.match_1... ok
Checking: Nat.repeat... ok
Checking: List.get.eq_1... ok
Checking: Bool.beq_eq_decide_eq... ok
Checking: HasSSubset.ctorIdx... ok
Checking: Lean.deprecated... ok
Checking: UInt32.ofBitVec.noConfusion... ok
Checking: Array.back!... ok
Checking: Lean.Parser.Tactic.symmSaturate... ok
Checking: Lean.Module.commands... ok
Checking: MonadControl.noConfusion... ok
Checking: MonadControl.mk.noConfusion... ok
Checking: of_getElem?_eq_some... ok
Checking: Lean.Meta.Simp.Config.proj... ok
Checking: _private.Init.Data.Repr.0.Sum.repr.match_1... ok
Checking: Sum.repr... ok
Checking: instReprSum... ok
Checking: Lean.Parser.Tactic.DecideConfig.revert... ok
Checking: DoResultPRBC.return.noConfusion... ok
Checking: DoResultPRBC.return.inj... ok
Checking: List.Perm.rec... ok
Checking: List.Perm.brecOn... ok
Checking: Option.max_none_right... ok
Checking: Option.max_none_left... ok
Checking: Option.max_eq_or... ok
Checking: Lean.Parser.Tactic.Grind.withAnnotateState... ok
Checking: Lean.Parser.Tactic.mexistsMacro... ok
Checking: String.Pos.Raw.mk.sizeOf_spec... ok
Checking: instToStringProd.match_1... ok
Checking: Lean.Macro.instNonemptyMethodsRef... ok
Checking: Lean.Macro.mkMethods... ok
Checking: Lean.Macro.instInhabitedMethodsRef... ok
Checking: Lean.Parser.Tactic.mleaveMacro... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.beq.match_1.splitter... ok
Checking: Nat.beq.eq_def... ok
Checking: _private.Init.Data.Array.Basic.0.Array.shrink.match_1... ok
Checking: _private.Init.Data.Array.Basic.0.Array.shrink.loop... ok
Checking: Array.shrink... ok
Checking: HOrElse.hOrElse... ok
Checking: OrElse.orElse... ok
Checking: instHOrElseOfOrElse... ok
Checking: instOrElseOfAlternative... ok
Checking: optional... ok
Checking: DoResultBC.break.inj... ok
Checking: Lean.Parser.Tactic.rwSeq... ok
Checking: Equivalence.rec... ok
Checking: Equivalence.casesOn... ok
Checking: List.eraseDupsBy.loop.eq_1... ok
Checking: Lean.Parser.Tactic.tacticSorry... ok
Checking: andM... ok
Checking: Option.Rel.recOn... ok
Checking: List.eraseIdx.match_1... ok
Checking: List.eraseIdx... ok
Checking: List.eraseIdx_cons_zero... ok
Checking: List.find?... ok
Checking: List.findM?_pure... ok
Checking: List.getElem?_cons... ok
Checking: List.head?_map... ok
Checking: Bool.ne_of_lt... ok
Checking: Lean.Parser.Tactic.intros... ok
Checking: Lean.MonadNameGenerator.noConfusionType... ok
Checking: instMonadFinallyST.match_1... ok
Checking: instMonadLiftSTEST... ok
Checking: Fin.mul._proof_1... ok
Checking: Fin.mul... ok
Checking: Fin.instMul... ok
Checking: ReprTuple.ctorIdx... ok
Checking: pure_id_seq... ok
Checking: Bool.and_eq_left_iff_imp... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getLast?.match_1.splitter... ok
Checking: List.filterMap.eq_def... ok
Checking: Lean.Macro.Exception._sizeOf_1... ok
Checking: Lean.Macro.Exception._sizeOf_inst... ok
Checking: Lean.Macro.Exception.unsupportedSyntax.sizeOf_spec... ok
Checking: Fin.getElem_fin... ok
Checking: HXor.rec... ok
Checking: HXor.casesOn... ok
Checking: HXor.noConfusionType... ok
Checking: Lean.Parser.Tactic.rcasesPat.paren... ok
Checking: Lean.MonadNameGenerator.setNGen... ok
Checking: Bool.term_^^_... ok
Checking: Nat.eq_iff_le_and_ge... ok
Checking: term_<=<_... ok
Checking: ExceptT.adapt... ok
Checking: imp_congr_right... ok
Checking: Decidable.or_congr_left'... ok
Checking: List.map_tail?... ok
Checking: UInt32.ofBitVec.injEq... ok
Checking: Except.toOption... ok
Checking: Option.max_eq_right_of_lt... ok
Checking: _private.Init.Data.List.Lemmas.0.List.eq_iff_flatten_eq.match_1_1... ok
Checking: iff_and_self._simp_1... ok
Checking: List.eq_iff_flatten_eq... ok
Checking: ExceptT.runK... ok
Checking: ExceptT.runCatch... ok
Checking: true_eq_decide_iff... ok
Checking: Lean.Macro.Context.rec... ok
Checking: Lean.Macro.Context.casesOn... ok
Checking: Nat.lt_add_right... ok
Checking: _private.Init.PropLemmas.0.forall_eq_apply_imp_iff._simp_1_1... ok
Checking: forall_eq_apply_imp_iff... ok
Checking: Mul.recOn... ok
Checking: Int.ofNat_zero... ok
Checking: List.forall_mem_ne'... ok
Checking: _private.Init.Control.Lawful.Instances.0.OptionT.seqLeft_eq.match_1_5... ok
Checking: _private.Init.Control.Lawful.Instances.0.OptionT.seqLeft_eq._simp_1_7... ok
Checking: OptionT.seqLeft_eq... ok
Checking: OptionT.instLawfulMonad... ok
Checking: HPow.ctorIdx... ok
Checking: Lean.Syntax.Command... ok
Checking: absurd.congr_simp... ok
Checking: MonadFunctor.ctorIdx... ok
Checking: Bool.or_true... ok
Checking: Option.isSome_max... ok
Checking: Option.max_join_right._proof_1... ok
Checking: Option.max_join_right... ok
Checking: Lean.Meta.Omega.OmegaConfig.mk.inj... ok
Checking: List.mem_insert_iff._simp_1... ok
Checking: List.all_insert... ok
Checking: ShiftRight.rec... ok
Checking: ShiftRight.casesOn... ok
Checking: ShiftRight.noConfusionType... ok
Checking: ShiftRight.noConfusion... ok
Checking: none_eq_getElem?_iff... ok
Checking: List.mem_ite_nil_left... ok
Checking: true_imp_iff... ok
Checking: _private.Init.PropLemmas.0.Decidable.and_or_imp._simp_1_1... ok
Checking: false_imp_iff... ok
Checking: _private.Init.PropLemmas.0.Decidable.and_or_imp._simp_1_2... ok
Checking: Decidable.and_or_imp... ok
Checking: Lean.Meta.Simp.Config._sizeOf_1... ok
Checking: Lean.Meta.Simp.Config._sizeOf_inst... ok
Checking: Lean.Meta.Simp.Config.mk.sizeOf_spec... ok
Checking: List.range'TR.go.eq_2... ok
Checking: Option.pmap_some'... ok
Checking: PSum.ctorIdx... ok
Checking: PSum.ctorElimType... ok
Checking: PSum.ctorElim... ok
Checking: PSum.inl.elim... ok
Checking: CoeSort.recOn... ok
Checking: Lean.Parser.Tactic.normCastAddElim... ok
Checking: Relation.TransGen.below... ok
Checking: Relation.TransGen.below.single... ok
Checking: Relation.TransGen.below.tail... ok
Checking: Relation.TransGen.brecOn... ok
Checking: Nat.pow_one... ok
Checking: Nat.pow_succ... ok
Checking: Nat.mul_lt_mul_of_pos_right... ok
Checking: Nat.pow_lt_pow_left... ok
Checking: Lean.Parser.Tactic.simpAllTraceArgsRest... ok
Checking: pi_congr... ok
Checking: CoeHTC.coe... ok
Checking: instCoeHTCTOfCoeTailOfCoeHTC... ok
Checking: List.any_map... ok
Checking: Lean.Grind.Config.lax... ok
Checking: Lean.Macro.Methods.hasDecl... ok
Checking: Lean.Macro.hasDecl... ok
Checking: Std.Format.MonadPrettyFormat.mk.noConfusion... ok
Checking: _private.Init.Data.Array.Basic.0.Array.findFinIdx?.loop._proof_1... ok
Checking: _private.Init.Data.Array.Basic.0.Array.findFinIdx?.loop._proof_2... ok
Checking: _private.Init.Data.Array.Basic.0.Array.findFinIdx?.loop... ok
Checking: Array.findFinIdx?... ok
Checking: Lean.Syntax.Preresolved.ctorElimType... ok
Checking: Lean.Syntax.Preresolved.ctorElim... ok
Checking: Lean.Syntax.Preresolved.decl.elim... ok
Checking: Lean.Macro.Methods.resolveNamespace... ok
Checking: Option.map_map... ok
Checking: Option.map_comp_map... FAIL
Checking: OptionT.lift.eq_1... ok
Checking: List.getLast_reverse... ok
Checking: List.head_eq_getLast_reverse... ok
Checking: Alternative.failure... ok
Checking: Option.getM... ok
Checking: Option.getM_some... FAIL
Checking: Std.Format.MonadPrettyFormat.recOn... ok
Checking: List.foldr_map... ok
Checking: ForIn.rec... ok
Checking: ForIn.casesOn... ok
Checking: Bool.or_eq_false_iff... ok
Checking: Option.map.eq_1... ok
Checking: List.append_right_inj... ok
Checking: List.append_right_eq_self... ok
Checking: List.self_eq_append_right... ok
Checking: MonadControlT.liftWith... ok
Checking: Nat.add_lt_add_right... ok
Checking: Lean.Parser.Tactic.injections... ok
Checking: Lean.Parser.Tactic.Conv.convApply_... ok
Checking: _private.Init.SimpLemmas.0.and_assoc.match_1_1... ok
Checking: _private.Init.SimpLemmas.0.and_assoc.match_1_3... ok
Checking: and_assoc... ok
Checking: _private.Init.PropLemmas.0.and_right_comm.match_1_1... ok
Checking: _private.Init.PropLemmas.0.and_right_comm.match_1_3... ok
Checking: and_right_comm... ok
Checking: and_and_and_comm... ok
Checking: MonadControlT.rec... ok
Checking: MonadControlT.casesOn... ok
Checking: MonadControlT.noConfusionType... ok
Checking: MonadControlT.noConfusion... ok
Checking: MonadControlT.mk.noConfusion... ok
Checking: ne_comm... ok
Checking: List.map_eq_foldr... ok
Checking: Prod.mk.injEq... ok
Checking: _private.Init.Data.Prod.0.Prod.swap_inj._simp_1_1... ok
Checking: Prod.swap_inj... ok
Checking: Lean.Parser.Tactic.failIfSuccess... ok
Checking: UInt64.ofBitVec.noConfusion... ok
Checking: UInt64.ofBitVec.injEq... ok
Checking: Nat.Linear.Poly.isNonZero.eq_2... ok
Checking: MonadEval.recOn... ok
Checking: StateRefT'.get... ok
Checking: Insert.ctorIdx... ok
Checking: Nat.Linear.Expr.toPoly.go.eq_4... ok
Checking: Lean.term∀__,_... ok
Checking: Lean.Parser.Tactic.Conv.first... ok
Checking: if_true... ok
Checking: ReaderT.run_seqRight... FAIL
Checking: _private.Init.Data.Option.Lemmas.0.Option.not_rel_none_some.match_1_1... ok
Checking: Option.not_rel_none_some... ok
Checking: Option.bind_guard... ok
Checking: List.length_nil... ok
Checking: Std.Format.nest.sizeOf_spec... ok
Checking: Lean.Grind.Config.ctorIdx... ok
Checking: Int.ofNat.elim... ok
Checking: Lean.Grind.NoopConfig.mk.inj... ok
Checking: Lean.Meta.TransparencyMode._sizeOf_1... ok
Checking: Lean.Meta.TransparencyMode._sizeOf_inst... ok
Checking: Lean.Meta.TransparencyMode.all.sizeOf_spec... ok
Checking: Option.eq_none_iff_forall_ne_some... ok
Checking: Option.join_beq_some... ok
Checking: Lean.Grind.Config.detailed... ok
Checking: Substring.Raw.Internal.isEmpty... ok
Checking: Lean.Syntax.TSepArray.recOn... ok
Checking: Lean.Parser.Syntax.addPrec... ok
Checking: Lean.Meta.ApplyConfig.synthAssignedInstances... ok
Checking: Nat.Linear.instBEqPolyCnstr... ok
Checking: Nat.Linear.instBEqPolyCnstr.beq.eq_1... ok
Checking: Nat.Linear.instBEqPolyCnstr.beq_spec_1... ok
Checking: Nat.Linear.instReflBEqPolyCnstr... ok
Checking: Bool.and_eq_true_iff... ok
Checking: DerivingHelpers.and_true_curry... ok
Checking: DerivingHelpers.deriving_lawful_beq_helper_nd... ok
Checking: _private.Init.Data.List.Basic.0.List.instLawfulBEq.match_1... ok
Checking: List.instLawfulBEq... ok
Checking: Prod.instLawfulBEq... ok
Checking: Nat.Linear.instLawfulBEqPolyCnstr... ok
Checking: Array.forIn'_eq_forIn'... ok
Checking: Array.swap.congr_simp... ok
Checking: instDecidableIte... ok
Checking: EStateM.Result.ctorElimType... ok
Checking: EStateM.Result.ctorElim... ok
Checking: EStateM.Result.ok.elim... ok
Checking: Nat.add_le_add_iff_left... ok
Checking: StateT.run'... ok
Checking: StateT.run'_eq... FAIL
Checking: Lean.Syntax.SepArray.mk.noConfusion... ok
Checking: List.insert_nil... FAIL
Checking: Dvd.casesOn... ok
Checking: Dvd.noConfusionType... ok
Checking: ForInStep.yield.noConfusion... ok
Checking: instInhabitedPNonScalar.default... ok
Checking: Lean.SourceInfo.none.sizeOf_spec... ok
Checking: Array.push.eq_1... ok
Checking: Except.recOn... ok
Checking: MonadStateOf.rec... ok
Checking: MonadStateOf.recOn... ok
Checking: List.getLast_cons_cons._proof_1... ok
Checking: List.getLast_cons_cons._proof_2... ok
Checking: List.getLast_cons_cons... ok
Checking: Option.sequence.match_1... ok
Checking: Option.sequence... ok
Checking: Option.sequence_none... FAIL
Checking: Lean.MonadQuotation.rec... ok
Checking: Lean.MonadQuotation.casesOn... ok
Checking: Lean.MonadQuotation.noConfusionType... ok
Checking: Lean.MonadQuotation.noConfusion... ok
Checking: Lean.MonadQuotation.mk.noConfusion... ok
Checking: Option.all_min... ok
Checking: Option.filter.eq_1... ok
Checking: _private.Init.Ext.0.PSigma.ext.match_1... ok
Checking: PSigma.ext... ok
Checking: PSigma.ext_iff... ok
Checking: Functor.ctorIdx... ok
Checking: List.any_beq... ok
Checking: List.any_beq'... ok
Checking: DoResultPR.return.noConfusion... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getLastD_mem_cons.match_1_1... ok
Checking: List.getLastD_mem_cons... ok
Checking: _private.Init.PropLemmas.0.eq_true_eq_id._simp_1_1... ok
Checking: eq_true_eq_id... ok
Checking: Int.ofNat_two... ok
Checking: List.any_eq_true... ok
Checking: Lean.Parser.Tactic.Conv.convIntro___... ok
Checking: List.length_insert_of_mem... ok
Checking: List.length_insert_of_not_mem... ok
Checking: List.length_le_length_insert... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.sub_one_cancel.match_1_1... ok
Checking: Nat.sub_one_cancel... ok
Checking: List.findIdx_nil... ok
Checking: Lean.Parser.Tactic.tacticRefine_lift'_... ok
Checking: not_of_iff_false... ok
Checking: Lean.Syntax.SepArray.elemsAndSeps... ok
Checking: Lean.Syntax.SepArray.getElems... ok
Checking: Lean.Meta.ApplyNewGoals.nonDependentFirst.sizeOf_spec... ok
Checking: Std.IdempotentOp.idempotent... ok
Checking: Option.instIdempotentOpMax... ok
Checking: BitVec.ofFin.noConfusion... ok
Checking: BitVec.ofFin.inj... ok
Checking: Lean.monadNameGeneratorLift... ok
Checking: OrOp.rec... ok
Checking: OrOp.recOn... ok
Checking: List.leftpad... ok
Checking: Lean.Parser.Tactic.mstartMacro... ok
Checking: Decidable.predToBool... ok
Checking: Option.mem_bind_iff... ok
Checking: decidable_of_iff'... ok
Checking: ForM.casesOn... ok
Checking: exists₄_congr... ok
Checking: Lean.Parser.Syntax.exact?... ok
Checking: StateRefT'.instLawfulMonadLift... ok
Checking: EStateM.Result.error.noConfusion... ok
Checking: EStateM.Result.error.injEq... ok
Checking: term_=<<_... ok
Checking: coeFunNotation... ok
Checking: String.mk... ok
Checking: dite_false... ok
Checking: List.mapA... ok
Checking: Ne.elim... ok
Checking: List.foldr_flip_append_eq_append... ok
Checking: Lean.ParserDescr.unary.noConfusion... ok
Checking: Substring.Raw.Internal.takeWhile... ok
Checking: Quotient.recOn... ok
Checking: Lean.Parser.Command.classAbbrev... ok
Checking: stx!_... ok
Checking: Lean.Parser.Tactic.Conv.convErw__... ok
Checking: Lean.Parser.Tactic.Conv.conv.quot... ok
Checking: _private.Init.Prelude.0.USize.size_pos.match_1_1... ok
Checking: _private.Init.Prelude.0.USize.size_eq.match_1_1... ok
Checking: System.Platform.numBits_eq... ok
Checking: USize.size_eq... ok
Checking: USize.size_pos... ok
Checking: USize.ofNatTruncate._proof_1... ok
Checking: USize.ofNatTruncate... ok
Checking: _private.Init.PropLemmas.0.and_left_comm.match_1_1... ok
Checking: _private.Init.PropLemmas.0.and_left_comm.match_1_3... ok
Checking: and_left_comm... ok
Checking: ReaderT.run_read... FAIL
Checking: Std.Format.FlattenAllowability._sizeOf_1... ok
Checking: Std.Format.FlattenAllowability._sizeOf_inst... ok
Checking: Std.Format.FlattenAllowability.allow.sizeOf_spec... ok
Checking: List.head?_concat... ok
Checking: USize.decLe... ok
Checking: Option.some_eq_dite_none_right... ok
Checking: Bool.or_left_comm... ok
Checking: _private.Init.Data.Array.Basic.0.Array.erase.match_1... ok
Checking: Array.reverse._proof_2... ok
Checking: Array.eraseP... ok
Checking: map_bind... ok
Checking: bind_map_left... ok
Checking: ExceptT.lift_bind... FAIL
Checking: Option.lawfulIdentity_merge... ok
Checking: Lean.Meta.DSimp.Config.recOn... ok
Checking: List.findSomeM?_cons.match_1... ok
Checking: SDiff.rec... ok
Checking: Lean.Name.str.sizeOf_spec... ok
Checking: Lean.Parser.Tactic.Grind.focus... ok
Checking: Lean.Meta.EtaStructMode.noConfusionType... ok
Checking: Lean.Meta.EtaStructMode.noConfusion... ok
Checking: Lean.Meta.Simp.Config.ground... ok
Checking: Bool.decide_coe... ok
Checking: LT.recOn... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.get_of_eq_some.match_1_1... ok
Checking: Option.get_of_eq_some... ok
Checking: List.Pairwise.below.rec... ok
Checking: term__[_]_!... ok
Checking: Std.Format.join... ok
Checking: Array.back?... ok
Checking: _private.Init.Control.StateRef.0.StateRefT'.run'.match_1... ok
Checking: StateRefT'.run'... ok
Checking: _private.Init.Data.Array.Basic.0.Array.mapM.map._unary._proof_1... ok
Checking: _private.Init.Data.Array.Basic.0.Array.mapM.map._unary._proof_2... ok
Checking: _private.Init.Data.Array.Basic.0.Array.mapM.map._unary... ok
Checking: _private.Init.Data.Array.Basic.0.Array.mapM.map... ok
Checking: Array.mapM... ok
Checking: Array.map... ok
Checking: Array.instFunctor... ok
Checking: Lean.modCast... ok
Checking: List.getD_eq_getElem?_getD... ok
Checking: Int.ofNat_one... ok
Checking: instReprRaw_1... ok
Checking: Nat.beq.eq_1... ok
Checking: List.replicate_append_replicate... ok
Checking: Nat.add_one_mul... ok
Checking: List.flatten_replicate_replicate... ok
Checking: List.getElem!_nil... ok
Checking: List.filterMap_filter... ok
Checking: List.append.eq_2... ok
Checking: ST.Out.recOn... ok
Checking: List.nil_eq_append_iff... ok
Checking: _private.Init.Data.List.Lemmas.0.List.filterMap_eq_append_iff._simp_1_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.filterMap_eq_append_iff._simp_1_2... ok
Checking: List.filterMap_eq_append_iff... ok
Checking: List.append_eq_filterMap_iff... ok
Checking: Lean.Parser.Tactic.eqRefl... ok
Checking: Fin.ofNat'... ok
Checking: List.beq_cons₂... ok
Checking: instToStringRaw_1... ok
Checking: List.findSome?_cons... FAIL
Checking: Nat.instTransLtLe... ok
Checking: Lean.hexnumKind... ok
Checking: AndThen... ok
Checking: AndThen.mk... ok
Checking: AndThen.rec... ok
Checking: AndThen.casesOn... ok
Checking: AndThen.noConfusionType... ok
Checking: Lean.Module.casesOn... ok
Checking: instCoeTCOfCoe_1... ok
Checking: Decidable.by_contra... ok
Checking: Option.bind_none... ok
Checking: Option.none_bind... ok
Checking: PSigma._sizeOf_1... ok
Checking: PSigma._sizeOf_inst... ok
Checking: PSigma.mk.sizeOf_spec... ok
Checking: Std.LawfulRightIdentity.rec... ok
Checking: Std.LawfulRightIdentity.casesOn... ok
Checking: Option.mem_unique... ok
Checking: Option.all_join... ok
Checking: Std.ToFormat.noConfusion... ok
Checking: Subtype.mk.noConfusion... ok
Checking: Subtype.mk.inj... ok
Checking: MonadReaderOf.noConfusionType... ok
Checking: MonadReaderOf.noConfusion... ok
Checking: MonadReaderOf.mk.noConfusion... ok
Checking: Array.mkArray8... ok
Checking: Lean.Syntax.node8... ok
Checking: Seq.recOn... ok
Checking: tacticBy_cases_:_... ok
Checking: Prod.Lex.instDecidableRelOfDecidableEq.match_5... ok
Checking: Prod.Lex.instDecidableRelOfDecidableEq.match_3... ok
Checking: Prod.Lex.instDecidableRelOfDecidableEq._proof_1... ok
Checking: Prod.Lex.instDecidableRelOfDecidableEq._proof_2... ok
Checking: Prod.Lex.instDecidableRelOfDecidableEq._proof_3... ok
Checking: Prod.Lex.instDecidableRelOfDecidableEq... ok
Checking: Option.isNone_bind... ok
Checking: List.eraseP... ok
Checking: Std.LawfulLeftIdentity.left_id... ok
Checking: Lean.Syntax.instCoeTSyntaxArrayOfTSyntax... ok
Checking: Lean.Parser.Tactic.Conv.arg... ok
Checking: Except.map.eq_2... ok
Checking: Bool.default_bool... ok
Checking: Lean.MonadQuotation.addMacroScope... ok
Checking: Nat.lt_of_add_one_le... ok
Checking: Bool.or_comm... ok
Checking: List.any_reverse... ok
Checking: Bool.and'.eq_1... ok
Checking: Alternative.noConfusionType... ok
Checking: Alternative.noConfusion... ok
Checking: wfParam... ok
Checking: Option.pmap_none'... ok
Checking: Lean.Parser.Tactic.clearValueStar... ok
Checking: Lean.Parser.Tactic.clearValueArg... ok
Checking: termS!_... ok
Checking: Option.any_bind... ok
Checking: Lean.NameGenerator.noConfusion... ok
Checking: Lean.NameGenerator.mk.noConfusion... ok
Checking: Lean.NameGenerator.mk.injEq... ok
Checking: Nat.Linear.Poly.isZero.eq_1... ok
Checking: IntCast.intCast... ok
Checking: Int.cast... ok
Checking: instIntCastInt... ok
Checking: Int.cast_eq... ok
Checking: Task.ctorIdx... ok
Checking: List.mapTR.loop.match_1... ok
Checking: List.mapTR.loop... ok
Checking: Array.eraseIdx.congr_simp... ok
Checking: USize.ofBitVec.injEq... ok
Checking: Bool.not_eq_true'... ok
Checking: LawfulMonad.rec... ok
Checking: LawfulMonad.recOn... ok
Checking: Array.append... ok
Checking: Array.instAppend... ok
Checking: Array.leftpad... ok
Checking: Lean.Module.header... ok
Checking: Std.Asymm... ok
Checking: Std.Asymm.mk... ok
Checking: Std.Asymm.asymm... ok
Checking: UInt16.ofNatLT... ok
Checking: Option.map_max... ok
Checking: Lean.instGetElemRArrayNatTrue... ok
Checking: Substring.Raw.bsize.match_1... ok
Checking: Substring.Raw.bsize... ok
Checking: Bool.not_bne... TIMEOUT
Checking: Lean.Grind.Config.zetaDelta... ok
Checking: Lean.Meta.Occurrences.casesOn... ok
Checking: Lean.Meta.Occurrences.ctorIdx... ok
Checking: Lean.Meta.Occurrences.ctorElimType... ok
Checking: Lean.Meta.Occurrences.ctorElim... ok
Checking: Lean.Meta.Occurrences.neg.elim... ok
Checking: Lean.RArray.leaf.noConfusion... ok
Checking: Std.Symm.rec... ok
Checking: Std.Symm.recOn... ok
Checking: and_self_right... ok
Checking: _private.Init.Meta.Defs.0.Array.filterSepElemsMAux... ok
Checking: Array.filterSepElemsM... ok
Checking: List.contains_filter... ok
Checking: StateT.instMonadLift... ok
Checking: StateT.monadControl... ok
Checking: dite_eq_ite... ok
Checking: UInt16.toBitVec... ok
Checking: UInt16.toNat... ok
Checking: instReprUInt16... ok
Checking: instMonadExceptOfExceptT... ok
Checking: Option.ctorElim... ok
Checking: Bool.cond_then_not_self... ok
Checking: Lean.Parser.Tactic.dsimpKind... ok
Checking: Option.orElse_none... ok
Checking: ExceptT.instMonadLift... ok
Checking: instMonadControlExceptTOfMonad... ok
Checking: Union.recOn... ok
Checking: List.insert_replicate_ne... ok
Checking: Lean.Macro.throwError... ok
Checking: Std.Total... ok
Checking: Std.Total.mk... ok
Checking: Std.Total.rec... ok
Checking: Std.Total.casesOn... ok
Checking: _private.Init.Data.List.Control.0.List.getLast?.match_1.splitter... ok
Checking: List.findSome?.eq_def... ok
Checking: Subtype.ctorIdx... ok
Checking: USize.toNat... ok
Checking: Array.uget... ok
Checking: Array.instGetElemUSizeLtNatToNatSize... ok
Checking: Bool.not_not... ok
Checking: List.all_eq_not_any_not... ok
Checking: beq_self_eq_true... ok
Checking: Lean.Parser.Category.doElem... ok
Checking: _private.Init.PropLemmas.0.exists_eq_right_right._simp_1_1... ok
Checking: exists_eq_right_right... ok
Checking: term_<||>_... ok
Checking: dite_iff_left_iff... ok
Checking: Lean.Parser.Tactic.specialize... ok
Checking: Array.reverse.loop._unary._proof_1... ok
Checking: Array.reverse._proof_1... ok
Checking: Array.reverse.termination... ok
Checking: Array.reverse.loop._unary._proof_2... ok
Checking: Array.reverse.loop._unary._proof_3... ok
Checking: Array.reverse._proof_3... ok
Checking: Array.reverse.loop._unary._proof_4... ok
Checking: Array.reverse.loop._unary... ok
Checking: Array.reverse.loop... ok
Checking: Array.reverse.loop._proof_1... ok
Checking: Array.reverse.loop._proof_2... ok
Checking: Array.reverse.loop._unary._proof_5... ok
Checking: Array.reverse.loop._unary._proof_6... ok
Checking: have_body_congr'... ok
Checking: Array.reverse.loop._unary.eq_def... ok
Checking: Array.reverse.loop.eq_def... ok
Checking: BEq.congr_right... ok
Checking: List.max?... ok
Checking: Option.map_or... ok
Checking: Lean.Syntax.instGetElemNatTrue... ok
Checking: _private.Init.PropLemmas.0.nonempty_of_exists.match_1_1... ok
Checking: nonempty_of_exists... ok
Checking: ReprTuple.casesOn... ok
Checking: ReprTuple.noConfusionType... ok
Checking: ReprTuple.noConfusion... ok
Checking: ReprTuple.mk.noConfusion... ok
Checking: Lean.Syntax.setHeadInfoAux... ok
Checking: Lean.Syntax.setHeadInfo... ok
Checking: _private.Init.WF.0.PSigma.revLex.match_1_1... ok
Checking: PSigma.RevLex.casesOn... ok
Checking: PSigma.noConfusionType... ok
Checking: PSigma.noConfusion... ok
Checking: PSigma.mk.noConfusion... ok
Checking: PSigma.revLexAccessible... ok
Checking: PSigma.revLex... ok
Checking: PSigma.skipLeft._proof_1... ok
Checking: PSigma.skipLeft... ok
Checking: List.eraseIdx_nil... ok
Checking: Lean.Parser.Tactic.normCast0... ok
Checking: Trans.rec... ok
Checking: Trans.casesOn... ok
Checking: Trans.noConfusionType... ok
Checking: Trans.noConfusion... ok
Checking: Trans.mk.noConfusion... ok
Checking: List.eq_or_ne_mem_of_mem... ok
Checking: _private.Init.Data.Fin.Basic.0.Fin.exists_iff.match_1_1... ok
Checking: _private.Init.Data.Fin.Basic.0.Fin.exists_iff.match_1_3... ok
Checking: Fin.exists_iff... ok
Checking: Id.hasBind... ok
Checking: Option.some_or... ok
Checking: iff_self_or._simp_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.append_eq_append_iff._simp_1_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.append_eq_append_iff._simp_1_3... ok
Checking: _private.Init.Data.List.Lemmas.0.List.append_eq_append_iff._simp_1_2... ok
Checking: List.append_eq_append_iff... ok
Checking: List.modifyHead.eq_2... ok
Checking: Task.bind... ok
Checking: Lean.Meta.TransparencyMode.reducible.sizeOf_spec... ok
Checking: Bool.and_eq_left_iff_imp._simp_1... ok
Checking: List.all_eq_true... ok
Checking: List.all_eq_true._simp_1... ok
Checking: List.all_replicate... ok
Checking: Lean.Parser.Tactic.simp... ok
Checking: Option.max_pfilter_right... ok
Checking: Lean.Macro.Context.noConfusionType... ok
Checking: Lean.Macro.Context.noConfusion... ok
Checking: Option.max_some_guard... ok
Checking: Bool.bne_true... TIMEOUT
Checking: imp_congr_ctx... ok
Checking: imp_congr... ok
Checking: HOr.hOr... ok
Checking: Setoid.rec... ok
Checking: Setoid.casesOn... ok
Checking: Setoid.noConfusionType... ok
Checking: Fin.rev._proof_1... ok
Checking: Fin.rev... ok
Checking: Sum.inr.noConfusion... ok
Checking: Sum.inr.inj... ok
Checking: UInt8.ofNatTruncate._proof_1... TIMEOUT
Checking: UInt8.ofNatTruncate... ok
Checking: Lean.Parser.Tactic.Conv.convTry_... ok
Checking: List.zip... ok
Checking: List.zip_nil_left... ok
Checking: Lean.mkHole... ok
Checking: Option.instForIn'InferInstanceMembership.match_1... ok
Checking: Lean.Grind.GrobnerConfig.toNoopConfig... ok
Checking: Array.range... ok
Checking: Id.run_pure... FAIL
Checking: Bool.ne_false_iff... ok
Checking: List.getElem_append_left'._proof_1... ok
Checking: List.getElem_append_left'... ok
Checking: Option.none_lt_some... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.none_lt._simp_1_1... ok
Checking: Option.none_lt... ok
Checking: Option.none_lt._simp_1... ok
Checking: Option.merge_lt_iff... ok
Checking: List.isPrefixOf?... ok
Checking: List.isSuffixOf?... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.lt_iff_le_not_le.match_1_1... ok
Checking: Nat.lt_of_not_ge... ok
Checking: Nat.lt_iff_le_not_le... ok
Checking: Nat.lt_iff_le_and_not_ge... ok
Checking: instInhabitedNonScalar.default... ok
Checking: instInhabitedNonScalar... ok
Checking: _private.Init.Data.List.Lemmas.0.List.exists_cons_of_ne_nil.match_1_1... ok
Checking: List.exists_cons_of_ne_nil... ok
Checking: Lean.Meta.ExtractLetsConfig.casesOn... ok
Checking: Lean.Meta.ExtractLetsConfig.noConfusionType... ok
Checking: Lean.Meta.ExtractLetsConfig.noConfusion... ok
Checking: Lean.Meta.ExtractLetsConfig.mk.noConfusion... ok
Checking: right_eq_ite_iff... ok
Checking: List.getLast.eq_2... ok
Checking: List.tail!... ok
Checking: List.tail!_cons... ok
Checking: String.Pos... ok
Checking: _private.Init.Data.Repr.0.instReprSourceInfo.repr.match_1... ok
Checking: instReprRaw... ok
Checking: instReprSourceInfo.repr... ok
Checking: instReprSourceInfo... ok
Checking: Iff.subst... ok
Checking: Std.instToFormatString... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.isNone_pfilter_iff._simp_1_1... ok
Checking: ite_eq_right_iff... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.isNone_pfilter_iff._simp_1_2... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.isNone_pfilter_iff._simp_1_3... ok
Checking: Option.isNone_pfilter_iff... ok
Checking: _private.Init.Data.Array.Basic.0.Array.findSomeRevM?.find.match_1... ok
Checking: _private.Init.Data.Array.Basic.0.Array.findSomeRevM?.find... ok
Checking: Array.findSomeRevM?... ok
Checking: Array.findRevM?... ok
Checking: term__[_]'_... ok
Checking: ST.Prim.Ref.swap... ok
Checking: MonadWithReader.mk.noConfusion... ok
Checking: _private.Init.Data.Bool.0.Bool.exists_bool'.match_1_1... ok
Checking: Bool.exists_bool'... ok
Checking: OptionT.run_bind_lift... FAIL
Checking: Lean.Meta.instInhabitedEtaStructMode... ok
Checking: Lean.Meta.DSimp.instInhabitedConfig.default... ok
Checking: Lean.Meta.Simp.Config.ctorIdx... ok
Checking: List.modifyTailIdx_succ_nil... FAIL
Checking: Lean.termEval_prec_... ok
Checking: EST.tryCatch... ok
Checking: _private.Init.PropLemmas.0.nonempty_prop.match_1_1... ok
Checking: nonempty_prop... ok
Checking: List.decide_forall_mem... ok
Checking: Sum.recOn... ok
Checking: iff_def'... ok
Checking: Decidable.not_iff_not... ok
Checking: _private.Init.PropLemmas.0.Decidable.iff_congr_right._simp_1_1... ok
Checking: Decidable.iff_congr_right... ok
Checking: stx_,+,?... ok
Checking: _private.Init.Meta.Defs.0.Lean.Name.replacePrefix.match_1... ok
Checking: Lean.Name.replacePrefix... ok
Checking: Lean.Parser.Tactic.tacticNomatch_,,... ok
Checking: Option.all_false... ok
Checking: List.size_toArray... ok
Checking: List.getElem_toArray._proof_1... ok
Checking: List.getElem?_toArray... ok
Checking: List.getElem!_toArray... ok
Checking: Lean.SourceInfo.synthetic.sizeOf_spec... ok
Checking: Lean.Parser.Tactic.applyRfl... ok
Checking: OrOp.or... ok
Checking: instHOrOfOrOp... ok
Checking: Option.map_apply... ok
Checking: List.replicateTR.loop.match_1... ok
Checking: List.replicateTR.loop... ok
Checking: List.replicateTR.loop.eq_1... ok
Checking: Lean.Meta.Simp.Config.letToHave... ok
Checking: Lean.instInhabitedSourceInfo... ok
Checking: Decidable.not_and_iff_not_or_not... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.isNone_choice_eq_false._simp_1_1... ok
Checking: Option.isNone_choice_eq_false... ok
Checking: Lean.Meta.Simp.ConfigCtx.ctorIdx... ok
Checking: List.mem_of_ne_of_mem... ok
Checking: List.not_mem_cons_of_ne_of_not_mem... ok
Checking: _private.Init.Data.List.Lemmas.0.List.exists_cons_of_length_pos.match_1_1... ok
Checking: List.exists_cons_of_length_pos... ok
Checking: _private.Init.Data.List.Lemmas.0.List.length_pos_iff_exists_cons.match_1_1... ok
Checking: List.length_pos_iff_exists_cons... ok
Checking: Classical.instNonemptyDecidable... ok
Checking: Option.max_eq_right... ok
Checking: Int.ofNat.noConfusion... ok
Checking: CoeHead.coe... ok
Checking: List.mapTR... ok
Checking: List.mapTR_loop_eq... ok
Checking: List.map_eq_mapTR... FAIL
Checking: Option.toArray_some... ok
Checking: Lean.Parser.Tactic.grindErase... ok
Checking: Lean.Parser.Tactic.grindParam... ok
Checking: Lean.Parser.Tactic.Grind.finishTrace... ok
Checking: Option.pmap_pred_congr... ok
Checking: Option.pmap_congr... ok
Checking: List.getLast!.eq_1... ok
Checking: Append.recOn... ok
Checking: HMod.ctorIdx... ok
Checking: Lean.Parser.Tactic.Grind.sorry... ok
Checking: Div.mk.noConfusion... ok
Checking: List.map_filterMap_some_eq_filter_map_isSome... ok
Checking: Option.pelim_some'... ok
Checking: Lean.Parser.Tactic.tacticSimpa!_... ok
Checking: Option.bind_map_comm... ok
Checking: NatPow.mk.noConfusion... ok
Checking: ForIn.recOn... ok
Checking: dite_cond_congr... ok
Checking: Lean.Parser.Attr.simp... ok
Checking: Nat.Linear.PolyCnstr.recOn... ok
Checking: StateCpsT.runK_bind_get... ok
Checking: Array.eraseIdxIfInBounds... ok
Checking: STWorld.recOn... ok
Checking: Nat.Linear.Poly.norm.eq_1... ok
Checking: Acc.ndrecOn... ok
Checking: instDecidableEqPUnit... ok
Checking: Option.any_true... ok
Checking: CoeFun.coe... ok
Checking: instCoeOutOfCoeFun... ok
Checking: Complement.noConfusion... ok
Checking: ReaderT.instMonadFunctor... ok
Checking: ReaderT.run_monadMap... ok
Checking: Std.Format.nil.sizeOf_spec... ok
Checking: Lean.Parser.Tactic.Conv.zeta... ok
Checking: term_<$>_... ok
Checking: decide_ite... ok
Checking: Option.left_le_max... ok
Checking: Mul.casesOn... ok
Checking: Mul.noConfusionType... ok
Checking: Mul.noConfusion... ok
Checking: Mul.mk.noConfusion... ok
Checking: List.head?_replicate... ok
Checking: Nat.mod_def... ok
Checking: Nat.mod_eq_sub_mul_div... ok
Checking: Nat.mod_eq_sub_div_mul... ok
Checking: Lean.Meta.Simp.defaultMaxSteps... ok
Checking: _auto._@.Init.Data.Array.Basic.3727669890._hygCtx._hyg.5... ok
Checking: _private.Init.Data.Array.Basic.0.Array.back._proof_1... ok
Checking: Array.back... ok
Checking: Lean.Meta.ApplyNewGoals.recOn... ok
Checking: Lean.Meta.Simp.Config.beta... ok
Checking: Bool.bne_not... TIMEOUT
Checking: or_congr_right... ok
Checking: String.toSubstring'... ok
Checking: tacticGet_elem_tactic_trivial... ok
Checking: Except.error.noConfusion... ok
Checking: Except.error.inj... ok
Checking: Lean.Parser.Tactic.rcasesPat.tuple... ok
Checking: Lean.runCmd... ok
Checking: term_^_... ok
Checking: Option.any_eq_true... ok
Checking: List.getLast_singleton... ok
Checking: bne_comm... ok
Checking: List.all_bne'... ok
Checking: Lean.Macro.Exception.error.noConfusion... ok
Checking: instLTUSize... ok
Checking: Option.max_filter_right... ok
Checking: Lean.Grind.CutsatConfig.mk.noConfusion... ok
Checking: Lean.Grind.CutsatConfig.mk.injEq... ok
Checking: tacticDecreasing_trivial_pre_omega... ok
Checking: MProd.ctorIdx... ok
Checking: LawfulBEq.rec... ok
Checking: Bool.not'... ok
Checking: Bool.not'.eq_1... ok
Checking: List.filter_nil... ok
Checking: Option.min_guard_some... ok
Checking: Lean.Macro.Context._sizeOf_1... ok
Checking: Lean.Macro.Context._sizeOf_inst... ok
Checking: Lean.Macro.Context.mk.sizeOf_spec... ok
Checking: HasSubset.Subset... ok
Checking: List.instHasSubset... ok
Checking: List.instDecidableRelSubsetOfDecidableEq... ok
Checking: Bool.and_eq_false_imp._simp_1... ok
Checking: List.isEmpty_eq_false_iff... ok
Checking: List.isEmpty_eq_false_iff._simp_1... ok
Checking: Bool.and_assoc... ok
Checking: List.concat_beq_concat... ok
Checking: Nat.Linear.Poly.denote_eq.eq_1... ok
Checking: UInt64.toBitVec... ok
Checking: UInt64.toFin... ok
Checking: Inv.noConfusionType... ok
Checking: Inv.noConfusion... ok
Checking: term_::_... ok
Checking: ite_then_decide_not_self... ok
Checking: Lean.Parser.Tactic.withUnfoldingAll... ok
Checking: Nat.Linear.ExprCnstr.denote_toPoly... ok
Checking: Monad.ctorIdx... ok
Checking: cond_false... ok
Checking: Bool.cond_false... ok
Checking: USize.repr... ok
Checking: List.nil_append_fun... ok
Checking: termIfThenElse... ok
Checking: HomogeneousPow.noConfusionType... ok
Checking: HomogeneousPow.noConfusion... ok
Checking: HomogeneousPow.mk.noConfusion... ok
Checking: apply_dite... ok
Checking: apply_ite... ok
Checking: Int.NonNeg.recOn... ok
Checking: SDiff.casesOn... ok
Checking: SDiff.noConfusionType... ok
Checking: Bool.and_eq_right_iff_imp... ok
Checking: Std.Commutative.comm... ok
Checking: Lean.Parser.Tactic.Conv.enterPattern... ok
Checking: List.take_succ_cons... FAIL
Checking: List.drop_succ_cons... FAIL
Checking: List.singleton_append... ok
Checking: _private.Init.Data.List.Lemmas.0.List.splitAt_go._simp_1_5... ok
Checking: List.splitAt_go... ok
Checking: HMod.noConfusionType... ok
Checking: HMod.noConfusion... ok
Checking: HMod.mk.noConfusion... ok
Checking: _private.Init.Data.Nat.Div.Basic.0.Nat.one_mod_eq_zero_iff.match_1_1... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.add_one_ne_zero.match_1_1... ok
Checking: Nat.add_one_ne_zero... ok
Checking: _private.Init.Data.Nat.Div.Basic.0.Nat.one_mod_eq_zero_iff._simp_1_3... ok
Checking: Nat.one_mod_eq_zero_iff... ok
Checking: LawfulBEq.recOn... ok
Checking: instAssociativeAnd... ok
Checking: Lean.Parser.Tactic.mstopMacro... ok
Checking: List.extract... ok
Checking: term_*>_... ok
Checking: Lean.Parser.Tactic.Conv.ext... ok
Checking: Nat.mul_mod_right... ok
Checking: List.isEqv_eq... ok
Checking: PULift.down_up... ok
Checking: Decidable.or_congr_right'... ok
Checking: List.length_filterMap_le... ok
Checking: UInt64.ofBitVec.inj... ok
Checking: Lean.Parser.Tactic.Conv.anyGoals... ok
Checking: cond_true... ok
Checking: Bool.cond_true... ok
Checking: Option.toList... ok
Checking: Option.toList_none... ok
Checking: HAdd.noConfusionType... ok
Checking: HXor.recOn... ok
Checking: Int.pow.match_1... ok
Checking: Int.natAbs... ok
Checking: Int.pow... ok
Checking: Option.pbind_some'... ok
Checking: instReprAtomUInt8... ok
Checking: Lean.Syntax.isIdent... ok
Checking: Array.findIdx... ok
Checking: Std.Commutative.recOn... ok
Checking: PSum.recOn... ok
Checking: List.range.loop... ok
Checking: List.range... ok
Checking: List.foldl_append_eq_append... ok
Checking: List.Pairwise.below.casesOn... ok
Checking: dite_iff_right_iff... ok
Checking: List.nil_append... ok
Checking: Lean.Syntax.HygieneInfo... ok
Checking: Lean.TSyntax.getHygieneInfo... ok
Checking: Std.LawfulRightIdentity.right_id... ok
Checking: Thunk.sizeOf_eq... ok
Checking: List.flatMap_singleton'... ok
Checking: List.zipWithM... ok
Checking: List.foldr_flatMap... ok
Checking: BitVec.ofNatLT.eq_1... ok
Checking: Lean.Parser.discrTreeSimpKeyCmd... ok
Checking: List.toArrayImpl... ok
Checking: instToStringProd... ok
Checking: Alternative.mk.noConfusion... ok
Checking: term_+_... ok
Checking: List.idRun_findM?... FAIL
Checking: _private.Init.Prelude.0.Nat.lt_of_le_of_ne.match_1_1... ok
Checking: Nat.lt_of_le_of_ne... ok
Checking: Nat.lt_iff_le_and_ne... ok
Checking: List.range_zero... ok
Checking: Lean.Syntax.getArgs... ok
Checking: unexpandListCons... ok
Checking: CoeOut.ctorIdx... ok
Checking: forIn'_eq_forIn... ok
Checking: Lean.Parser.Tactic.tacticRfl... ok
Checking: Nat.mul_pow... ok
Checking: DoResultPR.return.injEq... ok
Checking: Lean.Parser.Tactic.fail... ok
Checking: Lean.MonadRef.withRef... ok
Checking: Lean.withRef... ok
Checking: Lean.Macro.throwErrorAt... ok
Checking: Fin.land._proof_1... ok
Checking: Fin.land... ok
Checking: Fin.instAndOp... ok
Checking: Nat.Linear.Expr.mulL.noConfusion... ok
Checking: Nat.Linear.Expr.mulL.inj... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.all_filter.match_1_3... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.all_filter.match_1_1... ok
Checking: Option.all_filter... ok
Checking: _private.Init.Data.List.Lemmas.0.List.set_append._simp_1_1... ok
Checking: List.set_append... ok
Checking: exists_eq... ok
Checking: Lean.Parser.Tactic.Conv.unfold... ok
Checking: Function.comp_id... ok
Checking: DoResultPRBC.break.noConfusion... ok
Checking: DoResultPRBC.break.inj... ok
Checking: Bool.le_trans... ok
Checking: ST.Ref.recOn... ok
Checking: Option.ite_none_left_eq_some... ok
Checking: Option.ite_none_left_eq_some._simp_1... ok
Checking: Option.mem_ite_none_left... ok
Checking: List.Sublist.below... ok
Checking: List.Sublist.below.slnil... ok
Checking: List.Sublist.below.cons... ok
Checking: List.Sublist.below.cons₂... ok
Checking: List.Sublist.rec... ok
Checking: List.Sublist.brecOn... ok
Checking: Option.or_self... ok
Checking: Option.or_some... ok
Checking: Option.filter_or_filter... ok
Checking: StateT.run_modifyGet... FAIL
Checking: forall_prop_congr_dom... ok
Checking: exists_eq._simp_1... ok
Checking: Option.ne_none_iff_exists... ok
Checking: Option.bind_assoc... ok
Checking: Lean.Meta.EtaStructMode.all.sizeOf_spec... ok
Checking: or_or_or_comm... ok
Checking: or_or_distrib_right... ok
Checking: Nat.instAntisymmLe... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getLast.match_1.splitter... ok
Checking: List.getLast.eq_def... ok
Checking: Lean.Parser.Tactic.Grind.showCases... ok
Checking: Std.Identity.rec... ok
Checking: Array.findSomeM?._sparseCasesOn_1... ok
Checking: Array.findSomeM?.match_1... ok
Checking: Array.findSomeM?... ok
Checking: Array.findSome?... ok
Checking: Nat.mod_self... ok
Checking: decide_eq_false_iff_not._simp_1... ok
Checking: Classical.not_imp... ok
Checking: Classical.not_imp._simp_1... ok
Checking: List.all_eq_false... ok
Checking: CoeTC.recOn... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.repeatTR.loop... ok
Checking: Nat.repeatTR... ok
Checking: Lean.Syntax.HexNum... ok
Checking: Lean.Syntax.instCoeOutTSyntaxArrayArray... ok
Checking: Repr.rec... ok
Checking: Repr.recOn... ok
Checking: Lean.Parser.Tactic.Grind.next... ok
Checking: UInt32.ofNatTruncate._proof_1... TIMEOUT
Checking: UInt32.ofNatTruncate... ok
Checking: instCoeHTCTOfCoeHTC... ok
Checking: List.tail_append... ok
Checking: List.tail_append_of_ne_nil... ok
Checking: Option.forall... ok
Checking: Option.decidableEqNone... ok
Checking: Nat.Linear.Expr.mulL.injEq... ok
Checking: Array.reduceOption... ok
Checking: _private.Init.Meta.Defs.0.Lean.Name.appendBefore.match_1... ok
Checking: Lean.instQuoteOfCoeHTCTTSyntaxConsSyntaxNodeKindNil... ok
Checking: instCoeOTCOfCoeTC... ok
Checking: Lean.TSyntax.instCoeStrLitTerm... ok
Checking: Lean.Syntax.mkNumLit... ok
Checking: Lean.instQuoteNatNumLitKind... ok
Checking: Lean.TSyntax.instCoeNumLitTerm... ok
Checking: Lean.quoteNameMk... ok
Checking: SDiff.recOn... ok
Checking: List.unzip.match_3... ok
Checking: List.unzip... ok
Checking: List.unzip_nil... ok
Checking: Lean.instQuoteBoolMkStr1.match_1... ok
Checking: Option.guard_apply... ok
Checking: Lean.origin... ok
Checking: List.mem_insert_of_mem... ok
Checking: Lean.Syntax.splitNameLit... ok
Checking: Lean.Parser.Tactic.mkOptConfig... ok
Checking: Lean.Parser.Tactic.appendConfig... ok
Checking: OrElse.rec... ok
Checking: List.replicate_succ'... ok
Checking: List.lex_nil... ok
Checking: _private.Init.Data.List.Lemmas.0.List.foldl_assoc.match_1_1... ok
Checking: Std.Associative.assoc... ok
Checking: List.foldl_assoc... ok
Checking: ExceptT.pure.eq_1... ok
Checking: CoeHTCT.recOn... ok
Checking: Lean.Name.brecOn.eq... ok
Checking: Option.pmap.eq_2... ok
Checking: instDecidableEqPEmpty... ok
Checking: instInhabitedForInStep.default... ok
Checking: Lean.Module.noConfusionType... ok
Checking: Lean.Module.noConfusion... ok
Checking: ExceptCpsT.runCatch... ok
Checking: ExceptCpsT.runCatch_pure... FAIL
Checking: Inv.mk.noConfusion... ok
Checking: List.extract_eq_drop_take... ok
Checking: Nat.Linear.ExprCnstr.mk.inj... ok
Checking: instInhabitedExcept... ok
Checking: List.foldl_flatten... ok
Checking: List.isEmpty_eq_false_iff_exists_mem... ok
Checking: Std.LawfulCommIdentity.recOn... ok
Checking: Lean.Elab.Tactic.Ext.tacticExt1___... ok
Checking: List.head?_nil... ok
Checking: Option.isSome_left_of_isSome_min... ok
Checking: Option.get_min... ok
Checking: Sum.inhabitedLeft... ok
Checking: imp_and... ok
Checking: Lean.Meta.Simp.instInhabitedConfig.default... ok
Checking: Lean.Parser.Tactic.Conv.extractLets... ok
Checking: String.Internal.extract... ok
Checking: PLift.up.injEq... ok
Checking: Prod.map_fst... FAIL
Checking: CoeTC.ctorIdx... ok
Checking: BEq.casesOn... ok
Checking: BEq.noConfusionType... ok
Checking: BEq.noConfusion... ok
Checking: BEq.mk.noConfusion... ok
Checking: Functor.discard... ok
Checking: ULift.noConfusion... ok
Checking: ULift.up.noConfusion... ok
Checking: ULift.up.injEq... ok
Checking: Bool.or_self_left... ok
Checking: term_∣_... ok
Checking: Option.get_none... ok
Checking: Std.LawfulIdentity.toLawfulLeftIdentity... ok
Checking: Std.LawfulIdentity.toLawfulRightIdentity... ok
Checking: Option.get_merge... ok
Checking: Option.filter_le... ok
Checking: Std.LawfulRightIdentity.recOn... ok
Checking: List.get_of_eq... ok
Checking: instCoeOTC... ok
Checking: Nat.recOn... ok
Checking: Lean.Parser.Tactic.Conv.rewrite... ok
Checking: Nat.Linear.PolyCnstr._sizeOf_1... ok
Checking: Nat.Linear.PolyCnstr._sizeOf_inst... ok
Checking: Nat.Linear.PolyCnstr.mk.sizeOf_spec... ok
Checking: instReprAtomChar... ok
Checking: ExceptT.instMonadLiftExcept... ok
Checking: AndThen.andThen... ok
Checking: List.instDecidablePairwise.match_5... ok
Checking: _private.Init.Data.List.Basic.0.List.pairwise_cons.match_1_1... ok
Checking: _private.Init.Data.List.Basic.0.List.pairwise_cons.match_1_3... ok
Checking: List.pairwise_cons... ok
Checking: List.instDecidablePairwise._proof_1... ok
Checking: List.instDecidablePairwise._proof_2... ok
Checking: List.instDecidablePairwise.match_3... ok
Checking: List.instDecidablePairwise._proof_3... ok
Checking: List.instDecidablePairwise... ok
Checking: Except.pure... ok
Checking: _private.Init.PropLemmas.0.exists_comm.match_1_1... ok
Checking: _private.Init.PropLemmas.0.exists_comm.match_1_3... ok
Checking: exists_comm... ok
Checking: PartialEquivBEq.recOn... ok
Checking: Acc.casesOn... ok
Checking: Prod.fst_swap... ok
Checking: Int.decEq.match_1... ok
Checking: Int.decEq._proof_1... ok
Checking: Int.decEq._proof_2... ok
Checking: Int.decEq._proof_3... ok
Checking: Int.decEq._proof_4... ok
Checking: Int.decEq._proof_5... ok
Checking: Int.decEq._proof_6... ok
Checking: Int.decEq... ok
Checking: Int.instDecidableEq... ok
Checking: List.and... ok
Checking: List.and_nil... ok
Checking: Option.map_guard... ok
Checking: _private.Init.Data.List.Lemmas.0.List.forall_getElem._simp_1_1... ok
Checking: List.forall_getElem... ok
Checking: OrOp.casesOn... ok
Checking: Bool.not_beq_self... TIMEOUT
Checking: Lean.binderPred≤_... ok
Checking: List.contains_append... ok
Checking: List.contains_reverse... ok
Checking: EStateM.run... ok
Checking: One.one... ok
Checking: List.flatMapM.match_1... ok
Checking: List.flatMapM.loop... ok
Checking: Classical.imp_iff_left_iff... ok
Checking: Lean.Parser.Attr.extFlat... ok
Checking: Lean.Meta.ExtractLetsConfig.mk.injEq... ok
Checking: Lean.command_code_action... ok
Checking: Decidable.imp_or... ok
Checking: Lean.Name.anonymous.sizeOf_spec... ok
Checking: Lean.MonadQuotation.withFreshMacroScope... ok
Checking: LawfulApplicative.rec... ok
Checking: LawfulApplicative.recOn... ok
Checking: List.filterMap_nil... ok
Checking: Option.map_pmap... ok
Checking: List.flatMap_singleton... FAIL
Checking: MonadReaderOf.ctorIdx... ok
Checking: ReprAtom.recOn... ok
Checking: Option.elim_join... ok
Checking: Bool.coe_false_iff_false... ok
Checking: PSigma.mk.congr_simp... ok
Checking: Option.merge.eq_1... ok
Checking: instNonemptyForall... ok
Checking: Append.noConfusion... ok
Checking: Id.pure_run... FAIL
Checking: USize.decLt... ok
Checking: StateT.run_modify... FAIL
Checking: Lean.Meta.Simp.instInhabitedConfig... ok
Checking: Nat.ctorElimType... ok
Checking: Nat.ctorElim... ok
Checking: Nat.zero.elim... ok
Checking: Nat.Linear.ExprCnstr.toNormPoly.eq_1... ok
Checking: List.map.eq_2... ok
Checking: List.flatten_nil... ok
Checking: List.foldr_hom... ok
Checking: LawfulSingleton.insert_empty_eq... ok
Checking: ite_else_decide_self... ok
Checking: Lean.calcTactic... ok
Checking: Inter.rec... ok
Checking: Inter.casesOn... ok
Checking: Inter.noConfusionType... ok
Checking: Inter.noConfusion... ok
Checking: List.findSomeM?_nil... ok
Checking: Option.or_some'... ok
Checking: List.foldr.eq_def... ok
Checking: Lean.Meta.Simp.Config.autoUnfold... ok
Checking: List.Mem.below... ok
Checking: List.Mem.below.head... ok
Checking: List.Mem.below.tail... ok
Checking: List.Mem.brecOn... ok
Checking: Functor.mapRev... ok
Checking: _private.Init.ByCases.0.dif_eq_if.match_1_1... ok
Checking: dif_eq_if... ok
Checking: Std.Format.text.noConfusion... ok
Checking: Std.Format.text.injEq... ok
Checking: MonadWithReaderOf.recOn... ok
Checking: Option.not_isNone... ok
Checking: PSigma.mk.inj... ok
Checking: instIdempotentOpBoolOr... ok
Checking: Max.ctorIdx... ok
Checking: Bool.coe_true_iff_false... ok
Checking: instSubsingletonPUnit... ok
Checking: Or.intro_right... ok
Checking: Lean.ParserDescr.trailingNode.noConfusion... ok
Checking: term_!=_... ok
Checking: Lean.Grind.Config.splitIndPred... ok
Checking: List.modifyTailIdx_zero... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.isNone._sparseCasesOn_1... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.isNone.match_1... ok
Checking: Lean.Syntax.isNone... ok
Checking: List.findM?_eq_findSomeM?... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.isNatLitAux... ok
Checking: Lean.Syntax.isNatLit?... ok
Checking: OptionT.mk.eq_1... ok
Checking: Option.le.eq_4... ok
Checking: EStateM.Backtrackable.recOn... ok
Checking: List.forall_mem_filter... ok
Checking: Array.uset... ok
Checking: List.mapM.match_1... ok
Checking: List.filterMapM.loop... ok
Checking: ExceptCpsT.run_lift... ok
Checking: termWithout_expected_type_... ok
Checking: OrOp.ctorIdx... ok
Checking: List.zipWith.eq_2... ok
Checking: List.zipWith_nil_right... ok
Checking: Int.negSucc.noConfusion... ok
Checking: Int.negSucc.injEq... ok
Checking: instInhabitedForallOfMonad... ok
Checking: Lean.Syntax.mkSep... ok
Checking: UInt32.toFin... ok
Checking: EStateM.adaptExcept.match_1... ok
Checking: EStateM.adaptExcept... ok
Checking: Classical.not_iff... ok
Checking: Option.isSome_of_isSome_bind... ok
Checking: StateCpsT.runK_bind_pure... FAIL
Checking: Lean.Syntax.node.noConfusion... ok
Checking: Option.recOn... ok
Checking: _private.Init.Data.List.Lemmas.0.List.get_mk_zero.match_1_1... ok
Checking: List.get_mk_zero... ok
Checking: Lean.Parser.Tactic.Grind.grindAdmit... ok
Checking: ForInStep.yield.injEq... ok
Checking: CoeT.mk.noConfusion... ok
Checking: EmptyCollection.recOn... ok
Checking: Lean.Name.mkStr8... ok
Checking: Lean.Macro.Exception.error.sizeOf_spec... ok
Checking: OptionT.run.eq_1... ok
Checking: Lean.Parser.Tactic.Grind.have... ok
Checking: Bool.and_eq_decide... ok
Checking: Or.neg_resolve_right... ok
Checking: Lean.Syntax.TSepArray._sizeOf_1... ok
Checking: Lean.Syntax.TSepArray._sizeOf_inst... ok
Checking: Lean.Syntax.TSepArray.mk.sizeOf_spec... ok
Checking: Array.toArrayLit.eq_1... ok
Checking: Array.findIdx?.loop.eq_def... ok
Checking: AndOp.recOn... ok
Checking: Lean.ParserDescr.sepBy1.sizeOf_spec... ok
Checking: Option.ite_some_none_eq_some... ok
Checking: USize._sizeOf_1... ok
Checking: USize._sizeOf_inst... ok
Checking: USize.ofBitVec.sizeOf_spec... ok
Checking: Bool.eq_true_of_true_le... ok
Checking: Option.not_lt_pfilter... ok
Checking: Std.Format.FlattenBehavior.allOrNone.elim... ok
Checking: ST.Ref.ref... ok
Checking: Lean.MonadQuotation.recOn... ok
Checking: guard... ok
Checking: String.Internal.nextWhile... ok
Checking: Lean.Syntax.decodeStringGap... ok
Checking: Lean.Parser.Tactic.Grind.ring... ok
Checking: Lean.Meta.Rewrite.Config.rec... ok
Checking: Lean.Meta.Rewrite.Config.recOn... ok
Checking: iff_congr... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.ext.match_1_1... ok
Checking: Option.ext... ok
Checking: Lean.Parser.Tactic.Conv.case'... ok
Checking: unexpandIte... ok
Checking: Inter.mk.noConfusion... ok
Checking: Lean.ParserDescr.unicodeSymbol.noConfusion... ok
Checking: List.filterMap_replicate_of_some... ok
Checking: List.filterTR.loop.eq_2... ok
Checking: Except.tryCatch... ok
Checking: instMonadExceptOfExcept... ok
Checking: Option.get_pbind... ok
Checking: List.nil_eq_flatten_iff... ok
Checking: ByteArray.IsValidUTF8.recOn... ok
Checking: ne_of_apply_ne... ok
Checking: Lean.Meta.ApplyConfig.newGoals... ok
Checking: List.mem_map_of_mem... ok
Checking: Prod.recOn... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.not_rel_some_none.match_1_1... ok
Checking: Option.not_rel_some_none... ok
Checking: Lean.instQuoteProdMkStr1... ok
Checking: Bool.bne_right_inj... TIMEOUT
Checking: Nat.Linear.Expr.toPoly.go.eq_3... ok
Checking: Function.comp_apply... ok
Checking: _private.Init.Data.Array.Basic.0.Array.findFinIdx?.loop.eq_def... ok
Checking: _private.Init.Data.Array.Basic.0.Array.findIdx?_loop_eq_map_findFinIdx?_loop_val... ok
Checking: Array.findIdx?_eq_map_findFinIdx?_val... ok
Checking: Lean.Macro.Methods.expandMacro?... ok
Checking: Lean.Macro.expandMacro?... ok
Checking: MonadFinally.rec... ok
Checking: MonadFinally.casesOn... ok
Checking: MonadFinally.noConfusionType... ok
Checking: MonadFinally.noConfusion... ok
Checking: MonadFinally.mk.noConfusion... ok
Checking: instNonemptyProd... ok
Checking: ShiftLeft.noConfusionType... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getLast?_append._simp_1_1... ok
Checking: List.getLast?_append... ok
Checking: Lean.Syntax.instCoeIdentTSyntaxConsSyntaxNodeKindMkStr4Nil... ok
Checking: Lean.Parser.Tactic.Conv.conv_<;>_... ok
Checking: Option.bind_fun_some... ok
Checking: List.head_append_right._proof_1... ok
Checking: List.head_append_right... ok
Checking: Lean.Parser.Category.rintroPat... ok
Checking: List.map_flatten... ok
Checking: _private.Init.Data.List.Lemmas.0.List.ext_getElem?.match_1_1... ok
Checking: List.ext_getElem?... ok
Checking: Nat.le_of_not_lt... ok
Checking: List.ext_getElem... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getElem_set_self.match_1_1... ok
Checking: List.getElem_set_self... ok
Checking: List.getElem_set... ok
Checking: List.set_getElem_self... ok
Checking: Bool.bne_self_left... TIMEOUT
Checking: DoResultBC.ctorElimType... ok
Checking: DoResultBC.ctorElim... ok
Checking: DoResultBC.break.elim... ok
Checking: Lean.Syntax.hasArgs... ok
Checking: Lean.version.getSpecialDesc... ok
Checking: MonadLiftT.ctorIdx... ok
Checking: Lean.Parser.Tactic.tacticRwa__... ok
Checking: Option.or_assoc... ok
Checking: Option.instAssociativeOr... ok
Checking: Option.or_eq_none_iff... ok
Checking: CoeHTC.noConfusion... ok
Checking: CoeHTC.mk.noConfusion... ok
Checking: Option.map_bind... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getElem?_of_mem.match_1_1... ok
Checking: List.getElem?_of_mem... ok
Checking: left_eq_dite_iff... ok
Checking: Option.toArray_none... ok
Checking: List.isSuffixOf... ok
Checking: List.isSuffixOf.eq_1... ok
Checking: Lean.Parser.Tactic.Conv.nestedTactic... ok
Checking: Option.eq_some_of_filter_eq_some... ok
Checking: ForM.noConfusionType... ok
Checking: ForM.noConfusion... ok
Checking: Nat.instTransLeLt... ok
Checking: DoResultSBC.continue.inj... ok
Checking: Lean.Parser.Tactic.repeat1'... ok
Checking: PULift.ctorIdx... ok
Checking: Nat.one_ne_zero... ok
Checking: Bool.true_eq... ok
Checking: List.contains_replicate... ok
Checking: List.map_singleton... ok
Checking: Option.getD_choice... ok
Checking: List.unzip_cons... FAIL
Checking: List.cons_removeAll... ok
Checking: List.filter_removeAll_filter... ok
Checking: OptionT.tryCatch... ok
Checking: OptionT.instMonadExceptOfPUnit... ok
Checking: List.flatMap_map... ok
Checking: Id.run_map... FAIL
Checking: Subtype.mk.injEq... ok
Checking: PSigma.Lex.recOn... ok
Checking: Lean.Parser.Tactic.Grind.showTrue... ok
Checking: List.intersperse_cons₂... ok
Checking: Bool.instDecidableExistsOfDecidablePred.match_3... ok
Checking: Nat.mul_add_mod_self_left... ok
Checking: Subsingleton.recOn... ok
Checking: OrElse.recOn... ok
Checking: Bool.xor_assoc... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.sub_lt_sub_left.match_1_1... ok
Checking: Nat.sub_lt_sub_left... ok
Checking: Std.Format.brecOn.eq... ok
Checking: instSTWorldEST... ok
Checking: _private.Init.Data.List.Basic.0.List.isPrefixOf.match_1.splitter... ok
Checking: _private.Init.Data.List.Basic.0.List.isPrefixOf.match_1.eq_2... ok
Checking: List.isPrefixOf.eq_def... ok
Checking: List.isPrefixOf.eq_2... ok
Checking: Option.max_filter_left... ok
Checking: _private.Init.Data.List.Lemmas.0.List.length_filter_eq_length_iff._simp_1_1... ok
Checking: Nat.lt_succ_iff... ok
Checking: _private.Init.Data.List.Lemmas.0.List.length_filter_eq_length_iff._simp_1_2... ok
Checking: List.length_filter_eq_length_iff... ok
Checking: Lean.getGithash... ok
Checking: Lean.githash... ok
Checking: instSTWorldST... ok
Checking: Lean.Parser.Tactic.Grind.grind_ref__1... ok
Checking: Lean.doElemWhile_Do_... ok
Checking: Bool.cond_decide... ok
Checking: Sum.nonemptyLeft... ok
Checking: Std.Total.recOn... ok
Checking: ExceptT.instMonad.eq_1... ok
Checking: Lean.Meta.Rewrite.Config.transparency... ok
Checking: HShiftLeft.rec... ok
Checking: Nat.Linear.instBEqExpr... ok
Checking: List.concat_inj_left... ok
Checking: Lean.Parser.commandSeal__... ok
Checking: StateCpsT.instMonadLiftOfMonad... ok
Checking: StateCpsT.instLawfulMonadLiftOfLawfulMonad... ok
Checking: Bool.true.sizeOf_spec... ok
Checking: Substring.Raw.mk.sizeOf_spec... ok
Checking: Std.Refl.refl... ok
Checking: List.find?_nil... ok
Checking: Lean.Parser.Tactic.Grind.casesTrace... ok
Checking: or_self_right... ok
Checking: Lean.Parser.Tactic.showTerm... ok
Checking: _private.Init.System.ST.0.ST.Prim.Ref.modifyGetUnsafe.match_1... ok
Checking: ST.Prim.Ref.modifyGet... ok
Checking: ST.Ref.modifyGet... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.succ_pred_eq_of_ne_zero.match_1_1... ok
Checking: Nat.succ_pred_eq_of_ne_zero... ok
Checking: BitVec.ofNat.eq_1... ok
Checking: Bool.cond_self... ok
Checking: Fin.shiftRight._proof_1... ok
Checking: Fin.shiftRight... ok
Checking: Fin.instShiftRight... ok
Checking: Fin.instShiftLeft... ok
Checking: Nat.mul_le_mul_right_iff... ok
Checking: Std.Antisymm.rec... ok
Checking: outOfBounds_eq_default... ok
Checking: PProd._sizeOf_1... ok
Checking: PProd._sizeOf_inst... ok
Checking: PProd.mk.sizeOf_spec... ok
Checking: instDecidableEqSum.decEq.match_1... ok
Checking: instDecidableEqSum.decEq._proof_1... ok
Checking: instDecidableEqSum.decEq._proof_3... ok
Checking: instDecidableEqSum.decEq._proof_4... ok
Checking: instDecidableEqSum.decEq._proof_5... ok
Checking: instDecidableEqSum.decEq._proof_2... ok
Checking: instDecidableEqSum.decEq._proof_6... ok
Checking: instDecidableEqSum.decEq... ok
Checking: instDecidableEqSum... ok
Checking: _private.Init.Prelude.0.Lean.withRef?.match_1... ok
Checking: Lean.withRef?... ok
Checking: List.foldr_nil... ok
Checking: Option.elim_none... FAIL
Checking: Lean.Grind.Config.ac... ok
Checking: or_self_iff... ok
Checking: Lean.Parser.Tactic.Grind.grind_filterGen≥_... ok
Checking: AndThen.recOn... ok
Checking: ReaderT.run_seqLeft... FAIL
Checking: Lean.version.specialDesc... ok
Checking: Lean.versionStringCore... ok
Checking: Lean.versionString... ok
Checking: HasSubset.ctorIdx... ok
Checking: GetElem.rec... ok
Checking: GetElem.recOn... ok
Checking: CoeOut.recOn... ok
Checking: Lean.instQuoteBoolMkStr1... ok
Checking: Nat.instAssociativeHMul... ok
Checking: _private.Init.Data.List.Lemmas.0.List.tailD_map._simp_1_1... ok
Checking: List.tailD_map... ok
Checking: Array.toListAppend... ok
Checking: Nat.lt_pred_of_succ_lt... ok
Checking: Classical.imp_iff_right_iff... ok
Checking: term_>=_... ok
Checking: Option.filter_beq_self... ok
Checking: Lean.Parser.Tactic.tacticLetI__... ok
Checking: _private.Init.While.0.Lean.Loop.forIn.loop... ok
Checking: Lean.Loop.forIn... ok
Checking: Lean.instForInLoopUnit... ok
Checking: Lean.Syntax.ident.injEq... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getElem?_eq_some_iff.match_1_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getElem?_eq_some_iff.match_1_3... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getElem?_eq_some_iff._simp_1_5... ok
Checking: List.getElem?_eq_some_iff... ok
Checking: List.getElem_of_getElem?... ok
Checking: Neg.ctorIdx... ok
Checking: _private.Init.Data.List.Lemmas.0.List.foldr_assoc.match_1_1... ok
Checking: List.foldr_assoc... ok
Checking: ExceptT.seq_eq... FAIL
Checking: StateRefT'.instMonadFunctor... ok
Checking: Option.join_join... ok
Checking: Lean.Parser.Tactic.tacticLet__... ok
Checking: Nat.toSubDigitsAux... ok
Checking: Nat.toSubDigits... ok
Checking: Lean.Parser.Tactic.Conv.reduce... ok
Checking: List.rightpad... ok
Checking: List.rightpad.eq_1... ok
Checking: Sum.inr.injEq... ok
Checking: List.sizeOf_lt_of_mem... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.pow_le_pow_left.match_1_1... ok
Checking: Nat.mul_le_mul... ok
Checking: Nat.pow_le_pow_left... ok
Checking: and_congr_left_iff... ok
Checking: Array.mk.sizeOf_spec... ok
Checking: List.zip_cons_cons... ok
Checking: Nat.succ_ne_succ_iff... ok
Checking: not_not_em... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getLast_dropLast.match_1... ok
Checking: List.getLast_dropLast._proof_3... ok
Checking: _private.Init.Data.List.Lemmas.0.List.length_dropLast.match_1_1... ok
Checking: List.length_dropLast... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getElem_dropLast.match_1_1... ok
Checking: List.getElem_dropLast... ok
Checking: List.getLast_dropLast... ok
Checking: List.mapTR.loop.eq_2... FAIL
Checking: Lean.Grind.CutsatConfig.ctorIdx... ok
Checking: SDiff.sdiff... ok
Checking: Lean.Parser.Tactic.Conv.change... ok
Checking: Lean.Meta.Simp.Config.implicitDefEqProofs... ok
Checking: LawfulSingleton.casesOn... ok
Checking: Nat.Linear.monomialToExpr... ok
Checking: Nat.Linear.Poly.toExpr.go... ok
Checking: HasEquiv.casesOn... ok
Checking: Option.isSome_or... ok
Checking: exists_or_eq_left'... ok
Checking: List.flatMap_replicate... ok
Checking: Lean.unifConstraint... ok
Checking: Lean.unifConstraintElem... ok
Checking: Lean.Parser.Tactic.tacticApply_mod_cast_... ok
Checking: Bool.xor_right_inj... ok
Checking: left_eq_ite_iff... ok
Checking: ForInStep.value.match_1... ok
Checking: ForInStep.value... ok
Checking: ForInStep.value_done... ok
Checking: or_iff_left... ok
Checking: term_/\_... ok
Checking: GetElem?.ctorIdx... ok
Checking: MonadControl.stM... ok
Checking: MonadControl.restoreM... ok
Checking: Or.recOn... ok
Checking: instCoeHTCT... ok
Checking: Option.guard_or_guard... ok
Checking: List.IsPrefix... ok
Checking: List.IsPrefix.eq_1... ok
Checking: Fin.modn.match_1... ok
Checking: List.range'_one... ok
Checking: String.Pos.Raw.recOn... ok
Checking: Min.ctorIdx... ok
Checking: Nat.Linear.Expr.inc... ok
Checking: Nat.Linear.Expr.of_cancel_le... ok
Checking: Nat.Linear.Expr.of_cancel_lt... FAIL
Checking: _private.Init.PropLemmas.0.or_rotate._simp_1_2... ok
Checking: _private.Init.PropLemmas.0.or_rotate._simp_1_1... ok
Checking: or_rotate... ok
Checking: Lean.Macro.instMonadQuotationMacroM... ok
Checking: Lean.Parser.Tactic.Conv.skip... ok
Checking: Fin.decLt... ok
Checking: LawfulMonadLiftT.recOn... ok
Checking: unexpandTSepArray... ok
Checking: Std.Format.tag.sizeOf_spec... ok
Checking: PSigma.ctorIdx... ok
Checking: Lean.Meta.LiftLetsConfig.casesOn... ok
Checking: Option.instForIn'InferInstanceMembership.match_3... ok
Checking: Option.instForIn'InferInstanceMembership... ok
Checking: HomogeneousPow.recOn... ok
Checking: List.foldr_map_hom... ok
Checking: Lean.Parser.Tactic.tacticSimp_all?!_... ok
Checking: Int.toNat.match_1... ok
Checking: Int.toNat... ok
Checking: Option.filter_some_eq_some... ok
Checking: ReaderT.run_map... FAIL
Checking: Lean.Grind.Config.lia... ok
Checking: Option.pbind_map... ok
Checking: Option.pfilter_guard._proof_1... ok
Checking: right_eq_ite_iff._simp_1... ok
Checking: Option.pfilter_guard... ok
Checking: _private.Init.Core.0.instSubsingletonProd.match_1... ok
Checking: instSubsingletonProd... ok
Checking: Option.map_id_fun... ok
Checking: PULift.up_down... ok
Checking: Lean.Syntax.getSepArgs... ok
Checking: List.intersperseTR.match_1... ok
Checking: List.intersperseTR... ok
Checking: Task.pure.noConfusion... ok
Checking: GetElem.casesOn... ok
Checking: LawfulFunctor.casesOn... ok
Checking: _private.Init.Prelude.0.Lean.Syntax.matchesLit.match_1... ok
Checking: Lean.Syntax.matchesLit... ok
Checking: PULift.up.inj... ok
Checking: List.head?_replace... ok
Checking: Bool.or_right_comm... ok
Checking: List.zip.eq_1... ok
Checking: Option.all_merge... ok
Checking: String.Internal.capitalize... ok
Checking: Lean.Name.capitalize... ok
Checking: SeqLeft.mk.noConfusion... ok
Checking: Bool.cond_then_self... ok
Checking: DecidableLE... ok
Checking: List.instLawfulIdentityHAppendNil... ok
Checking: PProd.recOn... ok
Checking: Option.reflBEq_iff... ok
Checking: EST.Out._sizeOf_1... ok
Checking: EST.Out._sizeOf_inst... ok
Checking: EST.Out.error.sizeOf_spec... ok
Checking: Option.map.eq_2... ok
Checking: Nat.lt_add_of_pos_left... ok
Checking: List.lookup_nil... ok
Checking: OptionT.ext_iff... ok
Checking: Option.isNone_eq_false_iff... ok
Checking: Option.lt.eq_1... ok
Checking: Lean.Parser.Tactic.config... ok
Checking: Pow.ctorIdx... ok
Checking: List.idRun_foldrM... FAIL
Checking: AndOp.mk.noConfusion... ok
Checking: Empty.elim... ok
Checking: _private.Init.Meta.Defs.0.Lean.Meta.Occurrences.contains.match_1... ok
Checking: Lean.Meta.Occurrences.contains... ok
Checking: _private.Init.Data.List.BasicAux.0.List.sizeOf_get.match_1_1... ok
Checking: List.sizeOf_get... ok
Checking: HAndThen.ctorIdx... ok
Checking: dite_then_true... ok
Checking: List.beq_nil_cons... ok
Checking: List.beq.eq_2... ok
Checking: Lean.Meta.Omega.OmegaConfig._sizeOf_1... ok
Checking: Lean.Meta.Omega.OmegaConfig._sizeOf_inst... ok
Checking: Lean.Meta.Omega.OmegaConfig.mk.sizeOf_spec... ok
Checking: ExceptT.run_pure... FAIL
Checking: ULift.down... ok
Checking: instReprULift... ok
Checking: List.find?_cons... ok
Checking: instToStringRaw... ok
Checking: Lean.Parser.Tactic.Grind.grind_filter.quot... ok
Checking: Lean.ParserDescr.const.noConfusion... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.eq_zero_of_add_eq_zero.match_1_1... ok
Checking: Nat.eq_zero_of_add_eq_zero... ok
Checking: Nat.eq_zero_of_add_eq_zero_left... ok
Checking: Lean.Parser.Tactic.constructor... ok
Checking: Fin.castLE._proof_1... ok
Checking: Fin.castLE... ok
Checking: Fin.castAdd... ok
Checking: Lean.Meta.Simp.Config.maxSteps... ok
Checking: Lean.Meta.Simp.Config.memoize... ok
Checking: Lean.Meta.Simp.Config.singlePass... ok
Checking: Lean.Meta.Simp.Config.zeta... ok
Checking: Lean.Meta.Simp.Config.etaStruct... ok
Checking: Lean.Meta.Simp.Config.iota... ok
Checking: Lean.Meta.Simp.Config.decide... ok
Checking: Lean.Meta.Simp.Config.dsimp... ok
Checking: Lean.Meta.Simp.Config.failIfUnchanged... ok
Checking: Lean.Meta.Simp.Config.unfoldPartialApp... ok
Checking: Lean.Meta.Simp.Config.zetaDelta... ok
Checking: Lean.Meta.Simp.Config.index... ok
Checking: Lean.Meta.Simp.Config.zetaUnused... ok
Checking: Lean.Meta.Simp.Config.catchRuntime... ok
Checking: Lean.Meta.Simp.Config.zetaHave... ok
Checking: Lean.Meta.Simp.Config.congrConsts... ok
Checking: Lean.Meta.Simp.Config.bitVecOfNat... ok
Checking: Lean.Meta.instReprConfig_1.repr... ok
Checking: Lean.Syntax.findAux... ok
Checking: Lean.Syntax.find?... ok
Checking: CoeHTCT.ctorIdx... ok
Checking: PSigma.lexNdep... ok
Checking: _private.Init.WF.0.PSigma.lexNdepWf.match_1_1... ok
Checking: PSigma.lexAccessible... ok
Checking: PSigma.lexNdepWf... ok
Checking: _private.Init.Data.List.Basic.0.List.intersperse_eq_intersperseTR.match_1_5... ok
Checking: List.intersperse_eq_intersperseTR... ok
Checking: Option.elim_some... FAIL
Checking: List.isPrefixOf.eq_3... ok
Checking: Lean.Meta.Occurrences.all.elim... ok
Checking: Lean.Meta.Occurrences.pos.elim... ok
Checking: Lean.Meta.Occurrences.noConfusionType... ok
Checking: Lean.Meta.Occurrences.noConfusion... ok
Checking: Lean.Meta.Occurrences.neg.noConfusion... ok
Checking: Lean.Macro.Methods._sizeOf_1... ok
Checking: Lean.Macro.Methods._sizeOf_inst... ok
Checking: Lean.Macro.Methods.mk.sizeOf_spec... ok
Checking: Nat.sub_mul... ok
Checking: Classical.or_iff_not_imp_right... ok
Checking: Bool.ite_eq_cond_iff... ok
Checking: Option.SomeLtNone.le.match_1... ok
Checking: exists_or_eq_right... ok
Checking: LawfulMonadLift.recOn... ok
Checking: Lean.Parser.Tactic.simpArith... ok
Checking: Std.Format.append.noConfusion... ok
Checking: Std.Format.append.injEq... ok
Checking: Lean.RArray.size... ok
Checking: have_body_congr_dep'... ok
Checking: Option.merge_some_some... ok
Checking: DoResultBC._sizeOf_1... ok
Checking: DoResultBC._sizeOf_inst... ok
Checking: DoResultBC.continue.sizeOf_spec... ok
Checking: Lean.Syntax.CharLit... ok
Checking: Lean.Syntax.mkCharLit... ok
Checking: Lean.instQuoteCharCharLitKind... ok
Checking: ne_false_of_self... ok
Checking: true_ne_false... ok
Checking: List.eraseDupsBy... ok
Checking: List.eraseDupsBy_nil... ok
Checking: Lean.Syntax.Prec... ok
Checking: Lean.TSyntax.instCoeNumLitPrec... ok
Checking: StateT.run_bind_lift... FAIL
Checking: Option.min_filter_left... ok
Checking: termDepIfThenElse... ok
Checking: List.zipWith.eq_1... FAIL
Checking: Lean.Parser.Tactic.simpAutoUnfold... ok
Checking: Lean.instCoeSyntaxTSyntaxConsSyntaxNodeKindMkStr1Nil... ok
Checking: instDecidableEqEmpty... ok
Checking: Std.ToFormat.recOn... ok
Checking: prioLow... ok
Checking: Lean.Name.appendBefore... ok
Checking: MProd.recOn... ok
Checking: Nat.Linear.Expr.toPoly.go.eq_1... ok
Checking: Except.error.elim... ok
Checking: List.replace_cons_self... ok
Checking: List.replace_replicate_self... ok
Checking: Lean.Parser.Category.rawStx... ok
Checking: ReflBEq.rec... ok
Checking: List.head_map... ok
Checking: Bool.or'_eq_or... ok
Checking: List.foldl_map_hom... ok
Checking: Bool.exists_bool... ok
Checking: _private.Init.Data.List.Basic.0.List.length.match_1.splitter... ok
Checking: List.length.eq_def... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.join_eq_none_iff.match_1_1... ok
Checking: Option.join_eq_none_iff... ok
Checking: Applicative.ctorIdx... ok
Checking: Nat.beq.eq_3... ok
Checking: Nat.lt_add_left... ok
Checking: Bool.eq_not... ok
Checking: Lean.Grind.NoopConfig.toConfig... ok
Checking: Nat.eq_or_lt_of_not_lt... ok
Checking: Nat.Linear.Poly.norm.go.eq_def... ok
Checking: Lean.defaultMaxRecDepth... ok
Checking: List.mapMonoM... ok
Checking: Array.getMax?... ok
Checking: List.leftpad.eq_1... ok
Checking: List.isEqv_nil_nil... ok
Checking: Array.mapIdxM... ok
Checking: exists_or_eq_right'... ok
Checking: Array.instLT... ok
Checking: Std.Asymm.rec... ok
Checking: Std.Asymm.casesOn... ok
Checking: Nat.sub_eq... ok
Checking: Bool.cond_true_right... ok
Checking: Array.filterSepElems... ok
Checking: Lean.Parser.Tactic.tacticLet'__... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.sub_one_ne_self.match_1_1... ok
Checking: Nat.sub_one_ne_self... ok
Checking: MonadExcept.orElse... ok
Checking: MonadExcept.instOrElse... ok
Checking: instReprAtomBool... ok
Checking: instInhabitedProd... ok
Checking: List.filterMap_some_fun... ok
Checking: PLift._sizeOf_1... ok
Checking: PLift._sizeOf_inst... ok
Checking: PLift.up.sizeOf_spec... ok
Checking: MonadEval.casesOn... ok
Checking: MonadEval.noConfusionType... ok
Checking: MonadEval.noConfusion... ok
Checking: MonadEval.mk.noConfusion... ok
Checking: Lean.NameGenerator.ctorIdx... ok
Checking: Nat.one_lt_two... ok
Checking: PEmpty.recOn... ok
Checking: List.Sublist.casesOn... ok
Checking: Std.Format.tag.inj... ok
Checking: EquivBEq.casesOn... ok
Checking: HXor.noConfusion... ok
Checking: HXor.mk.noConfusion... ok
Checking: Lean.RArray.getImpl.eq_1... ok
Checking: unexpandMkArray2... ok
Checking: List.map_filter_eq_foldr... ok
Checking: BitVec.toNat.eq_1... ok
Checking: Lean.SourceInfo.synthetic.noConfusion... ok
Checking: Nat.add_mul_mod_self_right... ok
Checking: Membership.noConfusion... ok
Checking: List.mem_insert_self... ok
Checking: Lean.doElemRepeat_... ok
Checking: _private.Init.Data.Array.Basic.0.Array.eraseReps.match_1... ok
Checking: Array.eraseReps... ok
Checking: Function.comp.eq_1... ok
Checking: Bool.false_beq... TIMEOUT
Checking: Fin.castSucc... ok
Checking: List.cons_eq_cons... ok
Checking: Lean.Parser.Tactic.tacticHave__... ok
Checking: List.mem_singleton... ok
Checking: Empty.casesOn... ok
Checking: instReprEmpty.match_1... ok
Checking: Option.min_le_right... ok
Checking: EStateM.run'... ok
Checking: List.eq_append_cons_of_mem... ok
Checking: decPropToBool... ok
Checking: left_iff_dite_iff... ok
Checking: Lean.Syntax.mkNameLit... ok
Checking: ST.Ref.swap... ok
Checking: Lean.Meta.Rewrite.Config.casesOn... ok
Checking: Lean.Meta.Rewrite.Config.noConfusionType... ok
Checking: Lean.Parser.Tactic.mhaveMacro... ok
Checking: Coe.rec... ok
Checking: Coe.casesOn... ok
Checking: Coe.noConfusionType... ok
Checking: List.take_nil... ok
Checking: List.replace_take... ok
Checking: List.isPrefixOf_cons₂... ok
Checking: Std.Format.group.injEq... ok
Checking: Lean.Grind.Config.splitImp... ok
Checking: Bool.and_xor_distrib_right... TIMEOUT
Checking: Lean.RArray.ctorIdx... ok
Checking: Lean.RArray.ctorElimType... ok
Checking: Lean.RArray.ctorElim... ok
Checking: Lean.RArray.branch.elim... ok
Checking: Fin.getElem!_fin... FAIL
Checking: Lean.ParserDescr.brecOn.eq... ok
Checking: Substring.Raw.ctorIdx... ok
Checking: Lean.MacroScopesView.recOn... ok
Checking: EStateM.instInhabitedResult... ok
Checking: _private.Init.Data.List.Lemmas.0.List.singleton_eq_append_iff._simp_1_1... ok
Checking: List.singleton_eq_append_iff... ok
Checking: USize.decEq.match_1... ok
Checking: USize.decEq._proof_1... ok
Checking: USize.decEq._proof_2... ok
Checking: USize.decEq... ok
Checking: instDecidableEqUSize... ok
Checking: Prod.RProd.casesOn... ok
Checking: Prod.RProdSubLex... ok
Checking: Option.getD_none... ok
Checking: have_congr'... ok
Checking: Lean.Parser.Tactic.delta... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.pred_lt_self.match_1_1... ok
Checking: Nat.pred_lt_self... ok
Checking: MonadWithReader.ctorIdx... ok
Checking: List.or_nil... ok
Checking: Sigma.noConfusionType... ok
Checking: Sigma.noConfusion... ok
Checking: BitVec.ofFin.sizeOf_spec... ok
Checking: Bool.bne_left_inj... TIMEOUT
Checking: Bool.xor_left_inj... ok
Checking: Lean.Grind.Config.inj... ok
Checking: List.append_left_inj... ok
Checking: List.append_left_eq_self... ok
Checking: List.self_eq_append_left... ok
Checking: Min.rec... ok
Checking: Dvd.noConfusion... ok
Checking: Lean.Parser.Tactic.Grind.grind.quot... ok
Checking: Lean.Macro.resolveNamespace... ok
Checking: List.flatMap.eq_1... ok
Checking: Lean.Parser.Tactic.Conv.clear... ok
Checking: Lean.binderPred⊆_... ok
Checking: term_≥_... ok
Checking: Substring.Raw.Internal.prev... ok
Checking: CoeOTC.recOn... ok
Checking: Lean.MonadRef.ctorIdx... ok
Checking: Option.getM_none... FAIL
Checking: Lean.Parser.Tactic.mvcgenMacro... ok
Checking: Lean.Parser.Tactic.Grind.grind_filterGen=_... ok
Checking: Lean.Syntax.decodeRawStrLitAux... ok
Checking: Id.run_seqLeft... FAIL
Checking: Option.isEqSome.eq_2... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getLast?_replicate._simp_1_1... ok
Checking: List.getLast?_replicate... ok
Checking: ForIn.noConfusionType... ok
Checking: ForIn.noConfusion... ok
Checking: Nat.lt_one_iff... ok
Checking: List.all_cons... ok
Checking: MonadFinally.recOn... ok
Checking: Option.filter_eq_bind... ok
Checking: Bool.or_not_self... ok
Checking: MonadLift.casesOn... ok
Checking: MonadLift.noConfusionType... ok
Checking: Lean.Parser.Tactic.massumptionMacro... ok
Checking: UInt32._sizeOf_1... ok
Checking: UInt32._sizeOf_inst... ok
Checking: Char._sizeOf_1... ok
Checking: Char._sizeOf_inst... ok
Checking: Char.mk.sizeOf_spec... ok
Checking: List.erase.eq_2... ok
Checking: Array.findSome!... ok
Checking: List.cons_lex_nil... ok
Checking: Or.by_cases... ok
Checking: Lean.Parser.Tactic.simpAllArith... ok
Checking: Lean.Meta.instBEqTransparencyMode.beq... ok
Checking: Lean.Meta.instBEqTransparencyMode... ok
Checking: Fin.coe_neg... TIMEOUT
Checking: Lean.Macro.Methods.noConfusion... ok
Checking: Fin.succ.match_1... ok
Checking: Fin.succ... ok
Checking: Lean.Meta.LiftLetsConfig.noConfusionType... ok
Checking: Lean.Meta.LiftLetsConfig.noConfusion... ok
Checking: Lean.Meta.LiftLetsConfig.mk.noConfusion... ok
Checking: Lean.Meta.LiftLetsConfig.mk.inj... ok
Checking: Lean.Parser.Tactic.right... ok
Checking: List.map_cons... FAIL
Checking: Lean.Meta.Rewrite.Config.offsetCnstrs... ok
Checking: Lean.TSyntax.instCoeCharLitTerm... ok
Checking: ST.instNonemptyRef... ok
Checking: Lean.Meta.Occurrences.pos.noConfusion... ok
Checking: Lean.Meta.Occurrences.pos.injEq... ok
Checking: unexpandListNil... ok
Checking: USize.ofBitVec.inj... ok
Checking: ST.Ref.ctorIdx... ok
Checking: List.one_lt_length_of_tail_ne_nil... ok
Checking: Option.isSome_eq_isSome... ok
Checking: Lean.Internal.liftCoeM... ok
Checking: Option.merge_max... ok
Checking: Option.instLawfulIdentityMaxNone... ok
Checking: Nat.ne_of_lt'... ok
Checking: Nat.add_one_ne_add_one_iff... ok
Checking: Lean.Parser.Tactic.Grind.anyGoals... ok
Checking: ST.Out.mk.noConfusion... ok
Checking: ST.Out.mk.injEq... ok
Checking: ULift._sizeOf_1... ok
Checking: ULift._sizeOf_inst... ok
Checking: ULift.up.sizeOf_spec... ok
Checking: Option.isSome.eq_2... ok
Checking: Nat.xor... ok
Checking: Fin.xor._proof_1... ok
Checking: Fin.xor... ok
Checking: Fin.instXorOp... ok
Checking: id.eq_1... ok
Checking: List.filterMap_some... ok
Checking: Bool.not_ite_eq_false_eq_false... ok
Checking: Nat.Linear.PolyCnstr.isUnsat.eq_1... ok
Checking: Bool.eq_self_and... ok
Checking: term_⊇_... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.eq_some_of_isSome.match_1_1... ok
Checking: Option.eq_some_of_isSome... ok
Checking: _private.Init.Data.List.Lemmas.0.List.length_pos_iff_exists_mem.match_1_1... ok
Checking: List.length_pos_iff_exists_mem... ok
Checking: _private.Init.Data.List.Lemmas.0.List.mem_of_getElem?.match_1_1... ok
Checking: List.mem_of_getElem?... ok
Checking: CoeOut.noConfusionType... ok
Checking: CoeOut.noConfusion... ok
Checking: List.eq_getElem_of_length_eq_one._proof_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.eq_getElem_of_length_eq_one.match_1_1... ok
Checking: List.eq_getElem_of_length_eq_one... ok
Checking: List.length_tail... ok
Checking: Nat.sub_add_eq... ok
Checking: Nat.sub_one_sub_lt_of_lt... ok
Checking: List.getElem_reverse._proof_1... ok
Checking: Nat.add_lt_of_lt_sub... ok
Checking: List.getElem_tail._proof_1... ok
Checking: List.getElem_tail... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.le_pred_iff_lt.match_1_1... ok
Checking: Nat.le_pred_iff_lt... ok
Checking: Nat.le_pred_of_lt... ok
Checking: Nat.le_sub_one_of_lt... ok
Checking: List.getElem?_reverse... ok
Checking: List.getElem_reverse... ok
Checking: List.tail_reverse... ok
Checking: Bool.and_not_eq_right_iff_and... ok
Checking: List.recOn... ok
Checking: Option.getD_or... ok
Checking: List.headD.eq_2... ok
Checking: Exists.recOn... ok
Checking: Option.elimM.eq_1... FAIL
Checking: Option.mapA... ok
Checking: Int.ofNat.inj... ok
Checking: List.replace_append_left... ok
Checking: Option.isSome_ite'._simp_1... ok
Checking: Option.get_ite'... ok
Checking: PSum.nonemptyRight... ok
Checking: List.map_eq_cons_iff'... ok
Checking: Nat.pred_zero... ok
Checking: List.instForM... ok
Checking: Bool.true.elim... ok
Checking: Lean.Parser.Tactic.Grind.casesNext... ok
Checking: _private.Init.Syntax.0.Lean.Syntax.setArgs.match_1... ok
Checking: Array.setIfInBounds... ok
Checking: Lean.Syntax.setArg... ok
Checking: Lean.Parser.checkTactic... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getElem_singleton.match_1_1... ok
Checking: List.getElem_singleton... ok
Checking: Lean.maxRecDepthErrorMessage... ok
Checking: Lean.Macro.withIncRecDepth... ok
Checking: Lean.expandMacros... ok
Checking: Lean.TSyntax.getNat... ok
Checking: Lean.evalPrio... ok
Checking: Lean.Meta.ExtractLetsConfig.onlyGivenNames... ok
Checking: Lean.Parser.Tactic.Grind.grind_filterGen!=_... ok
Checking: Lean.Parser.Tactic.mcasesMacro... ok
Checking: List.flatten_ne_nil_iff... ok
Checking: Decidable.isTrue.noConfusion... ok
Checking: Lean.Grind.Config.ext... ok
Checking: instToStringId... ok
Checking: PNonScalar._sizeOf_1... ok
Checking: PNonScalar._sizeOf_inst... ok
Checking: PNonScalar.mk.sizeOf_spec... ok
Checking: Lean.Parser.Tactic.rewriteSeq... ok
Checking: Lean.Macro.Context.recOn... ok
Checking: Lean.TSyntax._sizeOf_1... ok
Checking: Lean.TSyntax._sizeOf_inst... ok
Checking: Lean.TSyntax.mk.sizeOf_spec... ok
Checking: Std.Format.FlattenAllowability.disallow.elim... ok
Checking: Option.any_map... ok
Checking: Option.min_none_some... ok
Checking: Lean.Parser.Tactic.Grind.showTerm... ok
Checking: StateRefT'.instMonadExceptOf... ok
Checking: List.concat_cons... ok
Checking: Nat.not_ge_eq... ok
Checking: Std.LeftIdentity.recOn... ok
Checking: monadFunctorRefl... ok
Checking: Lean.instMonadRefOfMonadLiftOfMonadFunctor... ok
Checking: Lean.instMonadQuotationOfMonadFunctorOfMonadLift... ok
Checking: ForM.mk.noConfusion... ok
Checking: WellFounded.transGen... ok
Checking: NeZero.recOn... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.filter_join.match_1_1... ok
Checking: Option.filter_join... ok
Checking: not_false_iff... ok
Checking: UInt16.recOn... ok
Checking: Option.min_eq_none_iff... ok
Checking: Lean.Meta.instReprConfig_1... ok
Checking: Prod.swap_prod_mk... ok
Checking: Lean.Meta.ExtractLetsConfig.lift... ok
Checking: ForInStep.yield.elim... ok
Checking: liftExcept... ok
Checking: OptionT.bind.eq_1... ok
Checking: Option.merge_le_iff... ok
Checking: instReprTupleProdOfRepr... ok
Checking: Lean.Parser.Tactic.Conv.convNext__=>_... ok
Checking: precLead... ok
Checking: instToStringUSize... ok
Checking: Lean.Parser.Tactic.Conv.enterArg... ok
Checking: List.concat_nil... ok
Checking: List.map_eq_append_iff... ok
Checking: List.append_eq_map_iff... ok
Checking: Except.error.sizeOf_spec... ok
Checking: instTransIff... ok
Checking: Subrelation... ok
Checking: Subrelation.accessible... ok
Checking: Subrelation.wf... ok
Checking: Prod.rprod._proof_1... ok
Checking: Prod.rprod... ok
Checking: Nat.Linear.Expr.brecOn.eq... ok
Checking: Quotient.inductionOn₃... ok
Checking: _private.Init.Data.Nat.Div.Basic.0.Nat.mod_le.match_1_1... ok
Checking: _private.Init.Data.Nat.Div.Basic.0.Nat.mod_le.match_1_3... ok
Checking: Nat.mod_le... ok
Checking: Fin.mod._proof_1... ok
Checking: Fin.modn... ok
Checking: One.toOfNat1... ok
Checking: PSum.inr.sizeOf_spec... ok
Checking: Lean.interpolatedStrKind... ok
Checking: _private.Init.Prelude.0.Lean.Syntax.isMissing.match_1... ok
Checking: Lean.Syntax.isMissing... ok
Checking: Lean.TSyntax.expandInterpolatedStrChunks... ok
Checking: Lean.TSyntax.expandInterpolatedStr... ok
Checking: some_getElem_eq_getElem?_iff._simp_1... ok
Checking: List.some_getElem_eq_getElem?_iff... ok
Checking: _private.Init.Data.Array.GetLit.0.List.take.match_1.splitter... ok
Checking: List.drop.eq_def... ok
Checking: ite_else_self... ok
Checking: instLEFin... ok
Checking: Fin.val_le_of_ge... ok
Checking: Nat.Linear.Expr.add.sizeOf_spec... ok
Checking: Bool.le_refl... ok
Checking: Lean.Parser.Tactic.Grind.grind_<;>_... ok
Checking: String.Pos.Raw.Internal.sub... ok
Checking: Lean.TSyntax.getDocString... ok
Checking: Bool.false_eq... ok
Checking: Singleton.rec... ok
Checking: Singleton.casesOn... ok
Checking: Singleton.noConfusionType... ok
Checking: Singleton.noConfusion... ok
Checking: Singleton.mk.noConfusion... ok
Checking: WellFounded.casesOn... ok
Checking: Lean.Parser.Tactic.DecideConfig.mk.noConfusion... ok
Checking: Lean.Parser.Tactic.traceState... ok
Checking: right_iff_dite_iff... ok
Checking: List.Mem.below.rec... ok
Checking: List.Mem.below.casesOn... ok
Checking: _private.Init.Data.List.Lemmas.0.List.append_of_mem.match_1_6... ok
Checking: _private.Init.Data.List.Lemmas.0.List.append_of_mem.match_1_1... ok
Checking: List.cons_append... ok
Checking: List.append_of_mem... ok
Checking: Lean.Meta.ExtractLetsConfig.types... ok
Checking: EST.Out.ctorIdx... ok
Checking: EST.Out.ctorElimType... ok
Checking: EST.Out.ctorElim... ok
Checking: WellFoundedRelation.ctorIdx... ok
Checking: termMax_prec... ok
Checking: List.concat.eq_1... ok
Checking: Option.pbind_none'... ok
Checking: Bool.and_eq_false_iff... ok
Checking: Except.pure.eq_1... ok
Checking: Repr.casesOn... ok
Checking: Repr.noConfusionType... ok
Checking: UInt32.ofNatLT.eq_1... ok
Checking: List.set_append_left... ok
Checking: Lean.Parser.Tactic.acNf0... ok
Checking: List.Nodup... ok
Checking: List.nodupDecidable... ok
Checking: Std.Format.FlattenBehavior.allOrNone.sizeOf_spec... ok
Checking: Option.pelim_none'... ok
Checking: Lean.Parser.Tactic.Conv.case... ok
Checking: Lean.Loop.noConfusionType... ok
Checking: Option.min_eq_or... ok
Checking: instToStringFormat... ok
Checking: List.idRun_foldlM... FAIL
Checking: Lean.Parser.Tactic.mclearMacro... ok
Checking: Lean.Module.recOn... ok
Checking: Array.Array.repr... ok
Checking: Nat.sub_pos_of_lt... ok
Checking: HSMul.casesOn... ok
Checking: HSMul.noConfusionType... ok
Checking: List.isPrefixOf.eq_1... ok
Checking: Decidable.or_not_self... ok
Checking: Lean.instCoeOutTSyntaxSyntax... ok
Checking: List.getElem?_dropLast... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getLast?_dropLast.match_1_5... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getLast?_dropLast._simp_1_4... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getLast?_dropLast._simp_1_3... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getLast?_dropLast.match_1_1... ok
Checking: List.getLast?_dropLast... ok
Checking: UInt64.toNat... ok
Checking: instToStringUInt64... ok
Checking: _private.Init.Data.Array.Basic.0.Array.popWhile._proof_1... ok
Checking: _private.Init.Data.Array.Basic.0.Array.popWhile._proof_2... ok
Checking: _private.Init.Data.Array.Basic.0.Array.popWhile._proof_3... ok
Checking: Array.popWhile... ok
Checking: _private.Init.Data.Array.Basic.0.Array.popWhile._proof_4... ok
Checking: _private.Init.Data.Array.Basic.0.Array.popWhile.eq_def... ok
Checking: _private.Init.Data.Array.Basic.0.Array.popWhile.eq_1... ok
Checking: Array.popWhile_empty... ok
Checking: term_•_... ok
Checking: Option.pmap_guard._proof_1... ok
Checking: Option.pmap_guard... ok
Checking: List.eq_or_mem_of_mem_insert... ok
Checking: Nat.eq_zero_of_le_zero... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.le_zero.match_1_1... ok
Checking: Nat.le_zero... ok
Checking: Lean.Macro.State.casesOn... ok
Checking: Sigma.mk.noConfusion... ok
Checking: Sigma.mk.injEq... ok
Checking: term%[_|_]... ok
Checking: Append.mk.noConfusion... ok
Checking: Lean.Parser.Tactic.Conv.convConvSeq... ok
Checking: Nat.add_one_pos... ok
Checking: DoResultBC.continue.elim... ok
Checking: EStateM.Result._sizeOf_1... ok
Checking: EStateM.Result._sizeOf_inst... ok
Checking: EStateM.Result.ok.sizeOf_spec... ok
Checking: Option.bind_id_eq_join... ok
Checking: eq_true_of_decide... ok
Checking: List.isEmpty_nil... ok
Checking: Lean.Parser.Category.conv... ok
Checking: Option.guard_def... ok
Checking: Nat.Linear.Expr.num.noConfusion... ok
Checking: Lean.Parser.Tactic.tacIfThenElse... ok
Checking: Id.run_seqRight... FAIL
Checking: Monad.mk.noConfusion... ok
Checking: Lean.Parser.Tactic.tacticInfer_instance... ok
Checking: Quotient.ind₂... ok
Checking: Bool.xor_false... ok
Checking: Lean.mkIdentFrom... ok
Checking: Lean.mkIdentFromRef... ok
Checking: Lean.Syntax.Preresolved.recOn... ok
Checking: instReprUInt64... ok
Checking: Lean.Parser.Tactic.classical... ok
Checking: instInhabitedMProd... ok
Checking: stx_<|>_... ok
Checking: Option.mem_of_mem_join... ok
Checking: decidableGetElem?.congr_simp... ok
Checking: imp_iff_not... ok
Checking: Bool.cond_else_not_self... ok
Checking: unexpandGetElem?... ok
Checking: ReaderT.ext_iff... ok
Checking: dite_true... ok
Checking: Nat.lt.base... ok
Checking: have_val_congr'... ok
Checking: npowRec.match_1... ok
Checking: nsmulRec... ok
Checking: Nat.Linear.Expr.add.noConfusion... ok
Checking: Nat.Linear.Expr.add.inj... ok
Checking: Except.instMonad... ok
Checking: Bool.instMax... ok
Checking: Bool.max_eq_or... ok
Checking: term_*_... ok
Checking: decide_not... ok
Checking: Bool.true_beq... TIMEOUT
Checking: Bool.decide_beq_decide... ok
Checking: ST.Ref._sizeOf_1... ok
Checking: ST.Ref._sizeOf_inst... ok
Checking: ST.Ref.mk.sizeOf_spec... ok
Checking: _private.Init.PropLemmas.0.exists_and_right._simp_1_1... ok
Checking: exists_and_right... ok
Checking: Lean.Syntax.instBEqTSyntax... ok
Checking: PSigma.RevLex.recOn... ok
Checking: Lean.doElemRepeat__Until_... ok
Checking: List.foldrM.eq_1... ok
Checking: let_congr... ok
Checking: List.getElem_length_sub_one_eq_getLast._proof_1... ok
Checking: List.getElem_length_sub_one_eq_getLast... ok
Checking: Option.pelim_some... ok
Checking: Array.set!... ok
Checking: Lean.Parser.Tactic.Conv.normCast... ok
Checking: Option.filter_none... ok
Checking: _private.Init.Data.List.BasicAux.0.List.partitionM.go.match_1... ok
Checking: _private.Init.Data.List.BasicAux.0.List.partitionM.go... ok
Checking: List.partitionM... ok
Checking: Option.orElse_eq_or... ok
Checking: Lean.Parser.Tactic.rcasesPat.explicit... ok
Checking: List.singleton... ok
Checking: Fin.natAdd._proof_1... ok
Checking: Fin.natAdd... ok
Checking: List.eq_getElem_of_length_eq_two._proof_1... ok
Checking: List.eq_getElem_of_length_eq_two._proof_2... ok
Checking: _private.Init.Data.List.Lemmas.0.List.eq_getElem_of_length_eq_two.match_1_1... ok
Checking: List.eq_getElem_of_length_eq_two... ok
Checking: _private.Init.Data.List.Basic.0.List.lengthTRAux.match_1.splitter... ok
Checking: List.lengthTRAux.eq_def... ok
Checking: Bool.and_self_left... ok
Checking: Array.pop.eq_1... ok
Checking: Lean.TSyntax.instCoeIdentLevel... ok
Checking: _private.Init.Data.List.Basic.0.List.getLastD.match_1.splitter... ok
Checking: List.erase.eq_def... ok
Checking: Pow.recOn... ok
Checking: Bool.eq_false_imp_eq_true... ok
Checking: Lean.Parser.Tactic.mexfalsoMacro... ok
Checking: Lean.Meta.ApplyConfig.ctorIdx... ok
Checking: EStateM.Backtrackable.casesOn... ok
Checking: Bool.instMin... ok
Checking: List.instAntisymmLeOfNotLt... ok
Checking: forall₂_congr... ok
Checking: forall₃_congr... ok
Checking: forall₄_congr... ok
Checking: Add.ctorIdx... ok
Checking: prio(_)... ok
Checking: instReprExcept.match_1... ok
Checking: OptionT.run_mk... ok
Checking: ToString.ctorIdx... ok
Checking: Bool.cond_else_self... ok
Checking: _private.Init.PropLemmas.0.and_exists_self.match_1_1... ok
Checking: _private.Init.PropLemmas.0.and_exists_self.match_1_3... ok
Checking: and_exists_self... ok
Checking: Lean.Grind.Config.abstractProof... ok
Checking: List.sum_replicate_nat... ok
Checking: List.filter_filterMap... ok
Checking: List.reflBEq_iff... ok
Checking: ReaderT.failure... ok
Checking: Std.IdempotentOp.casesOn... ok
Checking: Lean.Parser.Tactic.cutsat... ok
Checking: tacticGet_elem_tactic_extensible... ok
Checking: Hashable.noConfusionType... ok
Checking: Hashable.noConfusion... ok
Checking: Hashable.mk.noConfusion... ok
Checking: false_ne_true... ok
Checking: List.head_singleton._proof_1... ok
Checking: List.head_singleton... ok
Checking: DoResultSBC.pureReturn.noConfusion... ok
Checking: DoResultSBC.pureReturn.inj... ok
Checking: Array.Mem.recOn... ok
Checking: Option.pbind_congr... ok
Checking: ReaderT.adapt... ok
Checking: List.head?_eq_getLast?_reverse... ok
Checking: List.set.eq_3... ok
Checking: Fin.getElem?_fin... FAIL
Checking: Std.Format.align.sizeOf_spec... ok
Checking: Lean.Parser.Tactic.case... ok
Checking: List.dropLast_singleton... ok
Checking: List.getLast_append._proof_1... ok
Checking: List.getLast_append_of_ne_nil... ok
Checking: List.getLast_append... ok
Checking: beq_false... ok
Checking: Lean.instInhabitedParserDescr... ok
Checking: Std.Format.MonadPrettyFormat.startTag... ok
Checking: iff_comm... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.isNone_filter.match_1_3... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.isNone_filter.match_1_1... ok
Checking: Option.isNone_filter... ok
Checking: List.tailD_nil... ok
Checking: Id.run_seq... FAIL
Checking: Std.Associative.recOn... ok
Checking: term_∈_... ok
Checking: Option.le.eq_2... ok
Checking: Lean.Meta.ApplyNewGoals.all.sizeOf_spec... ok
Checking: Lean.Parser.Tactic.simpArithBang... ok
Checking: Nat.add_one_le_of_lt... ok
Checking: term_≤_... ok
Checking: Lean.ParserDescr.binary.sizeOf_spec... ok
Checking: GetElem.noConfusionType... ok
Checking: Option.isNone_min... ok
Checking: Lean.Grind.Config.ring... ok
Checking: Std.Format.nest.injEq... ok
Checking: EStateM.Backtrackable.noConfusionType... ok
Checking: EStateM.Backtrackable.noConfusion... ok
Checking: Bool.true_xor... ok
Checking: _private.Init.Ext.0.Prod.ext.match_1... ok
Checking: Prod.ext... ok
Checking: Prod.ext_iff... ok
Checking: Lean.Parser.Attr.grind?... ok
Checking: Nat.mul_add_one... FAIL
Checking: Lean.Parser.Tactic.Grind.finish... ok
Checking: List.get?Internal_eq_getElem?... ok
Checking: Char.recOn... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.exists.match_1_1... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.exists.match_1_3... ok
Checking: Option.exists... ok
Checking: Lean.Parser.Tactic.tacticHaveI__... ok
Checking: OrOp.noConfusionType... ok
Checking: OrOp.noConfusion... ok
Checking: Nat.div_eq_of_eq_mul_right... ok
Checking: UInt16.instOfNat... ok
Checking: List.eraseDups... ok
Checking: _private.Init.Data.List.Lemmas.0.List.eraseDups_append.match_1_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.eraseDupsBy_loop_cons.match_1_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.reverseAux.match_1.splitter... ok
Checking: List.eraseDupsBy.loop.eq_def... ok
Checking: Nat.lt_add_one_of_le... ok
Checking: _private.Init.Data.List.Lemmas.0.List.eraseDupsBy_loop_cons._unary... ok
Checking: _private.Init.Data.List.Lemmas.0.List.eraseDupsBy_loop_cons... ok
Checking: Bool.decide_eq_false... ok
Checking: List.eraseDupsBy_cons... ok
Checking: List.eraseDups_cons... ok
Checking: _private.Init.Data.List.Lemmas.0.List.filter_append.match_1_1... ok
Checking: List.filter_append... ok
Checking: List.removeAll_cons... ok
Checking: List.eraseDups_append._unary... ok
Checking: List.eraseDups_append... ok
Checking: PSigma.lex._proof_1... ok
Checking: PSigma.lex... ok
Checking: Lean.Grind.GrobnerConfig.recOn... ok
Checking: Std.Format.append.inj... ok
Checking: Fin.instInhabited... ok
Checking: HAndThen.rec... ok
Checking: HAndThen.casesOn... ok
Checking: HAndThen.noConfusionType... ok
Checking: HAndThen.noConfusion... ok
Checking: Lean.termEval_prio_... ok
Checking: Lean.Syntax.decodeStrLitAux... ok
Checking: _private.Init.MetaTypes.0.Lean.Meta.instBEqOccurrences.beq._sparseCasesOn_1... ok
Checking: _private.Init.MetaTypes.0.Lean.Meta.instBEqOccurrences.beq._sparseCasesOn_2... ok
Checking: _private.Init.MetaTypes.0.Lean.Meta.instBEqOccurrences.beq._sparseCasesOn_3... ok
Checking: _private.Init.MetaTypes.0.Lean.Meta.instBEqOccurrences.beq.match_1... ok
Checking: Lean.Meta.instBEqOccurrences.beq... ok
Checking: Lean.Meta.instBEqOccurrences... ok
Checking: Option.min_le_left... ok
Checking: Option.map_eq_map... ok
Checking: Sum.inl.inj... ok
Checking: Option.any_false... ok
Checking: Option.pmap_or.match_1... ok
Checking: Option.pmap_or._proof_3... ok
Checking: Option.pmap_or._proof_4... ok
Checking: Option.pmap_or... ok
Checking: List.elem_cons... ok
Checking: map_eq_pure_bind... ok
Checking: List.mem_of_mem_head?... ok
Checking: List.head_of_mem_head?... ok
Checking: Char.isValidChar_zero... ok
Checking: Lean.Parser.Tactic.allGoals... ok
Checking: Nat.subDigitChar... ok
Checking: Bool.eq_false_and_eq_true_self... ok
Checking: instCoeHTCTIntOfIntCast... ok
Checking: Lean.Meta.ExtractLetsConfig.useContext... ok
Checking: StateT.modifyGet.eq_1... ok
Checking: _private.Init.Meta.Defs.0.Lean.Meta.instReprTransparencyMode.repr.match_1... ok
Checking: Lean.Meta.instReprTransparencyMode.repr... ok
Checking: Lean.Meta.instReprTransparencyMode... ok
Checking: List.set_eq_nil_iff... ok
Checking: term_∘_... ok
Checking: Option.join_max... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.succ_pred_eq_of_pos.match_1_1... ok
Checking: Nat.succ_pred_eq_of_pos... ok
Checking: Std.Identity.recOn... ok
Checking: IntCast.ctorIdx... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getElem_zero_eq_head._simp_1... ok
Checking: List.getElem_zero_eq_head._proof_2... ok
Checking: List.getElem_zero_eq_head... ok
Checking: Lean.Meta.Simp.Config.mk.noConfusion... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.pred_ne_self.match_1_1... ok
Checking: Nat.pred_ne_self... ok
Checking: CoeHTCT.mk.noConfusion... ok
Checking: Complement.recOn... ok
Checking: Function.const_comp... ok
Checking: List.all_append... ok
Checking: List.all_flatten... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.le_of_sub_eq_zero.match_1_1... ok
Checking: Nat.le_of_sub_eq_zero... ok
Checking: _private.Init.Data.Repr.0.Int.repr.match_1... ok
Checking: Int.repr... ok
Checking: Lean.Syntax.mkScientificLit... ok
Checking: Coe.noConfusion... ok
Checking: Coe.mk.noConfusion... ok
Checking: Lean.Parser.Tactic.dsimpTraceArgsRest... ok
Checking: Lean.Parser.Tactic.dsimpTrace... ok
Checking: _private.Init.Prelude.0.Lean.eraseMacroScopesAux.match_1... ok
Checking: _private.Init.Prelude.0.Lean.eraseMacroScopesAux... ok
Checking: Lean.Name.eraseMacroScopes... ok
Checking: Lean.Syntax.matchesIdent... ok
Checking: unexpandProdMk... ok
Checking: Option.commutative_merge... ok
Checking: Bool.or'.eq_1... ok
Checking: term_^^^_... ok
Checking: Alternative.recOn... ok
Checking: _private.Init.Data.List.Lemmas.0.List.head?_eq_head.match_1_1... ok
Checking: List.head?_eq_head... ok
Checking: Bool.cond_neg... ok
Checking: ExceptT.lift_pure... FAIL
Checking: Lean.Parser.Tactic.traceMessage... ok
Checking: List.getElem?_insert_succ... ok
Checking: List.getElem?_insert... ok
Checking: List.getElem_insert... ok
Checking: List.reverse.eq_1... ok
Checking: Insert.recOn... ok
Checking: Array.finIdxOf?... ok
Checking: _private.Init.Data.Array.Basic.0.Array.insertIdx.loop._proof_3... ok
Checking: Array.replace... ok
Checking: Array.drop... ok
Checking: Array.drop_eq_extract... ok
Checking: Lean.Parser.Tactic.decide... ok
Checking: seqRight_eq_bind... ok
Checking: Option.isSome_apply_of_isSome_bind... ok
Checking: List.mapTR.loop.eq_1... ok
Checking: NatCast.mk.noConfusion... ok
Checking: _private.Init.Meta.Defs.0.Lean.TSyntax.getHexNumSize.go... ok
Checking: Lean.TSyntax.getHexNumSize... ok
Checking: Lean.Grind.Config.ematch... ok
Checking: _private.Init.Data.Format.Basic.0.Std.Format.joinSuffix.match_1... ok
Checking: Std.Format.joinSuffix... ok
Checking: Lean.Parser.Category.stx... ok
Checking: Lean.Parser.Tactic.apply?... ok
Checking: HShiftLeft.casesOn... ok
Checking: HShiftLeft.noConfusionType... ok
Checking: Lean.Parser.Tactic.changeWith... ok
Checking: List.append.eq_1... ok
Checking: Option.or_eq_left_of_none... ok
Checking: Lean.Parser.Tactic.Grind.grind_ref.quot... ok
Checking: Lean.Meta.DSimp.Config.ctorIdx... ok
Checking: Nat.sub_le_add_right_sub... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.get_inj.match_1_1... ok
Checking: Option.get_inj... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.get_of_mem.match_1_1... ok
Checking: Option.get_of_mem... ok
Checking: Lean.Grind.Config.min... ok
Checking: HEq.ndrec... ok
Checking: List.intersperse_nil... ok
Checking: Lean.ParserDescr.nonReservedSymbol.sizeOf_spec... ok
Checking: Sub.recOn... ok
Checking: Lean.Loop.toCtorIdx... ok
Checking: List.take_zero... ok
Checking: List.erase_cons... ok
Checking: MonadControl.liftWith... ok
Checking: MonadControlT.restoreM... ok
Checking: instMonadControlTOfMonadControl... ok
Checking: Subtype.beq_iff... ok
Checking: Lean.Parser.Tactic.withReducible... ok
Checking: stx_?... ok
Checking: ForInStep.value_yield... ok
Checking: Fin.ofNat.eq_1... ok
Checking: UInt16.toFin... ok
Checking: LawfulMonad.casesOn... ok
Checking: term_⊃_... ok
Checking: HDiv.recOn... ok
Checking: Option.isNone_join... ok
Checking: Add.rec... ok
Checking: Add.casesOn... ok
Checking: Lean.Parser.Tactic.skip... ok
Checking: Std.Format.align.inj... ok
Checking: Fin.val_le_of_le... ok
Checking: Lean.Grind.instInhabitedConfig.default... ok
Checking: Lean.Grind.instInhabitedConfig... ok
Checking: _private.Init.Ext.0.Thunk.ext.match_1_1... ok
Checking: Thunk.ext... ok
Checking: ST.Out.mk.inj... ok
Checking: _private.Init.Data.List.Lemmas.0.List.set_comm.match_1_1... ok
Checking: List.set_comm... ok
Checking: _private.Init.Control.Lawful.Lemmas.0.map_inj_right_of_nonempty.match_1_1... ok
Checking: exists_apply_eq_apply... ok
Checking: _private.Init.Control.Lawful.Lemmas.0.map_inj_right_of_nonempty._simp_1_3... ok
Checking: Exists.choose_spec... ok
Checking: map_inj_right_of_nonempty... ok
Checking: map_inj_right... ok
Checking: List.map_eq_cons_iff... ok
Checking: _private.Init.Data.List.Lemmas.0.List.map_eq_singleton_iff._simp_1_1... ok
Checking: exists_eq_right_right._simp_1... ok
Checking: List.map_eq_singleton_iff... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.sub_eq_iff_eq_add.match_1_1... ok
Checking: Nat.sub_eq_iff_eq_add... ok
Checking: Nat.sub_eq_iff_eq_add'... ok
Checking: List.contains_map... ok
Checking: List.replace_singleton... ok
Checking: Option.bind_join... ok
Checking: _private.Init.Prelude.0.Lean.SourceInfo.getTrailing?.match_1... ok
Checking: Lean.SourceInfo.getTrailing?... ok
Checking: Lean.Syntax.getTrailing?... ok
Checking: Option.isSome_eq_false_iff... ok
Checking: ite_eq_right_iff._simp_1... ok
Checking: Option.pfilter_eq_none_iff... ok
Checking: _private.Init.Meta.Defs.0.Lean.Name.eraseSuffix?._sparseCasesOn_1... ok
Checking: _private.Init.Meta.Defs.0.Lean.Name.eraseSuffix?.match_1... ok
Checking: Lean.Name.eraseSuffix?... ok
Checking: List.getElem_cons.match_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.dropLast_append_of_ne_nil.match_1_1... ok
Checking: List.dropLast_append_of_ne_nil... ok
Checking: List.dropLast_append_cons... ok
Checking: Lean.NameGenerator.idx... ok
Checking: Lean.NameGenerator.curr... ok
Checking: Lean.NameGenerator.next... ok
Checking: Lean.mkFreshId... ok
Checking: Lean.ParserDescr.binary.noConfusion... ok
Checking: UInt16.ofBitVec.noConfusion... ok
Checking: Nat.div_add_mod._unary... ok
Checking: Nat.div_add_mod... ok
Checking: _private.Init.Data.Array.GetLit.0.Array.toListLitAux.match_1.splitter... ok
Checking: Array.toListLitAux.eq_def... ok
Checking: DoResultPRBC.pure.noConfusion... ok
Checking: Lean.Loop.recOn... ok
Checking: List.getElem?_set_self... ok
Checking: List.getElem?_set... ok
Checking: List.isEmpty_iff_length_eq_zero... ok
Checking: instReprExcept... ok
Checking: Option.left_lt_of_merge_lt... ok
Checking: Lean.Parser.Tactic.Grind.setOption... ok
Checking: Setoid.noConfusion... ok
Checking: List.takeWhile... ok
Checking: Lean.Parser.Tactic.tacticAc_nf_... ok
Checking: inline... ok
Checking: inline.eq_1... ok
Checking: Array.findSomeRev?... ok
Checking: HasEquiv.noConfusionType... ok
Checking: Or.intro_left... ok
Checking: Std.Format.group.sizeOf_spec... ok
Checking: WellFounded.recursion... ok
Checking: Except.map_id... ok
Checking: ExceptT.seqRight_eq... ok
Checking: forall₅_congr... ok
Checking: Min.casesOn... ok
Checking: Min.noConfusionType... ok
Checking: Min.noConfusion... ok
Checking: Append.ctorIdx... ok
Checking: instMonadControlReaderT... ok
Checking: instMonadControlStateRefT'... ok
Checking: exists₅_congr... ok
Checking: _private.Init.PropLemmas.0.decidable_of_bool.match_1... ok
Checking: _private.Init.PropLemmas.0.decidable_of_bool._proof_1... ok
Checking: _private.Init.PropLemmas.0.decidable_of_bool._proof_2... ok
Checking: decidable_of_bool... ok
Checking: WellFounded.induction... ok
Checking: Option.instDecidableRelLt.match_1... ok
Checking: Option.instDecidableRelLt... ok
Checking: Lean.Grind.ConfigInteractive.recOn... ok
Checking: Char.utf8Size._proof_1... ok
Checking: Char.utf8Size._proof_2... ok
Checking: Char.utf8Size._proof_3... ok
Checking: Char.utf8Size... ok
Checking: Array.any... ok
Checking: Array.contains... ok
Checking: Array.elem... ok
Checking: Max.noConfusion... ok
Checking: Lean.Parser.Tactic.Conv.convArgs... ok
Checking: liftM_seqLeft... ok
Checking: Div.ctorIdx... ok
Checking: Nat.Linear.Poly.isZero.eq_2... ok
Checking: USize.ctorIdx... ok
Checking: term_<&&>_... ok
Checking: Option.none_beq_some... ok
Checking: Zero.ctorIdx... ok
Checking: List.mapM.loop... ok
Checking: Lean.Parser.Tactic.extractLets... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getElem_eq_iff._simp_1_1... ok
Checking: List.getElem_eq_iff... ok
Checking: Nat.Linear.Expr.num.injEq... ok
Checking: List.intercalate... ok
Checking: Lean.Grind.genHEqPattern... ok
Checking: Pure.ctorIdx... ok
Checking: Lean.Parser.Tactic.Conv.convDone... ok
Checking: and_iff_right_of_imp... ok
Checking: and_iff_right_iff_imp... ok
Checking: term_==_... ok
Checking: Option.or_eq_none_iff._simp_1... ok
Checking: Option.orElse_eq_none_iff... ok
Checking: ExceptT.bindCont.eq_1... ok
Checking: instNonemptyPProd... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.add_one_add_one_ne_one.match_1_1... ok
Checking: Nat.add_one_add_one_ne_one... ok
Checking: Lean.Parser.Tactic.tacticSuffices_... ok
Checking: _private.Init.Meta.Defs.0.Lean.quoteArray.go._unary._proof_1... ok
Checking: _private.Init.Meta.Defs.0.Lean.quoteArray.go._unary._proof_2... ok
Checking: _private.Init.Meta.Defs.0.Lean.quoteArray.go._unary... ok
Checking: _private.Init.Meta.Defs.0.Lean.quoteArray.go... ok
Checking: _private.Init.Meta.Defs.0.Lean.quoteList.match_1... ok
Checking: _private.Init.Meta.Defs.0.Lean.quoteList... ok
Checking: Lean.instQuoteListMkStr1._private_1... ok
Checking: Lean.instQuoteListMkStr1... ok
Checking: _private.Init.Meta.Defs.0.Lean.quoteArray... ok
Checking: Lean.instQuoteArrayMkStr1._private_1... ok
Checking: Lean.instQuoteArrayMkStr1... ok
Checking: List.Pairwise.recOn... ok
Checking: DerivingHelpers.tacticDeriving_ReflEq_tactic... ok
Checking: List.getElem?_replicate... ok
Checking: List.replicate_inj... ok
Checking: unexpandMkArray6... ok
Checking: BEq.neq_of_beq_of_neq... ok
Checking: Lean.Meta.CheckTactic.CheckGoalType... ok
Checking: Lean.Meta.CheckTactic.CheckGoalType.intro... ok
Checking: StateRefT'.modifyGet... ok
Checking: List.getElem_cons_succ... TIMEOUT
Checking: Lean.Parser.Tactic.clearValue... ok
Checking: instLawfulMonadExcept... FAIL
Checking: Bool.false_le... ok
Checking: Option.get_bind... ok
Checking: List.intersperse.eq_1... ok
Checking: unexpandPSigma... ok
Checking: Option.or_eq_bif... ok
Checking: Lean.Macro.Context.mk.noConfusion... ok
Checking: StateRefT'.set... ok
Checking: StateRefT'.instMonadStateOfOfMonadLiftTST... ok
Checking: Int.instMin... ok
Checking: List.findIdx?.go... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.exists_eq_succ_of_ne_zero.match_1_1... ok
Checking: Nat.exists_eq_succ_of_ne_zero... ok
Checking: Lean.Parser.Tactic.Conv.fun... ok
Checking: _private.Init.Data.Nat.Div.Basic.0.Nat.sub_mul_div_of_le.match_1_1... ok
Checking: Nat.sub_mul_div_of_le... ok
Checking: List.getLastD_cons... ok
Checking: Lean.Grind.Config.splitIte... ok
Checking: DoResultPRBC._sizeOf_1... ok
Checking: DoResultPRBC._sizeOf_inst... ok
Checking: DoResultPRBC.pure.sizeOf_spec... ok
Checking: MonadLiftT.mk.noConfusion... ok
Checking: List.findSomeM?_id... FAIL
Checking: forall_not_of_not_exists... ok
Checking: _private.Init.Prelude.0.Lean.SourceInfo.getTrailingTailPos?.match_1... ok
Checking: Lean.SourceInfo.getTrailingTailPos?... ok
Checking: List.intersperseTR.eq_1... ok
Checking: _private.Init.Data.Array.Basic.0.Array.zipWithMAux._unary._proof_1... ok
Checking: _private.Init.Data.Array.Basic.0.Array.zipWithMAux._unary._proof_2... ok
Checking: Array.zipWithMAux._unary... ok
Checking: Array.zipWithMAux... ok
Checking: Array.zipWith... ok
Checking: Array.zip... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.decodeScientificLitVal?.decode... ok
Checking: Lean.Syntax.decodeScientificLitVal?... ok
Checking: Lean.MonadQuotation.ctorIdx... ok
Checking: CoeFun.ctorIdx... ok
Checking: List.contains_flatMap... ok
Checking: Option.eq_some_of_pfilter_eq_some... ok
Checking: exists_eq_right'... ok
Checking: ite.congr_simp... ok
Checking: List.Sublist.below.rec... ok
Checking: Option.all_eq_true... ok
Checking: instLawfulApplicativeExcept... ok
Checking: List.modifyHead.eq_1... ok
Checking: Lean.Parser.Tactic.Grind.allGoals... ok
Checking: Lean.Meta.Omega.OmegaConfig.recOn... ok
Checking: Option.decidableExistsMem.match_3... ok
Checking: Function.comp_const... ok
Checking: Bool.and_left_comm... ok
Checking: List.filterMap_flatMap... ok
Checking: Option.isSome_map... ok
Checking: Option.get_map._proof_1... ok
Checking: Option.get_map... ok
Checking: isSome_getElem?... ok
Checking: List.foldr_append_eq_append... ok
Checking: Option.merge.eq_4... ok
Checking: Option.ne_none_iff_exists'... ok
Checking: Prod.snd_swap... ok
Checking: List.getLast_append_left._proof_1... ok
Checking: List.getLast_append_left... ok
Checking: Lean.Meta.TransparencyMode.all.elim... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.or_of_isNone.match_1_1... ok
Checking: Option.or_of_isNone... ok
Checking: of_iff_true... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.isSome_merge._simp_1_1... ok
Checking: Option.isSome_merge... ok
Checking: neq_of_not_iff... ok
Checking: term∅... ok
Checking: and_rotate... ok
Checking: ForInStep.yield.sizeOf_spec... ok
Checking: instLawfulBEqChar... ok
Checking: List.head_replace._proof_1... ok
Checking: List.head_replace... ok
Checking: Bool.not_eq... ok
Checking: id_eq... ok
Checking: List.and_cons... ok
Checking: Lean.Parser.Tactic.substVars... ok
Checking: EStateM.instInhabited... ok
Checking: List.flatten_singleton... ok
Checking: Lean.Syntax.brecOn_2.go... ok
Checking: Lean.Syntax.brecOn_2... ok
Checking: StateCpsT.run'_eq... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.succ_succ_ne_one.match_1_1... ok
Checking: Nat.succ_succ_ne_one... ok
Checking: List.intersperseTR.eq_3... ok
Checking: One.recOn... ok
Checking: instReprAtomUInt32... ok
Checking: _private.Init.Data.List.Lemmas.0.List.exists_mem_nil.match_1_1... ok
Checking: List.exists_mem_nil... ok
Checking: DoResultPR.return.inj... ok
Checking: Nat.instLawfulIdentityHAddOfNat... ok
Checking: Lean.Parser.Tactic.Grind.showLocalThms... ok
Checking: Option.max_some_none... ok
Checking: MProd._sizeOf_1... ok
Checking: MProd._sizeOf_inst... ok
Checking: MProd.mk.sizeOf_spec... ok
Checking: HXor.ctorIdx... ok
Checking: LawfulBEq.casesOn... ok
Checking: Quotient.recOnSubsingleton... ok
Checking: Option.pmap_none... ok
Checking: List.getLast?_singleton... ok
Checking: Option.max_none_none... ok
Checking: String.ofByteArray.injEq... ok
Checking: Iff.rec... ok
Checking: Std.Total.total... ok
Checking: Lean.Parser.Tactic.Conv.pattern... ok
Checking: List.mem_of_mem_tail... ok
Checking: and_congr_left'... ok
Checking: Nat.eq_of_mul_eq_mul_right... ok
Checking: ne_of_mem_of_not_mem'... ok
Checking: UInt64.recOn... ok
Checking: Nat.Linear.Expr.eq_of_toNormPoly_eq... ok
Checking: term#[_,]... ok
Checking: Lean.Syntax.atom.noConfusion... ok
Checking: Lean.Syntax.atom.injEq... ok
Checking: funext_iff... ok
Checking: Option.bind_comm... ok
Checking: Lean.Parser.Tactic.tacticAssumption_mod_cast_... ok
Checking: _private.Init.Data.List.Lemmas.0.List.mem_iff_append.match_1_1... ok
Checking: List.mem_iff_append... ok
Checking: PSum.inr.inj... ok
Checking: _private.Init.Data.Format.Basic.0.Std.Format.prefixJoin.match_1... ok
Checking: Std.Format.prefixJoin... ok
Checking: Option.min_eq_left_of_lt... ok
Checking: List.forIn'_nil... FAIL
Checking: Lean.Parser.Tactic.bvNormalizeMacro... ok
Checking: instToStringId_1... ok
Checking: Std.Format.text.sizeOf_spec... ok
Checking: Nat.not_lt_of_gt... ok
Checking: Option.toList_some... ok
Checking: term_∩_... ok
Checking: _private.Init.Core.0.Exists.of_psigma_prop.match_1_1... ok
Checking: Exists.of_psigma_prop... ok
Checking: precMin... ok
Checking: instNonemptyMProd... ok
Checking: List.filterMap.eq_1... ok
Checking: Option.pfilter_eq_pbind_ite... ok
Checking: Option.pbind_eq_bind... ok
Checking: Lean.Macro.Methods.getCurrNamespace... ok
Checking: List.foldl_flip_cons_eq_append'... ok
Checking: unexpandExists... ok
Checking: DoResultSBC._sizeOf_1... ok
Checking: DoResultSBC._sizeOf_inst... ok
Checking: DoResultSBC.pureReturn.sizeOf_spec... ok
Checking: _private.Init.Data.Format.Basic.0.Std.Format.FlattenAllowability.shouldFlatten._sparseCasesOn_1... ok
Checking: _private.Init.Data.Format.Basic.0.Std.Format.FlattenAllowability.shouldFlatten.match_1... ok
Checking: Std.Format.FlattenAllowability.shouldFlatten... ok
Checking: List.lengthTRAux.eq_1... ok
Checking: Lean.Internal.hasLLVMBackend... ok
Checking: List.findSome?_eq_findSomeM?... ok
Checking: Union.union... ok
Checking: Lean.insertUnexpander... ok
Checking: Classical.propComplete... ok
Checking: tacticDecreasing_tactic... ok
Checking: List.nil_lex_cons... ok
Checking: have_unused'... ok
Checking: Fin.mk.inj... ok
Checking: List.flatMapM... ok
Checking: Bool.ite_eq_false... ok
Checking: Lean.Meta.DSimp.instInhabitedConfig... ok
Checking: Std.Format.defUnicode... ok
Checking: Nat.Linear.PolyCnstr.noConfusion... ok
Checking: Nat.Linear.PolyCnstr.mk.noConfusion... ok
Checking: Nat.Linear.PolyCnstr.mk.inj... ok
Checking: Lean.Meta.ApplyConfig.allowSynthFailures... ok
Checking: thunkCoe... ok
Checking: Nat.sub_one_mul... ok
Checking: Lean.isGreek... ok
Checking: instToBoolBool... ok
Checking: Bool.le_true... ok
Checking: _private.Init.Control.EState.0.EStateM.fromStateM.match_1... ok
Checking: EStateM.fromStateM... ok
Checking: XorOp.recOn... ok
Checking: Classical.not_and_iff_not_or_not... ok
Checking: Not.intro... ok
Checking: Exists.choose.congr_simp... ok
Checking: Prod.mk.inj... ok
Checking: Nat.lt_eq... ok
Checking: tacticDecreasing_trivial... ok
Checking: exists₂_imp... ok
Checking: UInt64.toUInt32... ok
Checking: Lean.Meta.Simp.NormCastConfig.mk.injEq... ok
Checking: ExceptT.instMonadFunctor... ok
Checking: STWorld.noConfusionType... ok
Checking: STWorld.noConfusion... ok
Checking: List.get_of_mem... ok
Checking: _private.Init.Data.List.Lemmas.0.List.mem_iff_get.match_1_1... ok
Checking: List.mem_iff_get... ok
Checking: LawfulApplicative.casesOn... ok
Checking: instHAndThenOfAndThen... ok
Checking: Option.orElse_some... ok
Checking: List.ne_nil_of_tail_ne_nil... ok
Checking: HOrElse.rec... ok
Checking: HOrElse.casesOn... ok
Checking: HOrElse.noConfusionType... ok
Checking: OptionT.run_seq... FAIL
Checking: _private.Init.Control.Lawful.Instances.0.OptionT.run_seqRight.match_1_1... ok
Checking: OptionT.run_seqRight... ok
Checking: Bool.cond_eq_false_distrib... ok
Checking: SizeOf.recOn... ok
Checking: instHashableString... ok
Checking: Lean.binderPred.quot... ok
Checking: MonadState.ctorIdx... ok
Checking: instIdempotentOpAnd... ok
Checking: List.any_flatten... ok
Checking: Nat.le_eq... ok
Checking: List.append_cancel_left_eq... ok
Checking: List.concat_inj_right... ok
Checking: Array.getElem?_toList... ok
Checking: Option.SomeLtNone.le... ok
Checking: HAndThen.mk.noConfusion... ok
Checking: _private.Init.MetaTypes.0.Lean.Meta.DSimp.instBEqConfig.beq.match_1... ok
Checking: Lean.Meta.DSimp.instBEqConfig.beq... ok
Checking: Lean.Meta.DSimp.instBEqConfig... ok
Checking: Lean.Macro.addMacroScope... ok
Checking: Nat.lt_of_add_left_lt... ok
Checking: Option.guard.eq_1... ok
Checking: EStateM.Backtrackable.mk.noConfusion... ok
Checking: Lean.Grind.GrobnerConfig.mk.inj... ok
Checking: List.dropLast_concat... ok
Checking: List.zipWith_cons_cons... FAIL
Checking: Option.guard_beq_some... ok
Checking: term_<*_... ok
Checking: Lean.Parser.Tactic.tacticExfalso... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.getTrailingSize.match_1... ok
Checking: Lean.Syntax.getTrailingSize... ok
Checking: term_<*>_... ok
Checking: Fin.castLT... ok
Checking: tacticClean_wf... ok
Checking: Nat.ne_zero_iff_zero_lt... ok
Checking: Nat.instNeZeroHPow... ok
Checking: Bool.and_not_self... ok
Checking: Lean.Grind.Config.zeta... ok
Checking: List.isEmpty_reverse... ok
Checking: Bool.decide_true_eq... ok
Checking: ReprTuple.recOn... ok
Checking: Char.repr... ok
Checking: dite.congr_simp... ok
Checking: instReprUnit... ok
Checking: Nat.lt_succ_of_lt... ok
Checking: SizeOf.ctorIdx... ok
Checking: forall_prop_of_true... ok
Checking: Option.not_comp_isNone... ok
Checking: List.decidableLE... ok
Checking: UInt16.decEq._proof_1... ok
Checking: UInt16.decEq._proof_2... ok
Checking: UInt16.decEq... ok
Checking: Option.none.elim... ok
Checking: Lean.Parser.Attr.wf_preprocess... ok
Checking: List.eraseDups.eq_1... ok
Checking: StateT.run_monadLift... ok
Checking: Lean.Parser.Tactic.Conv.rhs... ok
Checking: instDecidableEqOfLawfulBEq._proof_1... ok
Checking: instDecidableEqOfLawfulBEq... ok
Checking: Lean.MonadNameGenerator.noConfusion... ok
Checking: Lean.MonadNameGenerator.mk.noConfusion... ok
Checking: _private.Init.Data.List.Lemmas.0.List.flatten.match_1.splitter... ok
Checking: List.flatten.eq_def... ok
Checking: ExceptCpsT.runCatch_lift... ok
Checking: Lean.Parser.Attr.method_specs_simp... ok
Checking: SDiff.noConfusion... ok
Checking: SDiff.mk.noConfusion... ok
Checking: Lean.Meta.EtaStructMode.toCtorIdx... ok
Checking: Lean.Grind.GrobnerConfig.ctorIdx... ok
Checking: Bool.and_or_inj_right... ok
Checking: subtypeCoe... ok
Checking: DoResultPR.return.elim... ok
Checking: Array.isPrefixOf... ok
Checking: _private.Init.PropLemmas.0.Exists.imp'.match_1_1... ok
Checking: Exists.imp'... ok
Checking: and_iff_left... ok
Checking: _private.Init.Meta.Defs.0.Lean.isAlphanumAscii... ok
Checking: Lean.isIdRestAscii... ok
Checking: Lean.Syntax._sizeOf_2... ok
Checking: Lean.Syntax._sizeOf_3... ok
Checking: Lean.Syntax._sizeOf_3_eq... ok
Checking: Lean.Syntax._sizeOf_2_eq... ok
Checking: Lean.Syntax.node.sizeOf_spec... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.pmap_eq_some_iff._simp_1_4... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.pmap_eq_some_iff._simp_1_5... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.pmap_eq_some_iff._simp_1_6... ok
Checking: Option.pmap_eq_some_iff... ok
Checking: List.forM_nil... FAIL
Checking: Nat.ne_add_one... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.sub_one_eq_self._simp_1_1... ok
Checking: Nat.sub_one_eq_self... ok
Checking: Nat.Linear.Poly.toExpr... ok
Checking: Nat.Linear.PolyCnstr.toExpr... ok
Checking: Array.toListImpl... ok
Checking: Option.associative_merge... ok
Checking: EST.Out.ok.elim... ok
Checking: GetElem?.recOn... ok
Checking: And.elim... ok
Checking: List.foldrRecOn_cons... ok
Checking: HOrElse.noConfusion... ok
Checking: CoeTail.mk.noConfusion... ok
Checking: Lean.Meta.ApplyConfig.recOn... ok
Checking: Lean.Parser.Tactic.Grind.skip... ok
Checking: Lean.fieldIdxKind... ok
Checking: Lean.Syntax.isFieldIdx?... ok
Checking: OfNat.mk.noConfusion... ok
Checking: List.forIn'_eq_forIn'... ok
Checking: instMonadFinallyEST... ok
Checking: _private.Init.Data.List.Lemmas.0.List.forall_mem_flatten._simp_1_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.forall_mem_flatten._simp_1_2... ok
Checking: List.forall_mem_flatten... ok
Checking: Std.Format.instInhabitedFlattenBehavior.default... ok
Checking: Std.Format.instInhabitedFlattenBehavior... ok
Checking: Bool.xor_not... TIMEOUT
Checking: Lean.Parser.Tactic.first... ok
Checking: EST.Out.error.injEq... ok
Checking: Lean.Parser.Tactic.DecideConfig.zetaReduce... ok
Checking: List.reverse_concat... ok
Checking: List.reverse_eq_concat... ok
Checking: Mod.recOn... ok
Checking: Lean.Parser.Tactic.tacticRefine_lift_... ok
Checking: tacticFunext___... ok
Checking: MonadReaderOf.recOn... ok
Checking: Lean.Parser.Tactic.rintroPat.one... ok
Checking: Seq.noConfusionType... ok
Checking: Seq.noConfusion... ok
Checking: Seq.mk.noConfusion... ok
Checking: ne_self_iff_false... ok
Checking: Lean.Syntax.instEmptyCollectionSepArray... ok
Checking: MonadStateOf.casesOn... ok
Checking: MonadStateOf.noConfusionType... ok
Checking: Lean.Syntax.SepArray.ctorIdx... ok
Checking: Thunk.ctorIdx... ok
Checking: Option.some.sizeOf_spec... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.SomeLtNone.wellFounded_lt.match_1_1... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.SomeLtNone.wellFounded_lt.match_1_3... ok
Checking: Option.SomeLtNone.wellFounded_lt... ok
Checking: EStateM.instMonadFinally... ok
Checking: _private.Init.Data.List.Lemmas.0.List.head?_dropLast._simp_1_1... ok
Checking: List.head?_dropLast... ok
Checking: Lean.Parser.Tactic.rintroPat.binder... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getElem?_append_right.match_1_1... ok
Checking: List.getElem?_append_right... ok
Checking: List.getElem?_append... ok
Checking: Lean.Meta.LiftLetsConfig.ctorIdx... ok
Checking: Lean.Syntax.TSepArray.ofElems... ok
Checking: List.Pairwise.brecOn... ok
Checking: if_true_left... ok
Checking: Nat.lt_of_le_sub_one... ok
Checking: Nat.le_sub_one_iff_lt... ok
Checking: Fin.val_inj... ok
Checking: List.cons_inj_right... ok
Checking: List.getLast!_nil... ok
Checking: List.length_insert_pos... ok
Checking: imp_true_iff... ok
Checking: Option.isSome_of_any... ok
Checking: Option.any_eq_true_iff_get... ok
Checking: Option.get_of_any_eq_true... ok
Checking: Bool.ite_eq_true_else_eq_false... ok
Checking: Lean.Parser.Tactic.Grind.showState... ok
Checking: List.term_<:+_... ok
Checking: term_&&&_... ok
Checking: Option.getD_guard... ok
Checking: instLawfulIdentityAndTrue... ok
Checking: Acc.below.casesOn... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.lt_pred_iff_succ_lt.match_1_5... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.lt_pred_iff_succ_lt.match_1_1... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.lt_pred_iff_succ_lt.match_1_3... ok
Checking: Nat.lt_pred_iff_succ_lt... ok
Checking: _private.Init.Data.Int.Basic.0.Int.zero_ne_one.match_1_1... ok
Checking: Int.zero_ne_one... ok
Checking: instMonadReaderOfOfMonadLift... ok
Checking: Option.min_some_some... ok
Checking: Std.Format.MonadPrettyFormat.endTags... ok
Checking: Array.eraseIdx!... ok
Checking: Int.sign.match_1... ok
Checking: Int.sign... ok
Checking: List.filter_eq_append_iff... ok
Checking: List.append_eq_filter_iff... ok
Checking: Lean.Meta.Occurrences.pos.inj... ok
Checking: instInhabitedPProd... ok
Checking: instDecidableEqUInt16... ok
Checking: Bool.not_bne_not... ok
Checking: Bool.not_xor_not... ok
Checking: Option.min_pfilter_left... ok
Checking: PSum.inhabitedRight... ok
Checking: EStateM.Result.recOn... ok
Checking: UInt32.ofBitVec.inj... ok
Checking: Lean.Parser.Tactic.Conv.focus... ok
Checking: Nat.lt_of_succ_lt... ok
Checking: Option.max_le... ok
Checking: List.cons_beq_cons... ok
Checking: Setoid.ctorIdx... ok
Checking: instLawfulIdentityBoolAndTrue... ok
Checking: Option.getDM_none... ok
Checking: Nat.zero_eq... ok
Checking: List.getElem?_nil... ok
Checking: _private.Init.Data.Fin.Basic.0.Fin.modn_lt.match_1_1... ok
Checking: Fin.modn_lt... ok
Checking: List.foldl_hom... ok
Checking: List.tail?_nil... ok
Checking: Lean.Module.mk.noConfusion... ok
Checking: Prod.map_comp_map... FAIL
Checking: List.filter_reverse... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getLast_filter_of_pos._simp_1_1... ok
Checking: List.head_filter_of_pos... ok
Checking: List.getLast_filter_of_pos... ok
Checking: Bool.not_bne_self... TIMEOUT
Checking: Bool.not_xor_self... ok
Checking: NonScalar.recOn... ok
Checking: Lean.Parser.Tactic.simpAllArithBang... ok
Checking: Lean.Meta.Rewrite.Config.noConfusion... ok
Checking: _private.Init.Prelude.0.Lean.Syntax.getInfo?.match_1... ok
Checking: Lean.Syntax.getInfo?... ok
Checking: Nat.instTransLe... ok
Checking: ite_iff_left_iff... ok
Checking: Lean.Parser.Tactic.runTac... ok
Checking: List.getLastD_concat... ok
Checking: Bool.if_true_left... ok
Checking: not_not_not... ok
Checking: seqLeft_eq_bind... ok
Checking: _private.Init.Data.List.Lemmas.0.List.exists_mem_of_length_eq_add_one.match_1_1... ok
Checking: List.exists_mem_of_length_eq_add_one... ok
Checking: term_<_... ok
Checking: term_=_... ok
Checking: Lean.Meta.LiftLetsConfig.recOn... ok
Checking: Functor.mk.noConfusion... ok
Checking: Lean.evalPrec... ok
Checking: have_unused_dep'... ok
Checking: Array.erase... ok
Checking: Option.merge_eq_none_iff... ok
Checking: Bool.xor_left_comm... TIMEOUT
Checking: EStateM.instReprResult.match_1... ok
Checking: List.flatten.eq_2... ok
Checking: DoResultSBC.continue.sizeOf_spec... ok
Checking: _private.Init.Meta.Defs.0.Lean.withHeadRefOnly.match_1... ok
Checking: Lean.withHeadRefOnly... ok
Checking: term_-_... ok
Checking: Lean.Grind.Config.recOn... ok
Checking: Lean.Grind.Config.mk.sizeOf_spec... ok
Checking: List.foldlM.eq_1... ok
Checking: Lean.Syntax.Preresolved.namespace.elim... ok
Checking: Lean.Meta.ApplyNewGoals.toCtorIdx... ok
Checking: Nat.two_pos... ok
Checking: Lean.Parser.Tactic.Conv.allGoals... ok
Checking: or_iff_right... ok
Checking: List.filterTR.loop.eq_1... ok
Checking: Bool.lt_iff_le_not_le... ok
Checking: _private.Init.Data.List.Lemmas.0.List.exists_cons_of_length_eq_add_one.match_1_1... ok
Checking: List.exists_cons_of_length_eq_add_one... ok
Checking: ExceptCpsT.instMonadExceptOf... ok
Checking: ExceptCpsT.run_throw... FAIL
Checking: Iff.recOn... ok
Checking: Bool.if_true_right... ok
Checking: _private.Init.Prelude.0.eq_true_of_ne_false.match_1_1... ok
Checking: eq_true_of_ne_false... ok
Checking: List.getElem_cons... ok
Checking: Option.some_eq_ite_none_right... ok
Checking: UInt32.toUInt64._proof_1... ok
Checking: UInt32.toUInt64._proof_2... ok
Checking: UInt32.toUInt64... ok
Checking: liftOption... ok
Checking: Lean.Grind.CutsatConfig.recOn... ok
Checking: Option.right_le_max... ok
Checking: heq_eq_eq... ok
Checking: Array.uget.eq_1... ok
Checking: term_⁻¹... ok
Checking: instNonemptyTask... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getLast_tail.match_1_1... ok
Checking: List.getLast_tail... ok
Checking: List.filter_flatMap... ok
Checking: Lean.Parser.Tactic.Conv.nestedTacticCore... ok
Checking: IntCast.mk.noConfusion... ok
Checking: instNeZeroNatIte... ok
Checking: Lean.Parser.Tactic.generalizeArg... ok
Checking: Lean.Parser.Tactic.generalize... ok
Checking: le_of_le_of_eq... ok
Checking: Lean.Parser.Tactic.mrenameIMacro... ok
Checking: List.sum_reverse_nat... ok
Checking: and_or_right... ok
Checking: Array.anyM.loop._proof_4... ok
Checking: Array.anyM.loop.eq_def... ok
Checking: HDiv.noConfusion... ok
Checking: HDiv.mk.noConfusion... ok
Checking: List.intersperseTR.eq_2... ok
Checking: or_iff_right_of_imp... ok
Checking: Decidable.imp_or'... ok
Checking: _private.Init.Prelude.0.Lean.simpMacroScopesAux.match_1... ok
Checking: _private.Init.Prelude.0.Lean.simpMacroScopesAux... ok
Checking: Lean.Name.simpMacroScopes... ok
Checking: HSMul.noConfusion... ok
Checking: Lean.Parser.Tactic.paren... ok
Checking: Nat.beq.eq_4... ok
Checking: Std.LawfulLeftIdentity.rec... ok
Checking: Std.LawfulLeftIdentity.casesOn... ok
Checking: Option.get!_eq_getD... ok
Checking: ExceptT.run.eq_1... ok
Checking: ST.Ref.toMonadStateOf... ok
Checking: Fin.ctorIdx... ok
Checking: Lean.Macro.State.noConfusionType... ok
Checking: Lean.Macro.State.noConfusion... ok
Checking: Lean.Grind.NoopConfig.mk.sizeOf_spec... ok
Checking: List.insert.eq_1... ok
Checking: Lean.guardMsgsCmd... ok
Checking: _private.Init.Core.0.Exists.elim.match_1_1... ok
Checking: Exists.elim... ok
Checking: Nat.Linear.ExprCnstr.ctorIdx... ok
Checking: HMod.recOn... ok
Checking: Std.Format.FlattenAllowability.allow.injEq... ok
Checking: Lean.Syntax.instReprPreresolved... ok
Checking: List.min?... ok
Checking: List.getElem?_cons_zero... ok
Checking: Option.any_eq_false_iff_get... ok
Checking: Lean.Syntax.instCoeOutSepArrayArray... ok
Checking: AndOp.ctorIdx... ok
Checking: Option.join_none... ok
Checking: Nat.Linear.ExprCnstr.eq_of_toNormPoly_eq... ok
Checking: Int.instNatPow... ok
Checking: Lean.Parser.Tactic.falseOrByContra... ok
Checking: List.tail?_append... ok
Checking: ExceptCpsT.run_bind_lift... FAIL
Checking: List.elem.eq_1... ok
Checking: HShiftLeft.noConfusion... ok
Checking: HShiftLeft.mk.noConfusion... ok
Checking: Bool.eq_self_or... ok
Checking: _private.Init.Data.List.Lemmas.0.List.filterMap_eq_cons_iff._simp_1_1... ok
Checking: List.filterMap_eq_cons_iff... ok
Checking: Fin.val_add_one_le_of_gt... ok
Checking: Nat.eq_of_le_of_lt_succ... ok
Checking: Lean.Meta.Omega.OmegaConfig.splitNatSub... ok
Checking: _private.Init.Meta.Defs.0.Lean.Meta.Occurrences.isAll._sparseCasesOn_1... ok
Checking: _private.Init.Meta.Defs.0.Lean.Meta.Occurrences.isAll.match_1... ok
Checking: Lean.Meta.Occurrences.isAll... ok
Checking: Lean.Parser.Tactic.intro... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.pred_le_iff.match_1_1... ok
Checking: Nat.pred_le_iff... ok
Checking: Nat.pred_le_of_le_succ... ok
Checking: Lean.Syntax.isCharLit?... ok
Checking: instInhabitedSort... ok
Checking: Option.filter.eq_2... ok
Checking: Option.all_eq_false... ok
Checking: Classical.inhabited_of_exists._proof_1... ok
Checking: Classical.inhabited_of_exists... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.sub_le_sub_left.match_1_1... ok
Checking: Nat.sub_le_sub_left... ok
Checking: Nat.mul_sub_div... ok
Checking: PNonScalar.ctorIdx... ok
Checking: Bool.instDecidableExistsOfDecidablePred._proof_1... ok
Checking: Bool.instDecidableExistsOfDecidablePred._proof_2... ok
Checking: Bool.instDecidableExistsOfDecidablePred._proof_3... ok
Checking: Bool.instDecidableExistsOfDecidablePred... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.repeat_eq_repeatTR.go.match_1... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.repeatTR.loop.eq_2... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.repeat_eq_repeatTR.go... ok
Checking: Nat.repeat_eq_repeatTR... ok
Checking: List.getLast?.eq_2... ok
Checking: instAddUSize... ok
Checking: Array.size_eq_length_toList... ok
Checking: Lean.Parser.Tactic.mrefineMacro... ok
Checking: Bool.eq_true_and_eq_false_self... ok
Checking: ForInStep.done.injEq... ok
Checking: Task.pure.injEq... ok
Checking: Array.toListLitAux.eq_2... ok
Checking: Option.map_id_apply... ok
Checking: List.tail?_cons... ok
Checking: MonadEvalT.ctorIdx... ok
Checking: List.map_id''... ok
Checking: bne_self_eq_false... ok
Checking: bne_self_eq_false'... ok
Checking: Sigma._sizeOf_1... ok
Checking: Sigma._sizeOf_inst... ok
Checking: Sigma.mk.sizeOf_spec... ok
Checking: PSum.inl.inj... ok
Checking: Array.insertIdx!... ok
Checking: Option.map_eq_none_iff... ok
Checking: Nat.superDigitChar... ok
Checking: List.instBEq.eq_1... ok
Checking: List.decide_mem_cons... ok
Checking: dite_then_false... ok
Checking: Option.elim_guard... ok
Checking: ite_eq_dite... ok
Checking: Lean.Parser.Tactic.Grind.grind_filterGen>=_... ok
Checking: List.map_set... ok
Checking: EStateM.Result.ok.injEq... ok
Checking: term_>>>_... ok
Checking: StateT.lift.eq_1... ok
Checking: List.lengthTRAux.eq_2... ok
Checking: Nat.instNeZeroHPowOfNat... ok
Checking: Option.pelim_congr... ok
Checking: Option.pelim_guard... ok
Checking: NeZero.ne'... ok
Checking: Nat.le_add_left_of_le... ok
Checking: Bool.cond_false_right... ok
Checking: Nat.toSuperDigitsAux... ok
Checking: Nat.toSuperDigits... ok
Checking: Bool.eq_true_imp_eq_false... ok
Checking: ForInStep.yield.inj... ok
Checking: Lean.Parser.Tactic.rcases... ok
Checking: ReaderT.orElse... ok
Checking: ReaderT.instAlternativeOfMonad... ok
Checking: Lean.Grind.Config.verbose... ok
Checking: Lean.ParserDescr.trailingNode.sizeOf_spec... ok
Checking: List.mem_singleton_self... ok
Checking: MonadControl.ctorIdx... ok
Checking: List.mem_of_getLast?... ok
Checking: List.getLast_of_getLast?_eq_some... ok
Checking: List.any_eq_not_all_not... ok
Checking: List.intersperse.eq_2... ok
Checking: Option.dite_none_right_eq_some... ok
Checking: ReaderT.instLawfulMonadLift... ok
Checking: List.foldl_map... ok
Checking: instNatCastNat... ok
Checking: Option.filterM.match_1... ok
Checking: Option.filterM... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.isNone_merge._simp_1_1... ok
Checking: Option.isNone_merge... ok
Checking: Decidable.and_iff_not_not_or_not... ok
Checking: Option.right_lt_of_merge_lt... ok
Checking: Option.merge_eq_some_iff... ok
Checking: Applicative.recOn... ok
Checking: Quotient.exists_rep... ok
Checking: List.findSome?_nil... ok
Checking: LawfulMonad.map_pure'... ok
Checking: Lean.Meta.ExtractLetsConfig.recOn... ok
Checking: instDecidablePredComp... ok
Checking: Lean.Syntax.missing.sizeOf_spec... ok
Checking: Bool.le_of_lt... ok
Checking: List.reverseAux_nil... ok
Checking: List.ext_get... ok
Checking: dbgTraceIfShared... ok
Checking: ShiftLeft.noConfusion... ok
Checking: ShiftLeft.mk.noConfusion... ok
Checking: Except.error.injEq... ok
Checking: _private.Init.Data.Repr.0.Nat.reprArray... ok
Checking: Nat.reprFast... ok
Checking: List.splitAt... ok
Checking: Trans.recOn... ok
Checking: Bool.not_inj... ok
Checking: Nat.lt_le_asymm... ok
Checking: ForM.ctorIdx... ok
Checking: String.Internal.posOf... ok
Checking: List.mem_of_mem_getLast?... ok
Checking: Nat.add_one_le_iff... ok
Checking: Lean.ParserDescr.unary.sizeOf_spec... ok
Checking: Bool.cond_true_left... ok
Checking: Lean.Syntax.instCoeTermTSyntaxConsSyntaxNodeKindMkStr4Nil... ok
Checking: prioHigh... ok
Checking: PSum.inr.elim... ok
Checking: Except.bind.eq_1... ok
Checking: Nat.zero_pow_of_pos... ok
Checking: Sum.inhabitedRight... ok
Checking: Function.id_comp... ok
Checking: Nat.instXorOp... ok
Checking: ReprAtom.ctorIdx... ok
Checking: ULift.recOn... ok
Checking: ReflBEq.recOn... ok
Checking: ShiftRight.recOn... ok
Checking: Lean.Name.str.inj... ok
Checking: List.IsSuffix.eq_1... ok
Checking: List.foldlM_reverse... ok
Checking: List.foldrM_reverse... ok
Checking: instToStringFin... ok
Checking: Lean.Parser.checkSimpFailure... ok
Checking: Lean.Parser.Tactic.anyGoals... ok
Checking: Lean.TSyntax.Compat.instCoeTailArraySyntaxTSyntaxArray... ok
Checking: _private.Init.Data.List.Lemmas.0.List.map_inj_right._simp_1_1... ok
Checking: List.map_inj_right... ok
Checking: _private.Init.Data.List.Lemmas.0.List.map_flatMap.match_1_1... ok
Checking: List.map_flatMap... ok
Checking: List.map_eq_flatMap... ok
Checking: Lean.toolchain... ok
Checking: OptionT.instInhabitedOfPure... ok
Checking: instLawfulFunctorExcept... ok
Checking: instGetElem?OfGetElemOfDecidable... ok
Checking: Nat.add_sub_self_right... ok
Checking: termΣ_,_... ok
Checking: Option.join_le... ok
Checking: List.drop.eq_3... ok
Checking: heq_self_iff_true... ok
Checking: Relation.TransGen.below.rec... ok
Checking: ReaderT.run_bind... FAIL
Checking: ReaderT.run_monadLift... FAIL
Checking: Fin.cast._proof_1... ok
Checking: Fin.cast... ok
Checking: CoeDep.coe... ok
Checking: Option.pfilter.eq_2... ok
Checking: List.tail_cons... ok
Checking: Nat.mod_lt_of_lt... ok
Checking: Std.Format.FlattenBehavior.noConfusionType... ok
Checking: Std.Format.FlattenBehavior.noConfusion... ok
Checking: Prod.map_map... FAIL
Checking: List.splitAt.go.eq_3... ok
Checking: List.isSublist.match_1... ok
Checking: instMonadEvalT... ok
Checking: MonadStateOf.ctorIdx... ok
Checking: Lean.Syntax.SepArray.recOn... ok
Checking: OptionT.run_seqLeft... FAIL
Checking: CoeSort.noConfusion... ok
Checking: CoeSort.mk.noConfusion... ok
Checking: Lean.Grind.Config.funext... ok
Checking: UInt8.ofBitVec.inj... ok
Checking: SeqRight.recOn... ok
Checking: List.head?_flatten... ok
Checking: DoResultSBC.pureReturn.injEq... ok
Checking: Lean.Parser.Tactic.bvTraceMacro... ok
Checking: Lean.Meta.ExtractLetsConfig.preserveBinderNames... ok
Checking: if_false_left... ok
Checking: Lean.Meta.Simp.NormCastConfig.ctorIdx... ok
Checking: Nat.Linear.Expr.num.sizeOf_spec... ok
Checking: Nat.add_le_add... ok
Checking: getElem_congr_idx... ok
Checking: Lean.MonadNameGenerator.recOn... ok
Checking: Pure.noConfusion... ok
Checking: Lean.Macro.throwUnsupported... ok
Checking: instAssociativeOr... ok
Checking: Option.pelim_pfilter... ok
Checking: Array.flatMapM... ok
Checking: Option.min_pfilter_right... ok
Checking: Lean.Macro.Methods.mk.noConfusion... ok
Checking: List.getElem?_tail... ok
Checking: Option.filter_pmap... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.sub_one_add_one_eq_of_pos.match_1_1... ok
Checking: Nat.sub_one_add_one_eq_of_pos... ok
Checking: Min.mk.noConfusion... ok
Checking: List.cons_eq_flatten_iff... ok
Checking: List.length_flatten... ok
Checking: List.length_flatMap... ok
Checking: Array.forRevM... ok
Checking: Lean.Syntax.TSepArray.ctorIdx... ok
Checking: iff_not_self... ok
Checking: ExceptCpsT.runK... ok
Checking: List.set_cons_succ... FAIL
Checking: modifyThe... ok
Checking: Bool.instCommutativeAnd... ok
Checking: OptionT.instMonadExceptOf... ok
Checking: bind_pure_unit... ok
Checking: _private.Init.Data.Array.Basic.0.Array.zipWithAll.go._unary._proof_1... ok
Checking: _private.Init.Data.Array.Basic.0.Array.zipWithAll.go._unary._proof_2... ok
Checking: _private.Init.Data.Array.Basic.0.Array.zipWithAll.go._unary... ok
Checking: _private.Init.Data.Array.Basic.0.Array.zipWithAll.go... ok
Checking: Array.zipWithAll... ok
Checking: List.eq_nil_iff_length_eq_zero... ok
Checking: _private.Init.Data.List.Basic.0.List.beq.match_1.splitter... ok
Checking: _private.Init.Data.List.Basic.0.List.beq.match_1.eq_3... ok
Checking: List.beq.eq_def... ok
Checking: List.beq.eq_3... ok
Checking: forall_prop_of_false... ok
Checking: instReprAtomInt... ok
Checking: Lean.Meta.Simp.ConfigCtx.mk.injEq... ok
Checking: Lean.Meta.Simp.NormCastConfig.mk.inj... ok
Checking: Lean.Parser.Tactic.Conv.convRepeat_... ok
Checking: term_⊕'_... ok
Checking: Classical.typeDecidable.match_1... ok
Checking: Classical.typeDecidable._proof_1... ok
Checking: Classical.typeDecidable... ok
Checking: Nat.le_or_le... ok
Checking: Nat.min_def... ok
Checking: List.replicateTR_loop_replicate_eq... ok
Checking: _private.Init.Data.List.Lemmas.0.List.set_set.match_1_1... ok
Checking: List.set_set... ok
Checking: Lean.Parser.Tactic.symm... ok
Checking: Option.lawfulBEq_iff... ok
Checking: Nat.Linear.ExprCnstr._sizeOf_1... ok
Checking: Nat.Linear.ExprCnstr._sizeOf_inst... ok
Checking: Nat.Linear.ExprCnstr.mk.sizeOf_spec... ok
Checking: OptionT.instMonadFunctor... ok
Checking: not_and_of_not_left... ok
Checking: Nat.instLawfulIdentityHMulOfNat... ok
Checking: Int.beq'... ok
Checking: List.getLast.eq_1... ok
Checking: right_iff_ite_iff... ok
Checking: Bool.lt_asymm... ok
Checking: Lean.Parser.Tactic.tacticHave'... ok
Checking: Option.none_beq_none... ok
Checking: List.flatten.eq_1... ok
Checking: sizeOf_default... ok
Checking: ExceptT.instLawfulMonadLiftExcept... ok
Checking: Option.bind_eq_none_iff... ok
Checking: Nat.add_eq... ok
Checking: List.flatten_cons... ok
Checking: StateT.run_set... FAIL
Checking: List.isEmpty_map... ok
Checking: Std.LeftIdentity.casesOn... ok
Checking: Lean.RArray.leaf.inj... ok
Checking: Lean.Parser.Tactic.dsimp... ok
Checking: Lean.Parser.Category.term... ok
Checking: Lean.Meta.EtaStructMode.none.sizeOf_spec... ok
Checking: _private.Init.NotationExtra.0.Lean.expandExplicitBindersAux.loop... ok
Checking: Lean.expandExplicitBindersAux... ok
Checking: Substring.Raw.mk.injEq... ok
Checking: ne_of_mem_of_not_mem... ok
Checking: Option.get_guard... ok
Checking: Lean.Parser.Category.grind... ok
Checking: imp_imp_imp... ok
Checking: UInt32.ofNat.eq_1... ok
Checking: Lean.Parser.Tactic.Conv.liftLets... ok
Checking: instLawfulGetElem... ok
Checking: HAdd.noConfusion... ok
Checking: HAdd.mk.noConfusion... ok
Checking: String.Pos.Raw.ctorIdx... ok
Checking: Nat.lt_of_sub_eq_sub_one... ok
Checking: USize.recOn... ok
Checking: List.all_filter... ok
Checking: Empty.recOn... ok
Checking: Bool.not'_eq_not... ok
Checking: Lean.Syntax.atom.inj... ok
Checking: instReprInt... ok
Checking: not_true... ok
Checking: Nat.mul_add_mod_self_right... ok
Checking: Add.recOn... ok
Checking: false_iff_true... ok
Checking: some_eq_getElem?_iff... ok
Checking: Option.le_filter... ok
Checking: _private.Init.Core.0.cast_heq.match_1_1... ok
Checking: cast_heq... ok
Checking: Subtype.instDecidableEq.match_1... ok
Checking: List.tacticSizeOf_list_dec... ok
Checking: cast_eq... ok
Checking: List.Sublist.below.casesOn... ok
Checking: Lean.SourceInfo.original.sizeOf_spec... ok
Checking: eq_self_iff_true... ok
Checking: List.flatten_replicate_nil... ok
Checking: Char.ctorIdx... ok
Checking: Bool.or_not_eq_right_iff_and... ok
Checking: List.eq_getElem_of_length_eq_three._proof_1... ok
Checking: List.eq_getElem_of_length_eq_three._proof_2... ok
Checking: List.eq_getElem_of_length_eq_three._proof_3... ok
Checking: _private.Init.Data.List.Lemmas.0.List.eq_getElem_of_length_eq_three.match_1_1... ok
Checking: List.eq_getElem_of_length_eq_three... ok
Checking: Lean.Parser.Tactic.tactic_<;>_... ok
Checking: _private.Init.Data.List.Lemmas.0.List.flatten_eq_append_iff._simp_1_4... ok
Checking: _private.Init.Data.List.Lemmas.0.List.flatten_eq_append_iff._simp_1_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.flatten_eq_append_iff._simp_1_2... ok
Checking: _private.Init.Data.List.Lemmas.0.List.flatten_eq_append_iff._simp_1_3... ok
Checking: List.flatten_eq_append_iff... ok
Checking: MonadExcept.ctorIdx... ok
Checking: Lean.Parser.Tactic.tacticAnd_intros... ok
Checking: MonadLift.recOn... ok
Checking: List.tail_replicate... ok
Checking: _private.Init.PropLemmas.0.exists_and_self.match_1_1... ok
Checking: _private.Init.PropLemmas.0.exists_and_self.match_1_3... ok
Checking: exists_and_self... ok
Checking: DoResultSBC.break.sizeOf_spec... ok
Checking: Option.filter_bind... ok
Checking: HMul.mk.noConfusion... ok
Checking: List.foldl_nil... ok
Checking: Lean.SourceInfo.recOn... ok
Checking: CoeHTC.recOn... ok
Checking: term__[_]... ok
Checking: Relation.TransGen.below.casesOn... ok
Checking: Array.reverse._proof_4... ok
Checking: Array.reverse._proof_5... ok
Checking: Array.reverse... ok
Checking: Lean.Parser.Tactic.solveByElim... ok
Checking: MonadExceptOf.recOn... ok
Checking: List.findIdx?... ok
Checking: MonadStateOf.noConfusion... ok
Checking: Bool.instCommutativeOr... ok
Checking: List.mapMono... ok
Checking: Pure.mk.noConfusion... ok
Checking: Lean.Meta.Rewrite.Config.occs... ok
Checking: List.Perm.below.casesOn... ok
Checking: Array.mapIdx... ok
Checking: heq_comm... ok
Checking: ST.Ref.ptrEq... ok
Checking: List.head?_concat_concat... ok
Checking: Lean.Meta.Rewrite.Config.mk.noConfusion... ok
Checking: Lean.Meta.Rewrite.Config.mk.injEq... ok
Checking: List.append_eq_flatten_iff... ok
Checking: List.eraseRepsBy... ok
Checking: List.eraseReps... ok
Checking: List.insert_append... ok
Checking: List.insert_append_of_not_mem_left... ok
Checking: Option.rel_none_none... ok
Checking: Bool.decide_false_eq... ok
Checking: Option.all_true... ok
Checking: List.head_cons... ok
Checking: List.any_filter... ok
Checking: List.all_reverse... ok
Checking: Lean.Meta.LiftLetsConfig.toExtractLetsConfig... ok
Checking: Subtype.eq_iff... ok
Checking: HAnd.mk.noConfusion... ok
Checking: Lean.Parser.Category.noConfusion... ok
Checking: ExceptT.run_bind_lift... FAIL
Checking: OptionT.run_lift... ok
Checking: instReprUSize... ok
Checking: instToStringUInt8... ok
Checking: Lean.instCoeSyntaxNodeKindSyntaxNodeKinds... ok
Checking: Fin.Internal.ofNat_eq_ofNat... TIMEOUT
Checking: Lean.Meta.Rewrite.Config._sizeOf_1... ok
Checking: Lean.Meta.Rewrite.Config._sizeOf_inst... ok
Checking: Lean.Meta.Rewrite.Config.mk.sizeOf_spec... ok
Checking: ExceptT.run_lift... ok
Checking: tacticGet_elem_tactic... ok
Checking: Lean.TSyntax.instCoeConsSyntaxNodeKind... ok
Checking: List.filter_map... ok
Checking: Option.all_bind... ok
Checking: List.map_filterMap_of_inv... ok
Checking: UInt8.toUInt32._proof_1... ok
Checking: UInt8.toUInt32._proof_2... ok
Checking: UInt8.toUInt32... ok
Checking: Char.ofUInt8._proof_1... ok
Checking: Char.ofUInt8._proof_2... ok
Checking: Char.ofUInt8... ok
Checking: Nat.Linear.Poly.isNum?... ok
Checking: _private.Init.Core.0.Subtype.exists_of_subtype.match_1_1... ok
Checking: Subtype.exists_of_subtype... ok
Checking: npowRec... ok
Checking: Lean.Syntax.brecOn_2.eq... ok
Checking: List.splitAt.go.eq_1... ok
Checking: Std.instCommutativeIff... ok
Checking: and_iff_left_iff_imp._simp_1... ok
Checking: List.replicate_beq_replicate... ok
Checking: getModify... ok
Checking: List.any_nil... ok
Checking: List.modifyHead_nil... ok
Checking: Lean.Grind.Config.clean... ok
Checking: CoeTail.ctorIdx... ok
Checking: _private.Init.Classical.0.Classical.skolem.match_1_1... ok
Checking: Classical.skolem... ok
Checking: _private.Init.Data.List.Lemmas.0.List.isEqv.match_1.splitter... ok
Checking: _private.Init.Data.List.Lemmas.0.List.isEqv.match_1.eq_3... ok
Checking: List.isEqv.eq_def... ok
Checking: List.isEqv.eq_3... ok
Checking: map_congr... ok
Checking: Option.map_dif... ok
Checking: List.set_tail... ok
Checking: Zero.mk.noConfusion... ok
Checking: PLift.down_up... ok
Checking: term_>=>_... ok
Checking: List.ne_nil_iff_length_pos... ok
Checking: StateT.run.eq_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.ne_nil_iff_exists_cons.match_1_1... ok
Checking: List.ne_nil_iff_exists_cons... ok
Checking: Prod.Lex.recOn... ok
Checking: Lean.Parser.Tactic.refine'... ok
Checking: DoResultSBC.continue.injEq... ok
Checking: Add.noConfusionType... ok
Checking: Sigma.recOn... ok
Checking: instToStringInt.match_1... ok
Checking: instToStringInt... ok
Checking: List.filterRevM... ok
Checking: Lean.Syntax.recOn... ok
Checking: Lean.RArray.leaf.elim... ok
Checking: MonadFunctorT.ctorIdx... ok
Checking: List.map.eq_1... ok
Checking: Option.guard_true... ok
Checking: _private.Init.Data.List.Lemmas.0.List.mem_iff_getElem?._simp_1_2... ok
Checking: _private.Init.Data.List.Lemmas.0.List.mem_iff_getElem?._simp_1_1... ok
Checking: List.mem_iff_getElem?... ok
Checking: List.mapTR.eq_1... ok
Checking: instToStringDecidable.match_1... ok
Checking: OptionT.lift_pure... FAIL
Checking: OptionT.lift_bind... ok
Checking: OptionT.instLawfulMonadLift... ok
Checking: instMonadWithReaderOfOfMonadFunctor... ok
Checking: Lean.Parser.Tactic.tacticDsimp?!_... ok
Checking: Lean.Meta.EtaStructMode.notClasses.sizeOf_spec... ok
Checking: Lean.Parser.Category.level... ok
Checking: List.insertIdx... ok
Checking: Nat.shiftRight_succ... TIMEOUT
Checking: Bool.toInt... ok
Checking: Bool.toInt_false... ok
Checking: instToStringSum.match_1... ok
Checking: instToStringSum... ok
Checking: MonadControl.recOn... ok
Checking: List.getElem_toArray... ok
Checking: Bool.false_xor... ok
Checking: Sep.sep... ok
Checking: Nat.zero_sub_one... ok
Checking: unexpandSigma... ok
Checking: Lean.Parser.Tactic.Conv.whnf... ok
Checking: AndThen.ctorIdx... ok
Checking: Fin.instAdd... ok
Checking: Option.max_eq_left... ok
Checking: Lean.NameGenerator.mk.inj... ok
Checking: Subtype.instLawfulBEq... ok
Checking: prioMid... ok
Checking: Option.orElse_fun_some... ok
Checking: Lean.Meta.TransparencyMode.noConfusionType... ok
Checking: Lean.Meta.TransparencyMode.noConfusion... ok
Checking: Lean.TSyntax.Compat.instCoeTailSyntax... ok
Checking: Std.IdempotentOp.recOn... ok
Checking: Lean.Macro... ok
Checking: List.length_insert... ok
Checking: Nat.Linear.Expr.mulR.inj... ok
Checking: Lean.termSatisfies_binder_pred%__... ok
Checking: Bool.forall_bool... ok
Checking: Std.LawfulIdentity.toIdentity... ok
Checking: String.toSubstring... ok
Checking: proof_irrel_heq... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.recCompiled.match_1... ok
Checking: Nat.recCompiled... ok
Checking: Nat.rec_eq_recCompiled... ok
Checking: Lean.ParserDescr.nonReservedSymbol.noConfusion... ok
Checking: Fin.addNat._proof_1... ok
Checking: Fin.addNat... ok
Checking: id_def... ok
Checking: _private.Init.Data.ToString.Basic.0.List.toString._sparseCasesOn_1... ok
Checking: _private.Init.Data.ToString.Basic.0.List.toString.match_1... ok
Checking: List.toString... ok
Checking: Option.decidableForallMem._proof_1... ok
Checking: Option.decidableForallMem._proof_2... ok
Checking: Option.decidableForallMem._proof_3... ok
Checking: Option.decidableForallMem... ok
Checking: Classical.decide_not... ok
Checking: SeqLeft.recOn... ok
Checking: List.foldr_add_const... ok
Checking: Lean.Meta.LiftLetsConfig.mk.injEq... ok
Checking: Lean.Parser.Tactic.tacticSimpa?_... ok
Checking: instToStringULift... ok
Checking: Repr.noConfusion... ok
Checking: Repr.mk.noConfusion... ok
Checking: _private.Init.System.ST.0.runST.match_1... ok
Checking: runST... ok
Checking: SMul.smul... ok
Checking: instHSMul... ok
Checking: One.ofOfNat1... ok
Checking: Nat.Linear.Poly.denote_sort... ok
Checking: and_iff_right... ok
Checking: List.flatten_replicate_singleton... ok
Checking: List.Lex.recOn... ok
Checking: _private.Init.PropLemmas.0.Decidable.iff_congr_left._simp_1_1... ok
Checking: Decidable.iff_congr_left... ok
Checking: LawfulMonadLift.casesOn... ok
Checking: Option.eq_none_iff_forall_some_ne... ok
Checking: instToStringBool... ok
Checking: UInt32.recOn... ok
Checking: Option.max_eq_left_of_lt... ok
Checking: instToStringUInt32... ok
Checking: Lean.Parser.Tactic.unfold... ok
Checking: List.getElem?_cons_succ... TIMEOUT
Checking: Array.idxOf... ok
Checking: Lean.Syntax.setArgs... ok
Checking: UInt16.ofNatTruncate._proof_1... TIMEOUT
Checking: UInt16.ofNatTruncate... ok
Checking: Option.map_min... ok
Checking: List.getElem!_cons_zero... ok
Checking: Option.join_some... ok
Checking: Bool.toNat_lt... ok
Checking: HAnd.recOn... ok
Checking: _private.Init.Data.Array.Basic.0.Array.findM?.match_1... ok
Checking: Array.findM?... ok
Checking: Lean.Grind.Config.acSteps... ok
Checking: term_>>_... ok
Checking: Lean.Parser.Attr.extIff... ok
Checking: Lean.Parser.Attr.ext... ok
Checking: Array.ext_iff... ok
Checking: CoeT.ctorIdx... ok
Checking: Lean.Syntax.atom.sizeOf_spec... ok
Checking: List.headD_map... ok
Checking: GetElem.noConfusion... ok
Checking: GetElem.mk.noConfusion... ok
Checking: Option.min_join_right... ok
Checking: Lean.Parser.Tactic.Conv.dsimpTrace... ok
Checking: Bool.not_ite_eq_false_eq_true... ok
Checking: List.getLast_eq_iff_getLast?_eq_some... ok
Checking: _private.Init.Data.Nat.Div.Basic.0.Nat.div_le_of_le_mul.match_1_1... ok
Checking: Nat.div_le_of_le_mul... ok
Checking: Pi.instSubsingleton... ok
Checking: List.replicateTR... ok
Checking: Lean.Parser.Tactic.grindTrace... ok
Checking: List.idxOf_nil... ok
Checking: List.Lex.brecOn... ok
Checking: Option.instIdempotentOpOr... ok
Checking: Complement.mk.noConfusion... ok
Checking: Bind.noConfusion... ok
Checking: Bool.beq_self_left... TIMEOUT
Checking: Std.Antisymm.casesOn... ok
Checking: instLawfulMonadLiftT... ok
Checking: List.idxOf?... ok
Checking: Lean.Syntax.Preresolved.noConfusion... ok
Checking: Lean.Syntax.Preresolved.decl.noConfusion... ok
Checking: List.all_filterMap... ok
Checking: term_>_... ok
Checking: Lean.Parser.Tactic.Grind.linarith... ok
Checking: not_or_intro... ok
Checking: Lean.Grind.Config.qlia... ok
Checking: List.get!Internal_eq_getElem!... ok
Checking: MonadState.set... ok
Checking: Option.not_isSome_iff_eq_none... ok
Checking: List.isSuffixOf_nil_left... ok
Checking: Lean.Syntax.node.injEq... ok
Checking: Inter.recOn... ok
Checking: List.filterTR... ok
Checking: List.filterTR_loop_eq... ok
Checking: List.filter_eq_filterTR... ok
Checking: Nat.le_of_add_right_le... ok
Checking: List.cons_head_tail... ok
Checking: Lean.Parser.Tactic.repeat'... ok
Checking: Std.Format.text.inj... ok
Checking: DoResultPRBC.return.injEq... ok
Checking: instReprAtomUInt64... ok
Checking: Array.zipIdx... ok
Checking: UInt32.ctorIdx... ok
Checking: Std.Format.FlattenAllowability.disallow.sizeOf_spec... ok
Checking: BitVec.ofFin.injEq... ok
Checking: HOr.ctorIdx... ok
Checking: Lean.Parser.Tactic.Conv.convRw__... ok
Checking: ST.Out.ctorIdx... ok
Checking: Lean.Meta.TransparencyMode.instances.sizeOf_spec... ok
Checking: _private.Init.Data.Repr.0.Option.repr.match_1... ok
Checking: Option.repr... ok
Checking: instReprOption... ok
Checking: _private.Init.Control.State.0.instSubsingletonStateM.match_1... ok
Checking: instSubsingletonStateM... ok
Checking: Nat.not_beq_eq_true_eq... ok
Checking: Nat.Linear.Expr.toPoly.go.eq_def... ok
Checking: MonadExcept.ofExcept... ok
Checking: DoResultPR._sizeOf_1... ok
Checking: DoResultPR._sizeOf_inst... ok
Checking: DoResultPR.pure.sizeOf_spec... ok
Checking: let_body_congr... ok
Checking: Lean.Meta.ExtractLetsConfig.mk.inj... ok
Checking: Singleton.recOn... ok
Checking: Nat.Linear.Expr.var.sizeOf_spec... ok
Checking: _private.Init.PropLemmas.0.cast_cast.match_1_1... ok
Checking: cast_cast... ok
Checking: Nat.le_or_eq_of_le_succ... ok
Checking: Lean.Grind.ConfigInteractive.mk.injEq... ok
Checking: List.leftpad_suffix... ok
Checking: Lean.Name.instLawfulBEq... ok
Checking: DoResultSBC.recOn... ok
Checking: Nat.Linear.Expr.num.inj... ok
Checking: Lean.Parser.Tactic.rintroPat.quot... ok
Checking: Option.getD_eq_iff... ok
Checking: StateCpsT.instLawfulMonad... ok
Checking: Hashable.ctorIdx... ok
Checking: Lean.MonadQuotation.getMainModule... ok
Checking: List.foldr.eq_2... FAIL
Checking: Singleton.ctorIdx... ok
Checking: Inv.recOn... ok
Checking: Nat.Linear.Poly.cancelAux.eq_3... ok
Checking: Applicative.mk.noConfusion... ok
Checking: Nat.lt_or_lt_of_ne... ok
Checking: List.filterMap_eq_map'... ok
Checking: ByteArray.data_push... FAIL
Checking: term_>>=_... ok
Checking: Nat.mul_sub_one... ok
Checking: instInhabitedEST... ok
Checking: Bool.coe_false_iff_true... ok
Checking: List.rotateLeft... ok
Checking: List.rotateLeft_nil... TIMEOUT
Checking: List.ext_getElem?_iff... ok
Checking: Lean.Grind.Config.order... ok
Checking: DoResultBC.break.sizeOf_spec... ok
Checking: Lean.Parser.resetGrindAttrs... ok
Checking: Mod.ctorIdx... ok
Checking: _private.Init.Control.State.0.ForM.forIn.match_1... ok
Checking: _private.Init.Control.State.0.ForM.forIn.match_3... ok
Checking: ForM.forIn... ok
Checking: List.foldlM.eq_2... FAIL
Checking: Lean.cdotTk... ok
Checking: Lean.cdot... ok
Checking: sizeOf_thunk... ok
Checking: HShiftRight.recOn... ok
Checking: Lean.Parser.Tactic.Grind.showEqcs... ok
Checking: List.Sublist.recOn... ok
Checking: ExceptT.instLawfulMonad... ok
Checking: Setoid.mk.noConfusion... ok
Checking: Lean.Syntax.ScientificLit... ok
Checking: Lean.TSyntax.instCoeScientificLitTerm... ok
Checking: precMax... ok
Checking: List.filterTR.eq_1... ok
Checking: unexpandMkArray3... ok
Checking: Std.Identity.toLeftIdentity... ok
Checking: _private.Init.Data.NeZero.0.instNeZeroNatHMul.match_3... ok
Checking: _private.Init.Data.NeZero.0.instNeZeroNatHMul.match_1... ok
Checking: instNeZeroNatHMul... ok
Checking: List.leftpadTR... ok
Checking: _private.Init.Data.List.Basic.0.List.replicateTR_loop_eq.match_1_1... ok
Checking: List.replicate.eq_1... ok
Checking: List.replicateTR.loop.eq_2... ok
Checking: List.replicateTR_loop_eq... ok
Checking: List.leftpad_eq_leftpadTR... ok
Checking: WellFoundedRelation.recOn... ok
Checking: List.map_replicate... ok
Checking: instReprChar... ok
Checking: Option.guard_lt_some... ok
Checking: Lean.Meta.ExtractLetsConfig.descend... ok
Checking: ForIn'.ctorIdx... ok
Checking: Bool.beq_self_right... TIMEOUT
Checking: instInhabitedUSize... ok
Checking: Lean.Parser.Tactic.inductionAlts... ok
Checking: Nat.pow_zero... ok
Checking: List.get_cons_succ'... TIMEOUT
Checking: Lean.TSyntax.instCoeNumLitPrio... ok
Checking: Lean.instQuoteRawMkStr1... ok
Checking: strictAnd... ok
Checking: Bool.decide_iff_dist... ok
Checking: Lean.Parser.Tactic.tacticBv_omega... ok
Checking: List.instFunctor... ok
Checking: List.foldlRecOn_nil... ok
Checking: prioDefault... ok
Checking: UInt8.ctorIdx... ok
Checking: Option.pelim_none... FAIL
Checking: EStateM.instReprResult... ok
Checking: Option.none_or... ok
Checking: Option.instLawfulIdentityOrNone... ok
Checking: ne_true_of_not... ok
Checking: Lean.Grind.Config.ringSteps... ok
Checking: Lean.Grind.NoopConfig.mk.injEq... ok
Checking: DoResultBC.recOn... ok
Checking: Lean.Meta.Omega.OmegaConfig.splitDisjunctions... ok
Checking: List.zip_nil_right... ok
Checking: List.headD_nil... ok
Checking: Option.or_eq_some_iff... ok
Checking: Lean.Macro.getCurrNamespace... ok
Checking: Fin.modn.eq_1... ok
Checking: Min.recOn... ok
Checking: STWorld.ctorIdx... ok
Checking: Nat.beq_eq... ok
Checking: OrElse.ctorIdx... ok
Checking: Complement.ctorIdx... ok
Checking: Option.mapM_some... FAIL
Checking: Lean.MonadRef.casesOn... ok
Checking: Lean.MonadRef.noConfusionType... ok
Checking: Lean.MonadRef.noConfusion... ok
Checking: _private.Init.Data.Nat.Div.Basic.0.Nat.pos_of_div_pos.match_1_1... ok
Checking: Nat.pos_of_div_pos... ok
Checking: Char.mk.injEq... ok
Checking: Option.pelim_join._proof_1... ok
Checking: Option.pelim_join... ok
Checking: Fin.Internal.ofNat.congr_simp... ok
Checking: DoResultPRBC.return.sizeOf_spec... ok
Checking: ByteArray.ctorIdx... ok
Checking: Add.noConfusion... ok
Checking: List.getElem_concat_length... ok
Checking: Lean.Meta.ApplyConfig.mk.injEq... ok
Checking: List.isPrefixOf_cons_nil... ok
Checking: Lean.ParserDescr.sepBy.noConfusion... ok
Checking: Array.swapAt!... ok
Checking: Bind.mk.noConfusion... ok
Checking: Decidable._sizeOf_1... ok
Checking: Decidable._sizeOf_inst... ok
Checking: Decidable.isFalse.sizeOf_spec... ok
Checking: LawfulGetElem.casesOn... ok
Checking: LE.ctorIdx... ok
Checking: List.filter_eq_cons_iff... ok
Checking: Lean.Meta.Omega.OmegaConfig.splitMinMax... ok
Checking: Option.mapA_eq_mapM... ok
Checking: UInt8.toUInt16._proof_1... ok
Checking: UInt8.toUInt16._proof_2... ok
Checking: UInt8.toUInt16... ok
Checking: String.recOn... ok
Checking: Lean.Parser.Tactic.induction... ok
Checking: List.isSublist... ok
Checking: List.forall_mem_replicate... ok
Checking: List.beq_cons_nil... ok
Checking: _private.Init.Data.List.Lemmas.0.List.filter_congr.match_1_1... ok
Checking: List.filter_congr... ok
Checking: UInt64.ctorIdx... ok
Checking: Lean.binderPred≠_... ok
Checking: Lean.Parser.Syntax.subPrio... ok
Checking: Lean.TSyntax.instCoeNameLitTerm... ok
Checking: Fin.mod... ok
Checking: term_<=_... ok
Checking: instReprEmpty... ok
Checking: List.isEmpty_replicate... ok
Checking: Dvd.ctorIdx... ok
Checking: Lean.Parser.Tactic.mspecializePureMacro... ok
Checking: List.map_id... ok
Checking: Lean.Meta.Occurrences.neg.inj... ok
Checking: List.eraseDups_nil... ok
Checking: Id.run_bind... ok
Checking: Option.bind_eq_bind... ok
Checking: List.filterMap_map... ok
Checking: CoeDep.mk.noConfusion... ok
Checking: _private.Init.System.ST.0.runEST.match_1... ok
Checking: runEST... ok
Checking: Nat.add_one_le_add_one_iff... ok
Checking: stx_,+... ok
Checking: Lean.Parser.Tactic.obtain... ok
Checking: orM... ok
Checking: EST.Out.ok.injEq... ok
Checking: Option.max_guard_some... ok
Checking: EStateM.orElse... ok
Checking: StateT.run_lift... ok
Checking: Lean.Parser.Tactic.Grind.grind_filterGen≤_... ok
Checking: Lean.Syntax.copyHeadTailInfoFrom... ok
Checking: Array.Mem.val... ok
Checking: Bool.eq_false_or_eq_true... ok
Checking: CoeSort.ctorIdx... ok
Checking: Lean.Syntax.decodeStrLit... ok
Checking: Lean.Syntax.isStrLit?... ok
Checking: BitVec.recOn... ok
Checking: Nat.mul_left_comm... ok
Checking: Fin.div._proof_1... ok
Checking: Fin.div... ok
Checking: Decidable.not_exists_not... ok
Checking: PSigma.mk.injEq... ok
Checking: Superset... ok
Checking: Array.instBEq... ok
Checking: DoResultSBC.break.inj... ok
Checking: OptionT.run_throw... FAIL
Checking: MonadLift.noConfusion... ok
Checking: List.term_<+_... ok
Checking: Nat.mod.eq_1... ok
Checking: Lean.Syntax.SepArray.ofElemsUsingRef... ok
Checking: Lean.instQuoteTermMkStr1... ok
Checking: Fin.last... ok
Checking: Option.orElse_eq_orElse... ok
Checking: Std.instToFormatFormat... ok
Checking: Array.instRepr... ok
Checking: Functor.map_unit... FAIL
Checking: Std.Identity.casesOn... ok
Checking: Nat.le_or_ge... ok
Checking: List.flatMap_id'... ok
Checking: List.reverseAux_eq... ok
Checking: Fin.instMod... ok
Checking: List.map_inj... ok
Checking: Lean.Parser.Tactic.withReducibleAndInstances... ok
Checking: acc_transGen_iff... ok
Checking: List.head?_cons... ok
Checking: List.none_eq_getElem?_iff... ok
Checking: CoeOTC.ctorIdx... ok
Checking: ExceptCpsT.run_bind_throw... FAIL
Checking: instToStringDecidable... ok
Checking: Option.right_le_of_merge_le... ok
Checking: Array.getInternal_eq_getElem... ok
Checking: instMonadControlTOfPure... ok
Checking: get_getElem?._proof_1... ok
Checking: get_getElem?... ok
Checking: Int.negSucc.inj... ok
Checking: EStateM.instOrElseOfBacktrackable... ok
Checking: Lean.Parser.Tactic.simpAllTrace... ok
Checking: Std.Format.defIndent... ok
Checking: Std.Format.nestD... ok
Checking: Classical.forall_or_exists_not... ok
Checking: Thunk.mk.injEq... ok
Checking: Nat.mul_mod_mul_left... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getElem?_set_self'._simp_1_1... ok
Checking: getElem?_eq_none_iff._simp_1... ok
Checking: List.getElem?_set_self'... ok
Checking: ite_false... ok
Checking: Classical.not_exists_not... ok
Checking: Option.elim.eq_1... ok
Checking: Lean.Meta.Simp.Config.mk.inj... ok
Checking: Bool.false.elim... ok
Checking: Lean.Meta.ApplyNewGoals.all.elim... ok
Checking: UInt64.toUInt16... ok
Checking: HAppend.ctorIdx... ok
Checking: List.term_<:+:_... ok
Checking: getElem_of_getElem?... ok
Checking: instReprUInt32... ok
Checking: SeqLeft.ctorIdx... ok
Checking: Option.some_orElse... ok
Checking: Lean.Parser.Tactic.focus... ok
Checking: DoResultPRBC.continue.sizeOf_spec... ok
Checking: Lean.Parser.Tactic.tacticErw___... ok
Checking: _private.Init.Data.Array.Basic.0.Array.firstM.go._proof_1... ok
Checking: _private.Init.Data.Array.Basic.0.Array.firstM.go._proof_2... ok
Checking: _private.Init.Data.Array.Basic.0.Array.firstM.go... ok
Checking: Array.firstM... ok
Checking: Nat.default_eq_zero... ok
Checking: optParam_eq... ok
Checking: _private.Init.Data.Nat.Div.Basic.0.Nat.div.go.match_1.splitter... ok
Checking: Nat.modCore.go.eq_def... ok
Checking: Subtype.instDecidableEq._proof_3... ok
Checking: Subtype.instDecidableEq._proof_1... ok
Checking: Subtype.instDecidableEq... ok
Checking: Lean.Parser.Tactic.Grind.grind_filterGen<_... ok
Checking: Option.forall_ne_none... ok
Checking: _private.Init.Data.List.Lemmas.0.List.forall_mem_singleton._simp_1_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.forall_mem_singleton._simp_1_2... ok
Checking: List.forall_mem_singleton... ok
Checking: MonadWithReaderOf.ctorIdx... ok
Checking: Lean.RArray.branch.injEq... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.setInfo.match_1... ok
Checking: Lean.Syntax.setInfo... ok
Checking: Lean.Parser.Tactic.tacticTrivial... ok
Checking: exists_eq_right_right'... ok
Checking: instSubsingletonEmpty... ok
Checking: _private.Init.Data.List.Lemmas.0.List.eq_of_mem_singleton.match_1_1... ok
Checking: List.eq_of_mem_singleton... ok
Checking: Fin.recOn... ok
Checking: Lean.Parser.Tactic.cases... ok
Checking: Bool.or_eq_right_iff_imp... ok
Checking: Lean.runElab... ok
Checking: UInt16.ofBitVec.injEq... ok
Checking: CoeDep.ctorIdx... ok
Checking: Lean.solveTactic... ok
Checking: Nat.caseStrongRecOn.match_1... ok
Checking: Nat.caseStrongRecOn... ok
Checking: Array.idxOf?... ok
Checking: Lean.Grind.CutsatConfig.toNoopConfig... ok
Checking: HSMul.hSMul... ok
Checking: and_self_left... ok
Checking: Lean.Grind.CutsatConfig.mk.inj... ok
Checking: List.zipWithAll_nil... ok
Checking: Bool.not_or_eq_left_iff_and... ok
Checking: ite_else_decide_not_self... ok
Checking: instDecidableEqProd.match_1... ok
Checking: UInt16.toUInt64._proof_1... ok
Checking: UInt16.toUInt64._proof_2... ok
Checking: UInt16.toUInt64... ok
Checking: Pi.instNonempty... ok
Checking: eq_mpr_eq_cast... ok
Checking: ExceptT.ext_iff... ok
Checking: _private.Init.Data.List.Basic.0.List.reverseAux.match_1.splitter... ok
Checking: List.filterTR.loop.eq_def... ok
Checking: Option.get!_none... ok
Checking: Nat.Linear.Expr.var.inj... ok
Checking: Decidable.imp_iff_or_not... ok
Checking: Lean.Parser.Tactic.mintroMacro... ok
Checking: Lean.Parser.Tactic.Conv.convTactic... ok
Checking: List.or_all_distrib_left... ok
Checking: Std.instCommutativeOr... ok
Checking: Lean.Parser.Tactic.tacticStop_... ok
Checking: ExceptCpsT.runCatch_bind_throw... FAIL
Checking: true_eq_false_of_false... ok
Checking: Option.some_eq_ite_none_left... ok
Checking: Lean.Parser.Tactic.simpAllAutoUnfold... ok
Checking: List.getD_cons_zero... ok
Checking: Thunk.bind... ok
Checking: MonadWithReader.recOn... ok
Checking: instToStringUnit... ok
Checking: Lean.Meta.EtaStructMode.all.elim... ok
Checking: Option.default_eq_none... ok
Checking: List.splitBy.loop.match_1... ok
Checking: List.splitBy.loop... ok
Checking: List.splitBy... ok
Checking: List.headD_cons... ok
Checking: Lean.Parser.Tactic.revert... ok
Checking: Option.eq_none_iff_forall_not_mem... ok
Checking: StateCpsT.runK_set... ok
Checking: Bool.cond_eq_if... ok
Checking: Or.by_cases'... ok
Checking: OptionT.bind_throw... FAIL
Checking: Lean.Grind.Config.gen... ok
Checking: Bool.toNat_false... ok
Checking: List.asString... ok
Checking: unexpandListToArray... ok
Checking: List.countP.go... ok
Checking: PSum.nonemptyLeft... ok
Checking: Lean.Parser.Tactic.assumption... ok
Checking: Lean.Parser.Tactic.Grind.setConfig... ok
Checking: ite_iff_right_iff... ok
Checking: Nat.add_div_left... ok
Checking: Bool.and_right_comm... ok
Checking: Option.filter_lt... ok
Checking: OptionT.map_failure... FAIL
Checking: MonadReader.ctorIdx... ok
Checking: eq_mp_eq_cast... ok
Checking: AndThen.noConfusion... ok
Checking: Option.min_none_none... ok
Checking: MonadExcept.orelse'... ok
Checking: Classical.typeDecidableEq... ok
Checking: Lean.Macro.Exception.ctorElim... ok
Checking: Lean.Macro.Exception.error.elim... ok
Checking: Bool.xor_true... ok
Checking: Array.get!Internal.eq_1... ok
Checking: List.set_replicate_self... ok
Checking: List.foldl_rel... ok
Checking: Option.any_max... ok
Checking: Nat.lt_succ_iff_lt_or_eq... ok
Checking: Nat.eq_of_lt_succ_of_not_lt... ok
Checking: _private.Init.Data.List.Control.0.List.foldlM.match_1.splitter... ok
Checking: List.foldlM.eq_def... ok
Checking: Lean.Parser.Tactic.Conv.nestedConv... ok
Checking: Lean.Meta.LiftLetsConfig._sizeOf_1... ok
Checking: Lean.Meta.LiftLetsConfig._sizeOf_inst... ok
Checking: Lean.Meta.LiftLetsConfig.mk.sizeOf_spec... ok
Checking: Option.any_some... ok
Checking: Function.false_comp... ok
Checking: term_|||_... ok
Checking: not_decide_eq_true... ok
Checking: Array.swapIfInBounds... ok
Checking: Lean.command__Unif_hint____Where_|_-⊢_... ok
Checking: ExceptT.bindCont.eq_2... ok
Checking: Int.ble'... ok
Checking: List.modifyHead_cons... ok
Checking: List.range'TR... ok
Checking: _private.Init.Data.List.Basic.0.List.range'_eq_range'TR.go.match_1... ok
Checking: _private.Init.Data.List.Basic.0.List.range'_eq_range'TR.go... ok
Checking: List.range'_eq_range'TR... ok
Checking: _private.Init.Data.Prod.0.Prod.exists.match_1_1... ok
Checking: _private.Init.Data.Prod.0.Prod.exists.match_1_3... ok
Checking: Prod.exists... ok
Checking: Bool.false_ne_true... ok
Checking: ToString.recOn... ok
Checking: Nat.not_lt_eq... ok
Checking: Nat.not_gt_eq... ok
Checking: instTransEq_1... ok
Checking: PLift.ctorIdx... ok
Checking: List.reverse_flatten... ok
Checking: _private.Init.Data.List.Basic.0.List.of_concat_eq_concat.match_1_1... ok
Checking: List.of_concat_eq_concat... ok
Checking: stx_,*,?... ok
Checking: Nat.add_lt_add... ok
Checking: Bool.cond_pos... ok
Checking: Std.ToFormat.mk.noConfusion... ok
Checking: Lean.runMeta... ok
Checking: ST.Ref.mk.inj... ok
Checking: Option.max_pfilter_left... ok
Checking: Array.all... ok
Checking: Nat.le_of_not_le... ok
Checking: Nat.le_of_not_ge... ok
Checking: Lean.Parser.Tactic.mspecMacro... ok
Checking: Option.guard_eq_some_iff... ok
Checking: List.map_tail... ok
Checking: List.any_insert... ok
Checking: Std.Symm.casesOn... ok
Checking: List.replicate_eq_replicateTR... ok
Checking: instReprPUnit... ok
Checking: Lean.Grind.genPattern... ok
Checking: instReprFin... ok
Checking: Nat.two_mul... ok
Checking: Squash.lift._proof_1... ok
Checking: Squash.lift... ok
Checking: HShiftLeft.ctorIdx... ok
Checking: PSigma.instWellFoundedRelation... ok
Checking: Fin.val_congr... ok
Checking: List.map_nil... ok
Checking: monadLift_seqRight... ok
Checking: ForIn.mk.noConfusion... ok
Checking: Option.pfilter.eq_1... ok
Checking: Nat.pow_add_one... FAIL
Checking: Lean.Parser.Tactic.Conv.conv·._... ok
Checking: Nat.Linear.Expr.mulR.sizeOf_spec... ok
Checking: Lean.Parser.Tactic.funCases... ok
Checking: DerivingHelpers.deriving_lawful_beq_helper_dep... ok
Checking: String.isValidUTF8... ok
Checking: not_and_of_not_right... ok
Checking: Classical.and_or_imp... ok
Checking: ExceptCpsT.instLawfulMonadLiftOfLawfulMonad... ok
Checking: Option.elim.eq_2... ok
Checking: decide_eq_decide... ok
Checking: Lean.Meta.ExtractLetsConfig.underBinder... ok
Checking: Option.some_beq_none... ok
Checking: List.flatMap_id... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getLast?_flatten._simp_1_1... ok
Checking: List.getLast?_flatten... ok
Checking: Option.bind_fun_none... ok
Checking: Lean.Meta.DSimp.Config.mk.inj... ok
Checking: Nat.instOrOp... ok
Checking: SMul.recOn... ok
Checking: List.intersperse.eq_def... ok
Checking: HOrElse.mk.noConfusion... ok
Checking: List.map_eq_iff... ok
Checking: Lean.Meta.Simp.ConfigCtx._sizeOf_1... ok
Checking: Lean.Meta.Simp.ConfigCtx._sizeOf_inst... ok
Checking: Lean.Meta.Simp.ConfigCtx.mk.sizeOf_spec... ok
Checking: Option.pfilter_filter... ok
Checking: Option.getD_some... ok
Checking: Option.getD_of_ne_none... ok
Checking: Lean.Parser.Tactic.mrevertMacro... ok
Checking: instInhabitedPNonScalar... ok
Checking: DoResultPRBC.pure.injEq... ok
Checking: Option.pmap.eq_1... ok
Checking: HasEquiv.noConfusion... ok
Checking: Lean.Parser.Category.binderPred... ok
Checking: Lean.MacroScopesView.ctorIdx... ok
Checking: Lean.Syntax.brecOn... ok
Checking: instToBoolOption... ok
Checking: Membership.mk.noConfusion... ok
Checking: Std.ToFormat.ctorIdx... ok
Checking: List.reverse_ne_nil_iff... ok
Checking: Lean.MonadRef.mk.noConfusion... ok
Checking: MonadLift.mk.noConfusion... ok
Checking: Lean.Syntax.isScientificLit?... ok
Checking: ExceptT.bind_throw... FAIL
Checking: Lean.Name.num.inj... ok
Checking: Option.max_eq_none_iff... ok
Checking: Lean.ParserDescr.sepBy.sizeOf_spec... ok
Checking: Option.isSome_join... ok
Checking: instCoeTOfCoeDep... ok
Checking: Option.bindM... ok
Checking: HAndThen.recOn... ok
Checking: Lean.Parser.Tactic.Conv.lhs... ok
Checking: List.findSome?.eq_1... ok
Checking: Lean.MacroScopesView._sizeOf_1... ok
Checking: Lean.MacroScopesView._sizeOf_inst... ok
Checking: Lean.MacroScopesView.mk.sizeOf_spec... ok
Checking: Option.min_some_guard... ok
Checking: List.dropLast_nil... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.pow_le_pow_right.match_1_3... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.pow_le_pow_right.match_1_1... ok
Checking: Nat.pow_le_pow_right... ok
Checking: MonadStateOf.mk.noConfusion... ok
Checking: Std.LawfulRightIdentity.toRightIdentity... ok
Checking: List.nil.elim... ok
Checking: List.contains_iff_mem... ok
Checking: List.nil_lex_nil... ok
Checking: term_||_... ok
Checking: Lean.Parser.Tactic.rewrites?... ok
Checking: Lean.expandExplicitBinders... ok
Checking: GetElem.ctorIdx... ok
Checking: Nat.min... ok
Checking: Nat.le_of_add_left_le... ok
Checking: Nat.add_one... ok
Checking: DoResultPRBC.continue.injEq... ok
Checking: NonScalar.mk.injEq... ok
Checking: term∃_,_... ok
Checking: letFun... ok
Checking: String.ctorIdx... ok
Checking: Option.choice_eq... ok
Checking: instToStringSubtype... ok
Checking: Lean.Name.instDecidableEq._proof_1... ok
Checking: Lean.Name.instDecidableEq._proof_2... ok
Checking: Lean.Name.instDecidableEq... ok
Checking: List.Perm.recOn... ok
Checking: Lean.Parser.Tactic.simpAllKind... ok
Checking: Lean.Parser.Tactic.declareSimpLikeTactic... ok
Checking: HAppend.mk.noConfusion... ok
Checking: _private.Init.Core.0.Decidable.not_and_iff_or_not.match_1_1... ok
Checking: _private.Init.Core.0.Decidable.not_and_iff_or_not.match_1_5... ok
Checking: _private.Init.Core.0.Decidable.not_and_iff_or_not.match_1_3... ok
Checking: Decidable.not_and_iff_or_not... ok
Checking: precArg... ok
Checking: List.mem_filterMap._simp_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.forall_mem_filterMap._simp_1_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.forall_mem_filterMap._simp_1_2... ok
Checking: List.forall_mem_filterMap... ok
Checking: Nat.add_one_sub_one... ok
Checking: Nat.toUInt64... ok
Checking: Array.zipWithM... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.elim_filter.match_1_3... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.elim_filter.match_1_1... ok
Checking: Option.elim_filter... ok
Checking: term_$__... ok
Checking: List.filterMap_reverse... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getLast_filterMap_of_eq_some._simp_1_1... ok
Checking: List.getLast_filterMap_of_eq_some... ok
Checking: List.getLast?_eq_none_iff... ok
Checking: Lean.Macro.Exception.recOn... ok
Checking: Prod.Lex.right'... ok
Checking: Bool.lt_of_le_of_ne... ok
Checking: Lean.TSyntax.instCoeDepTermMkIdentIdent... ok
Checking: Option.filter_map... ok
Checking: Bool.not_eq_false'... ok
Checking: Lean.TSyntax.ctorIdx... ok
Checking: DoResultPRBC.pure.inj... ok
Checking: boolPredToPred... ok
Checking: EST.Out.error.elim... ok
Checking: Nat.div.go.congr_simp... ok
Checking: term~~~_... ok
Checking: Bool.and_or_distrib_right... ok
Checking: Option.all_guard... ok
Checking: List.foldr_reverse... ok
Checking: Lean.Parser.Tactic.mconstructorMacro... ok
Checking: Nat.zero_ne_add_one... ok
Checking: _private.Init.Data.List.Basic.0.List.replicate.match_1.splitter... ok
Checking: List.replicate.eq_def... ok
Checking: Lean.Parser.Tactic.funInduction... ok
Checking: Lean.Parser.Tactic.rename... ok
Checking: List.dropLast_append... ok
Checking: List.map_id'... ok
Checking: Prod.ctorIdx... ok
Checking: List.mem_dite_nil_right... ok
Checking: MProd.mk.inj... ok
Checking: Option.isNone_max... ok
Checking: List.foldl_add_const... ok
Checking: Lean.Parser.Tactic.Grind.grind_filter_&&_... ok
Checking: String.Pos.Raw.Internal.min... ok
Checking: Lean.Parser.Tactic.tacticIterate____... ok
Checking: HOr.recOn... ok
Checking: List.any_flatMap... ok
Checking: Option.map_none... ok
Checking: List.getLast_eq_getLastD... ok
Checking: _private.Init.Data.List.Lemmas.0.List.dropLast_concat_getLast.match_1_1... ok
Checking: List.dropLast_cons₂... ok
Checking: List.dropLast_concat_getLast... ok
Checking: List.eq_or_mem_of_mem_cons... ok
Checking: Coe.ctorIdx... ok
Checking: Lean.Meta.TransparencyMode.toCtorIdx... ok
Checking: List.map.eq_def... ok
Checking: SeqRight.ctorIdx... ok
Checking: List.eq_nil_of_append_eq_nil... ok
Checking: Option.all_none... ok
Checking: Lean.Parser.Tactic.withAnnotateState... ok
Checking: Nat.shiftRight_zero... ok
Checking: Lean.Meta.CheckTactic.CheckGoalType.rec... ok
Checking: Lean.Meta.CheckTactic.CheckGoalType.casesOn... ok
Checking: List.repr... ok
Checking: instReprList... ok
Checking: List.dropLast.eq_1... ok
Checking: List.head_append_left._proof_1... ok
Checking: List.head_append_left... ok
Checking: Lean.Macro.Exception.unsupportedSyntax.elim... ok
Checking: List.partition.eq_1... ok
Checking: Thunk.fn_eq_fnImpl... ok
Checking: ExceptT.run_throw... FAIL
Checking: List.set_eq_of_length_le... ok
Checking: List.term_~_... ok
Checking: Bool.and_xor_distrib_left... TIMEOUT
Checking: Bool.or_self_right... ok
Checking: Nat.le_or_eq_of_le_add_one... ok
Checking: Lean.RArray.leaf.injEq... ok
Checking: Lean.binderPred∉_... ok
Checking: Nat.instCommutativeHMul... ok
Checking: instInhabitedUInt16._proof_1... ok
Checking: instInhabitedUInt16... ok
Checking: OrElse.casesOn... ok
Checking: OrElse.noConfusionType... ok
Checking: List.foldrM_nil... FAIL
Checking: Lean.ParserDescr.node.sizeOf_spec... ok
Checking: Bool.le_of_eq... ok
Checking: Sub.mk.noConfusion... ok
Checking: Option.elim_pfilter... ok
Checking: Bool.sizeOf_eq_one... ok
Checking: Option.merge_beq_none... ok
Checking: if_false_right... ok
Checking: instMinUInt32... ok
Checking: Lean.binderPred>_... ok
Checking: _private.Init.Data.List.Lemmas.0.List.filterMap_length_eq_length._simp_1_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.filterMap_length_eq_length._simp_1_3... ok
Checking: List.filterMap_length_eq_length... ok
Checking: Nat.beq.eq_2... ok
Checking: Lean.Parser.Tactic.DecideConfig.ctorIdx... ok
Checking: Lean.Syntax.brecOn_1.eq... ok
Checking: List.getElem?_singleton... ok
Checking: Lean.Meta.Rewrite.Config.ctorIdx... ok
Checking: Nat.max... ok
Checking: ForM.recOn... ok
Checking: _private.Init.PropLemmas.0.exists_prop'.match_1_1... ok
Checking: _private.Init.PropLemmas.0.exists_prop'.match_1_3... ok
Checking: exists_prop'... ok
Checking: Array.mk.inj... ok
Checking: List.concat.eq_2... ok
Checking: Lean.TSyntax.getChar... ok
Checking: instInhabitedTask.default... ok
Checking: instInhabitedTask... ok
Checking: Lean.mkGroupNode... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.join_ne_none._simp_1_1... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.join_ne_none._simp_1_2... ok
Checking: Option.join_ne_none... ok
Checking: Option.join_ne_none'... ok
Checking: Option.pbind_some... ok
Checking: Array.rightpad... ok
Checking: _private.Init.Data.List.Basic.0.List.append.match_1.splitter... ok
Checking: List.append.eq_def... ok
Checking: Lean.Parser.Tactic.dsimpAutoUnfold... ok
Checking: EStateM.Backtrackable.ctorIdx... ok
Checking: Std.LawfulCommIdentity.toLawfulIdentity... ok
Checking: Nat.Linear.Poly.cancelAux.eq_2... ok
Checking: List.getLast!.eq_2... ok
Checking: Equivalence.recOn... ok
Checking: OfNat.recOn... ok
Checking: Lean.ParserDescr.symbol.sizeOf_spec... ok
Checking: Lean.Meta.Simp.neutralConfig... ok
Checking: Std.LawfulLeftIdentity.toLeftIdentity... ok
Checking: Lean.MonadRef.recOn... ok
Checking: List.getElem_eq_getElem?_get._proof_1... ok
Checking: List.getElem_eq_getElem?_get... ok
Checking: Lean.ParserDescr.unicodeSymbol.sizeOf_spec... ok
Checking: Option.le.eq_3... ok
Checking: term{}... ok
Checking: liftM_seqRight... ok
Checking: List.foldr_cons_eq_append... ok
Checking: UInt64.toUInt8... ok
Checking: MonadFunctor.noConfusion... ok
Checking: Lean.Parser.Tactic.dbgTrace... ok
Checking: List.or_all_distrib_right... ok
Checking: instToStringString... ok
Checking: Option.guard_comp... FAIL
Checking: Lean.NameGenerator._sizeOf_1... ok
Checking: Lean.NameGenerator._sizeOf_inst... ok
Checking: Lean.NameGenerator.mk.sizeOf_spec... ok
Checking: Lean.ParserDescr.parser.noConfusion... ok
Checking: Acc.ndrec... ok
Checking: Lean.binderPred<_... ok
Checking: CoeOut.mk.noConfusion... ok
Checking: Lean.Parser.Tactic.show... ok
Checking: List.mem_flatten_of_mem... ok
Checking: List.mem_flatMap._simp_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.forall_mem_flatMap._simp_1_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.forall_mem_flatMap._simp_1_2... ok
Checking: List.forall_mem_flatMap... ok
Checking: Lean.Name.recOn... ok
Checking: Lean.Parser.Tactic.simpAll... ok
Checking: List.getLast?_nil... ok
Checking: Lean.MonadNameGenerator.ctorIdx... ok
Checking: Int.ofNat_eq_natCast... ok
Checking: Lean.calc... ok
Checking: _private.Init.PropLemmas.0.forall_apply_eq_imp_iff._simp_1_1... ok
Checking: forall_apply_eq_imp_iff... ok
Checking: Option.min_filter_right... ok
Checking: Option.none_orElse... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.or_of_isSome.match_1_1... ok
Checking: Option.or_of_isSome... ok
Checking: Option.isSome.eq_1... ok
Checking: Std.Format.sbracket... ok
Checking: Option.isSome_of_mem... ok
Checking: Lean.Grind.Config.suggestions... ok
Checking: CoeHTC.ctorIdx... ok
Checking: List.head_eq_of_cons_eq... ok
Checking: Array.emptyWithCapacity_eq... ok
Checking: Lean.Meta.TransparencyMode.instances.elim... ok
Checking: Lean.Parser.Tactic.Conv.convLeft... ok
Checking: _private.Init.Control.Lawful.Instances.0.OptionT.run_orElse.match_1_1... ok
Checking: OptionT.run_orElse... FAIL
Checking: Option.not_lt_filter... ok
Checking: sizeOf_nat... ok
Checking: List.set.eq_2... ok
Checking: StateT.orElse... ok
Checking: Lean.Parser.Tactic.Conv.simp... ok
Checking: Lean.Parser.Tactic.sleep... ok
Checking: Bool.or_eq_left_iff_imp... ok
Checking: Bool.or_eq_left_iff_imp._simp_1... ok
Checking: List.any_eq_true._simp_1... ok
Checking: forall_eq_apply_imp_iff._simp_1... ok
Checking: List.any_replicate... ok
Checking: Nat.mul_two... ok
Checking: Option.pmap_map... ok
Checking: EStateM.Result.error.inj... ok
Checking: Lean.Meta.ExtractLetsConfig.proofs... ok
Checking: term_<->_... ok
Checking: List.map_dropLast... ok
Checking: ite_then_not_self... ok
Checking: peirce'... ok
Checking: Nat.div_self... ok
Checking: List.mem_append_cons_self... ok
Checking: MonadControlT.recOn... ok
Checking: Lean.Parser.Tactic.DecideConfig.recOn... ok
Checking: instReprSubtype... ok
Checking: Nat.not_lt_of_ge... ok
Checking: not_and'... ok
Checking: Lean.binderPred⊂_... ok
Checking: StateT.ext_iff... ok
Checking: List.isPerm... ok
Checking: term_|>_... ok
Checking: Lean.byElab... ok
Checking: ExceptCpsT.runCatch_bind_lift... FAIL
Checking: NatPow.ctorIdx... ok
Checking: reprStr... ok
Checking: Lean.Syntax.instCoeTSyntaxArrayTSepArray... ok
Checking: left_iff_ite_iff... ok
Checking: StateT.bind.eq_1... ok
Checking: Std.Format.MonadPrettyFormat.ctorIdx... ok
Checking: Option.max_eq_some_iff... ok
Checking: term_≈_... ok
Checking: instDecidableEqProd._proof_1... ok
Checking: instDecidableEqProd._proof_2... ok
Checking: instDecidableEqProd._proof_3... ok
Checking: instDecidableEqProd... ok
Checking: Lean.HygieneInfo.mkIdent... ok
Checking: term_×'_... ok
Checking: Lean.infoTreesCmd... ok
Checking: Option.min_eq_right... ok
Checking: UInt8.recOn... ok
Checking: _private.Init.Meta.Defs.0.Lean.evalOptPrio.match_1... ok
Checking: Lean.evalOptPrio... ok
Checking: Array.set.congr_simp... ok
Checking: List.mem_append_left... ok
Checking: Std.Irrefl.irrefl... ok
Checking: _private.Init.Data.List.Basic.0.List.set.match_1.splitter... ok
Checking: List.set.eq_def... ok
Checking: Lean.Syntax.mkSynthetic... ok
Checking: Lean.Parser.Tactic.rcasesPat.quot... ok
Checking: Nat.Linear.Expr.eq_of_toNormPoly... ok
Checking: Option.merge_lt... ok
Checking: LawfulMonadLiftT.casesOn... ok
Checking: Option.get_some... ok
Checking: List.erase.eq_1... ok
Checking: Std.Format.MonadPrettyFormat.currColumn... ok
Checking: Lean.TSyntax.Compat.instCoeTailArraySyntaxTSepArray... ok
Checking: Lean.Parser.Tactic.exact... ok
Checking: List.firstM... ok
Checking: Option.elim_pmap... ok
Checking: Bool.eq_false_imp_eq_true_iff... ok
Checking: Coe.recOn... ok
Checking: Membership.ctorIdx... ok
Checking: Lean.Syntax.brecOn.eq... ok
Checking: List.forA... ok
Checking: List.singleton_inj... ok
Checking: List.lawfulBEq_iff... ok
Checking: Nat.not_add_one_le_self... ok
Checking: Lean.Parser.Tactic.omega... ok
Checking: Bool.toCtorIdx... ok
Checking: Std.Format.FlattenAllowability.allow.inj... ok
Checking: List.all_map... ok
Checking: List.getElem?_set'... ok
Checking: OrOp.mk.noConfusion... ok
Checking: _private.Init.Data.Array.Basic.0.Array.partition.match_1... ok
Checking: Array.partition... ok
Checking: List.contains_flatten... ok
Checking: Lean.ParserDescr.const.sizeOf_spec... ok
Checking: Lean.Parser.Tactic.rintro... ok
Checking: Option.orElse_apply... ok
Checking: Option.filter_eq_none_iff... ok
Checking: Bool.min_eq_and... ok
Checking: List.beq_nil_nil... ok
Checking: Lean.Name.appendIndexAfter... ok
Checking: MonadLift.ctorIdx... ok
Checking: Option.guard_le_some... ok
Checking: HSMul.ctorIdx... ok
Checking: Lean.Meta.Rewrite.Config.mk.inj... ok
Checking: Std.Format.append.sizeOf_spec... ok
Checking: StateT.instLawfulMonadLift... ok
Checking: term{_:_//_}... ok
Checking: Lean.Parser.Category.tactic... ok
Checking: Option.dite_none_left_eq_some... ok
Checking: Lean.NameGenerator.recOn... ok
Checking: MonadExcept.recOn... ok
Checking: Classical.choice.congr_simp... ok
Checking: _private.Init.Data.List.Lemmas.0.List.length_eq_one_iff.match_1_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.length_eq_one_iff.match_1_3... ok
Checking: List.length_eq_one_iff... ok
Checking: precMin1... ok
Checking: List.elem_nil... ok
Checking: Lean.Meta.Occurrences.neg.injEq... ok
Checking: instCoeTC... ok
Checking: Lean.Internal.isStage0... ok
Checking: Lean.Meta.TransparencyMode.default.elim... ok
Checking: List.replace_cons... ok
Checking: List.head_dropLast._proof_1... ok
Checking: List.head_dropLast... ok
Checking: unexpandSubtype... ok
Checking: Lean.Parser.Tactic.rcasesPat.one... ok
Checking: Option.min_some_none... ok
Checking: ite_then_self... ok
Checking: Lean.Parser.Tactic.simpa... ok
Checking: Lean.Meta.Simp.ConfigCtx.toConfig... ok
Checking: List.isEqv_cons_nil... ok
Checking: Nat.Linear.Poly.insert.eq_1... ok
Checking: List.append_eq... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.pred_inj.match_1_1... ok
Checking: Nat.pred_inj... ok
Checking: Bool.eq_false_or_eq_true_self... ok
Checking: Lean.Parser.Tactic.Grind.first... ok
Checking: Lean.ParserDescr.recOn... ok
Checking: _private.Init.NotationExtra.0.unexpandArrayEmpty.match_1... ok
Checking: unexpandArrayEmpty... ok
Checking: Lean.Grind.Config.extAll... ok
Checking: Lean.Parser.Attr.grind... ok
Checking: or_self_left... ok
Checking: ToString.mk.noConfusion... ok
Checking: Std.Format.nest.inj... ok
Checking: Option.pbind_eq_none_iff... ok
Checking: SDiff.ctorIdx... ok
Checking: instToStringUInt16... ok
Checking: Id.instMonadLiftTOfPure... ok
Checking: Id.instLawfulMonadLiftTOfLawfulMonad... ok
Checking: Prod.map_comp_swap... FAIL
Checking: HasSSubset.recOn... ok
Checking: Option.pmap.congr_simp... ok
Checking: Prod.map_id... FAIL
Checking: List.foldl_eq_foldr_reverse... ok
Checking: Lean.Loop._sizeOf_1... ok
Checking: Lean.Loop._sizeOf_inst... ok
Checking: Lean.Loop.mk.sizeOf_spec... ok
Checking: EST.throw... ok
Checking: ToBool.mk.noConfusion... ok
Checking: _private.Init.Meta.Defs.0.Lean.instQuoteNameMkStr1.match_1... ok
Checking: _private.Init.Meta.Defs.0.Lean.getEscapedNameParts?... ok
Checking: String.Internal.intercalate... ok
Checking: Lean.instQuoteNameMkStr1._private_1... ok
Checking: Lean.instQuoteNameMkStr1... ok
Checking: List.foldr_rel... ok
Checking: instIdempotentOpOr... ok
Checking: _private.Init.Prelude.0.instNonemptyOfMonad.match_1... ok
Checking: instNonemptyOfMonad... ok
Checking: Option.pmap_eq_none_iff... ok
Checking: Nat.add_one_ne_self... ok
Checking: List.eraseIdx_cons_succ... FAIL
Checking: List.foldrRecOn_nil... ok
Checking: strictOr... ok
Checking: Bool.cond_not... ok
Checking: instDecidableEqRaw.match_3... ok
Checking: ReaderM... ok
Checking: Option.isSome_eq_false_iff._simp_1... ok
Checking: Option.isSome_pbind_iff... ok
Checking: List.reduceOption... ok
Checking: ite_eq_left_iff... ok
Checking: Option.guard_false... ok
Checking: List.filter_flatten... ok
Checking: instSubUSize... ok
Checking: Lean.Syntax.SepArray._sizeOf_1... ok
Checking: Lean.Syntax.SepArray._sizeOf_inst... ok
Checking: Lean.Syntax.SepArray.mk.sizeOf_spec... ok
Checking: term_\_... ok
Checking: Lean.Meta.Omega.OmegaConfig.mk.injEq... ok
Checking: Std.RightIdentity.recOn... ok
Checking: Lean.Syntax.node.inj... ok
Checking: Option.some_bind... ok
Checking: _private.Init.PropLemmas.0.Decidable.not_and_not_right.match_1_1... ok
Checking: Decidable.not_and_not_right... ok
Checking: Option.map_inj_right... ok
Checking: UInt8.instOfNat... ok
Checking: Lean.Parser.Tactic.Grind.instantiate... ok
Checking: instMonadEvalOfMonadLift... ok
Checking: List.append_inj_left... ok
Checking: UInt64.ofNatTruncate._proof_1... TIMEOUT
Checking: UInt64.ofNatTruncate... ok
Checking: StateT.failure... ok
Checking: Nat.eq_zero_of_not_pos... ok
Checking: HSub.ctorIdx... ok
Checking: instToStringSigma.match_1... ok
Checking: instToStringSigma... ok
Checking: List.filter.eq_1... ok
Checking: Substring.Raw.Internal.beq... ok
Checking: Except.orElseLazy... ok
Checking: Array.flatten... ok
Checking: Dvd.mk.noConfusion... ok
Checking: _private.Init.Data.Option.Instances.0.Option.eq_of_eq_some.match_1_1... ok
Checking: Option.eq_of_eq_some... ok
Checking: _private.Init.Data.List.Lemmas.0.List.eq_nil_or_concat.match_1_3... ok
Checking: _private.Init.Data.List.Lemmas.0.List.eq_nil_or_concat.match_1_1... ok
Checking: List.eq_nil_or_concat... ok
Checking: Lean.Parser.Tactic.mrightMacro... ok
Checking: Nat.ctor_eq_zero... ok
Checking: Lean.Syntax.Preresolved.namespace.noConfusion... ok
Checking: term_×_... ok
Checking: String.Internal.offsetOfPos... ok
Checking: DoResultPRBC.break.sizeOf_spec... ok
Checking: Array.getLit.congr_simp... ok
Checking: List.map_const_fun... FAIL
Checking: Lean.Macro.Methods.recOn... ok
Checking: term_∧_... ok
Checking: Sum.inr.elim... ok
Checking: Bool.instLawfulIdentityBeqTrue... ok
Checking: Id.instOfNat... ok
Checking: Option.get_join... ok
Checking: Int.instLawfulBEq... ok
Checking: _private.Init.Data.List.Lemmas.0.List.ne_nil_of_length_pos.match_1_1... ok
Checking: List.ne_nil_of_length_pos... ok
Checking: Task._sizeOf_1... ok
Checking: Task._sizeOf_inst... ok
Checking: Task.pure.sizeOf_spec... ok
Checking: CoeTail.recOn... ok
Checking: Bool.not_eq_self... ok
Checking: Quotient.rec... ok
Checking: getElem_congr_coll... ok
Checking: List.takeWhile_nil... ok
Checking: Lean.Parser.Tactic.Grind.grind_filterGen<=_... ok
Checking: Eq.recOn... ok
Checking: _private.Init.Core.0.eqRec_heq.match_1_1... ok
Checking: eqRec_heq... ok
Checking: instDecidableDite... ok
Checking: recSubsingleton... ok
Checking: instInhabitedProp... ok
Checking: unexpandMkArray0... ok
Checking: List.not_mem_append... ok
Checking: StateT.run_get... FAIL
Checking: List.countP... ok
Checking: List.count... ok
Checking: instToStringList... ok
Checking: Array.instToString... ok
Checking: Alternative.ctorIdx... ok
Checking: Option.getDM_some... FAIL
Checking: List.replicate_eq_nil_iff... ok
Checking: List.replicate_eq_nil_iff._simp_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.eq_replicate_or_eq_replicate_append_cons.match_1_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.eq_replicate_or_eq_replicate_append_cons.match_1_3... ok
Checking: List.eq_replicate_or_eq_replicate_append_cons... ok
Checking: List.replicateRecOn._unary... ok
Checking: List.replicateRecOn... ok
Checking: Lean.Parser.Tactic.tacticUnhygienic_... ok
Checking: Option.eq_none_or_eq_some... ok
Checking: List.findSomeRev?... ok
Checking: term_⊆_... ok
Checking: Lean.Grind.Config.mbtc... ok
Checking: ExceptCpsT.runCatch_throw... FAIL
Checking: Add.mk.noConfusion... ok
Checking: ULift.up_down... ok
Checking: Nat.Linear.Poly.denote_le.eq_1... ok
Checking: forall_self_imp... ok
Checking: Fin.instDiv... ok
Checking: List.and_any_distrib_right... ok
Checking: Relation.TransGen.trans... ok
Checking: ite_else_not_self... ok
Checking: ExceptT.instLawfulMonadLift... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.bind_eq_none'._simp_1_1... ok
Checking: Option.bind_eq_none'... ok
Checking: List.mem_nil_iff... ok
Checking: ExceptCpsT.runCatch.eq_1... ok
Checking: instReprId_1... ok
Checking: Lean.Parser.Tactic.liftLets... ok
Checking: List.nil_removeAll... ok
Checking: Lean.Parser.Tactic.nativeDecide... ok
Checking: List.forall_mem_map... ok
Checking: or_or_distrib_left... ok
Checking: Lean.RArray.recOn... ok
Checking: Lean.Parser.Tactic.tacticNofun... ok
Checking: HOrElse.recOn... ok
Checking: PUnit.eq_punit... ok
Checking: Unit.ext... ok
Checking: Lean.Parser.Tactic.mpureIntroMacro... ok
Checking: Lean.reduceBool... ok
Checking: Lean.ofReduceBool... ok
Checking: Hashable.recOn... ok
Checking: Nat.succ.elim... ok
Checking: _private.Init.Data.List.Lemmas.0.List.flatten_filter_ne_nil._simp_1_1... ok
Checking: List.flatten_filter_ne_nil... ok
Checking: Option.some_beq_some... ok
Checking: Std.LawfulCommIdentity.casesOn... ok
Checking: Hashable.hash... ok
Checking: HMul.ctorIdx... ok
Checking: List.foldlM_nil... FAIL
Checking: EST.Out.recOn... ok
Checking: Lean.Quote.recOn... ok
Checking: Lean.NameGenerator.mkChild... ok
Checking: List.length.eq_2... ok
Checking: Nat.lt_add_one_iff_lt_or_eq... ok
Checking: List.flatMap_def... ok
Checking: OrElse.noConfusion... ok
Checking: OrElse.mk.noConfusion... ok
Checking: ULift.up.inj... ok
Checking: Classical.ite_not... ok
Checking: MonadFunctor.mk.noConfusion... ok
Checking: Lean.Parser.Tactic.Conv.failIfSuccess... ok
Checking: ByteArray.mk.sizeOf_spec... ok
Checking: Std.Format.FlattenAllowability.recOn... ok
Checking: Lean.Parser.checkSimp... ok
Checking: Int.toNat?... ok
Checking: List.tailD_cons... ok
Checking: instCoeOutOfCoeSort... ok
Checking: Lean.Parser.Tactic.substEqs... ok
Checking: Array.size.eq_1... ok
Checking: term_<|>_... ok
Checking: term[_]... ok
Checking: Lean.RArray.leaf.sizeOf_spec... ok
Checking: _private.Init.Meta.Defs.0.Lean.TSyntax.isHexNum?... ok
Checking: Lean.TSyntax.getHexNumVal... ok
Checking: Option.sequence_some... FAIL
Checking: OptionT.run_failure... FAIL
Checking: Option.isNone_guard... ok
Checking: BEq.symm_false... ok
Checking: Bool.instAssociativeBne... ok
Checking: Nat.pred_eq_sub_one... ok
Checking: List.sum_cons... ok
Checking: Lean.Meta.Occurrences.recOn... ok
Checking: ite_then_decide_self... ok
Checking: Except.map.eq_1... ok
Checking: term_≠_... ok
Checking: instToStringChar... ok
Checking: Trans.trans... ok
Checking: MProd.mk.injEq... ok
Checking: Lean.Parser.Tactic.bvDecideMacro... ok
Checking: _private.Init.Data.List.Basic.0.List.concat.match_1.splitter... ok
Checking: List.concat.eq_def... ok
Checking: Lean.Name.num.sizeOf_spec... ok
Checking: Sub.ctorIdx... ok
Checking: HSub.noConfusion... ok
Checking: HSub.mk.noConfusion... ok
Checking: controlAt... ok
Checking: control... ok
Checking: List.getD_cons_succ... ok
Checking: boolRelToRel... ok
Checking: List.set_cons_zero... ok
Checking: DoResultPRBC.break.injEq... ok
Checking: List.filterMapM... ok
Checking: _private.Init.Data.Option.Lemmas.0.Option.get_mem.match_1_1... ok
Checking: Option.get_mem... ok
Checking: Sum.inl.elim... ok
Checking: Array.toListLitAux.eq_1... ok
Checking: List.isEqv.eq_2... ok
Checking: Std.Format.indentD... ok
Checking: Nat.one_mod_eq_zero_iff._simp_1... ok
Checking: Nat.zero_eq_one_mod_iff... ok
Checking: Bool.eq_not_self... ok
Checking: List.exists_of_mem_map... ok
Checking: Nat.div.go.eq_def... ok
Checking: PLift.up.inj... ok
Checking: ST.Out.val... ok
Checking: Lean.Parser.Tactic.left... ok
Checking: Lean.Parser.Tactic.Grind.grind_filter_... ok
Checking: Option.join_beq_none... ok
Checking: Bool.or_eq_true_iff... ok
Checking: Bool.beq_comm... ok
Checking: PLift.recOn... ok
Checking: List.nil_of_isEmpty... ok
Checking: Option.filter_pbind... ok
Checking: Int.ofNat.injEq... ok
Checking: Option.filter_guard... ok
Checking: Nat.Linear.PolyCnstr.mk.injEq... ok
Checking: Bool.le_total... ok
Checking: neZero_zero_iff_false._simp_1... ok
Checking: Nat.sub_mod_add_mod_cancel... ok
Checking: Sigma.ext_iff... ok
Checking: List.flatMap_assoc... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.pow_left_inj.match_1_1... ok
Checking: Nat.pow_left_inj... ok
Checking: Functor.recOn... ok
Checking: Option.any_join... ok
Checking: Lean.Parser.Syntax.subPrec... ok
Checking: Bool.false.sizeOf_spec... ok
Checking: Membership.recOn... ok
Checking: Nat.instCommutativeHAdd... ok
Checking: instReprSigma... ok
Checking: true_iff_false... ok
Checking: Lean.Parser.Tactic.letToHave... ok
Checking: Option.guard_beq_none... ok
Checking: Task.pure.inj... ok
Checking: Lean.Syntax.getTrailingTailPos?... ok
Checking: List.filter_replicate_of_neg... ok
Checking: _private.Init.Data.List.Lemmas.0.List.forall_mem_append._simp_1_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.forall_mem_append._simp_1_2... ok
Checking: List.forall_mem_append... ok
Checking: Option.dite_none_left_eq_some._simp_1... ok
Checking: Option.mem_dite_none_left... ok
Checking: Thunk.ext_iff... ok
Checking: StateRefT'.instAlternativeOfMonad... ok
Checking: Function.const.eq_1... ok
Checking: unexpandEqRec... ok
Checking: Lean.Parser.discrTreeKeyCmd... ok
Checking: PULift.up.injEq... ok
Checking: panicWithPos... ok
Checking: decide_eq_decide._simp_1... ok
Checking: decide_implies... ok
Checking: ReflBEq.casesOn... ok
Checking: One.ctorIdx... ok
Checking: _private.Init.Data.List.Basic.0.List.mapTR.loop.match_1.splitter... ok
Checking: List.mapTR.loop.eq_def... ok
Checking: Bool.le_antisymm... ok
Checking: Lean.TSyntax.mk.noConfusion... ok
Checking: Setoid.recOn... ok
Checking: List.getElem_of_eq... ok
Checking: List.forM_cons... FAIL
Checking: Inhabited.recOn... ok
Checking: Nat.divExact_eq_div... ok
Checking: List.replicate_one... ok
Checking: eq_iff_true_of_subsingleton... ok
Checking: Option.all_some... ok
Checking: EST.Out.ok.sizeOf_spec... ok
Checking: List.findRev?... ok
Checking: _private.Init.Data.Array.Basic.0.Array.allDiffAux._proof_1... ok
Checking: _private.Init.Data.Array.Basic.0.Array.allDiffAuxAux.match_1... ok
Checking: _private.Init.Data.Array.Basic.0.Array.allDiffAuxAux._proof_1... ok
Checking: _private.Init.Data.Array.Basic.0.Array.allDiffAuxAux... ok
Checking: _private.Init.Data.Array.Basic.0.Array.allDiffAux._proof_2... ok
Checking: _private.Init.Data.Array.Basic.0.Array.allDiffAux... ok
Checking: Array.allDiff... ok
Checking: ForIn.ctorIdx... ok
Checking: tacticDecreasing_with_... ok
Checking: Lean.TSyntax.getName... ok
Checking: HPow.mk.noConfusion... ok
Checking: List.all_congr... ok
Checking: _private.Init.Data.Prod.0.Prod.forall.match_1_1... ok
Checking: Prod.forall... ok
Checking: Lean.Name.mkStr6... ok
Checking: Lean.Parser.Category.grind_ref... ok
Checking: Nat.le_lt_asymm... ok
Checking: Fin.decLe... ok
Checking: HShiftRight.noConfusionType... ok
Checking: HShiftRight.noConfusion... ok
Checking: Prod.lexLt_def... ok
Checking: Std.instCommutativeAnd... ok
Checking: Thunk.pure... ok
Checking: ULift.ctorIdx... ok
Checking: Lean.Syntax.ident.inj... ok
Checking: Lean.Parser.Tactic.Grind.grind_filter_||_... ok
Checking: HSMul.recOn... ok
Checking: List.foldr_filter... ok
Checking: Nat.lt.step... ok
Checking: Nat.lt_add_one_of_lt... ok
Checking: Lean.Meta.ExtractLetsConfig.ctorIdx... ok
Checking: _private.Init.Data.List.BasicAux.0.List.partitionMap.go.match_3... ok
Checking: _private.Init.Data.List.BasicAux.0.List.partitionMap.go.match_1... ok
Checking: _private.Init.Data.List.BasicAux.0.List.partitionMap.go... ok
Checking: List.partitionMap... ok
Checking: PLift.up_down... ok
Checking: Option.dite_none_right_eq_some._simp_1... ok
Checking: Option.mem_dite_none_right... ok
Checking: Option.ext_iff... ok
Checking: StateCpsT.runK_monadLift... ok
Checking: Array.singleton... ok
Checking: Fin.pred._proof_1... ok
Checking: Fin.pred._proof_2... ok
Checking: Fin.pred... TIMEOUT
Checking: UInt16.toUInt32._proof_1... ok
Checking: UInt16.toUInt32._proof_2... ok
Checking: UInt16.toUInt32... ok
Checking: Option.orElse_fun_none... ok
Checking: Sigma.mk.inj... ok
Checking: UInt64._sizeOf_1... ok
Checking: UInt64._sizeOf_inst... ok
Checking: UInt64.ofBitVec.sizeOf_spec... ok
Checking: beq_false_of_ne... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.sub_lt_sub_right.match_1_1... ok
Checking: Nat.sub_lt_sub_right... ok
Checking: false_of_true_iff_false... ok
Checking: Lean.ParserDescr.nodeWithAntiquot.sizeOf_spec... ok
Checking: List.leftpad_prefix... ok
Checking: instCoeTailIntOfIntCast... ok
Checking: Lean.Meta.TransparencyMode.default.sizeOf_spec... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.exists_eq_add_one_of_ne_zero.match_1_1... ok
Checking: Nat.exists_eq_add_one_of_ne_zero... ok
Checking: Bool.xor_self... TIMEOUT
Checking: Nat.succ_le_iff... ok
Checking: Array.instLE... ok
Checking: Nat.Linear.Expr.recOn... ok
Checking: instDecidableEqRaw.match_1... ok
Checking: instDecidableEqRaw._proof_1... ok
Checking: instDecidableEqRaw._proof_2... ok
Checking: instDecidableEqRaw... ok
Checking: dite_eq_right_iff._simp_1... ok
Checking: Option.choice_eq_none_iff_not_nonempty... ok
Checking: HasEquiv.mk.noConfusion... ok
Checking: EStateM.Result.error.elim... ok
Checking: Option.all_eq_false_iff_get... ok
Checking: false_of_true_eq_false... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.eq_zero_or_eq_sub_one_add_one.match_1_1... ok
Checking: Nat.eq_zero_or_eq_sub_one_add_one... ok
Checking: term-_... ok
Checking: Char.toUpper... ok
Checking: Option.map_orElse... ok
Checking: Std.LawfulLeftIdentity.recOn... ok
Checking: String.toName... ok
Checking: HomogeneousPow.ctorIdx... ok
Checking: Option.comp_map... ok
Checking: _private.Init.Data.List.Lemmas.0.List.mem_set._simp_1_1... ok
Checking: List.mem_set... ok
Checking: Array.modifyOp... ok
Checking: Std.Refl.casesOn... ok
Checking: tacticDeriving_LawfulEq_tactic_step... ok
Checking: Std.Format.FlattenBehavior.fill.sizeOf_spec... ok
Checking: Int.ofNat_eq_coe... ok
Checking: UInt16.ofBitVec.inj... ok
Checking: List.get_cons_zero... TIMEOUT
Checking: String.Pos.Raw.mk.inj... ok
Checking: Option.pfilter_join... ok
Checking: List.isEqv_nil_cons... ok
Checking: Char.toLower... ok
Checking: Bool.ite_eq_false_distrib... ok
Checking: Decidable.isTrue.sizeOf_spec... ok
Checking: instInhabitedUInt32._proof_1... ok
Checking: instInhabitedUInt32... ok
Checking: instInhabitedULift... ok
Checking: UInt16.toUInt8... ok
Checking: EStateM.Result.error.sizeOf_spec... ok
Checking: Nat.two_pow_pos... ok
Checking: Option.isNone_choice_iff_not_nonempty... ok
Checking: Option.get!_or... ok
Checking: _private.Init.Data.List.Lemmas.0.List.mem_of_mem_cons_of_mem.match_1_1... ok
Checking: List.mem_of_mem_cons_of_mem... ok
Checking: List.map_inj_left._simp_1... ok
Checking: List.map_eq_map_iff... ok
Checking: instDecidableEqUInt64... ok
Checking: PProd.mk.injEq... ok
Checking: _private.Init.Data.Repr.0.Prod.repr.match_1... ok
Checking: Prod.repr... ok
Checking: List.foldr_cons... FAIL
Checking: List.partition.loop.eq_2... ok
Checking: Nat.Linear.Poly.isNonZero.eq_def... ok
Checking: HAdd.recOn... ok
Checking: List.filterMap.eq_2... FAIL
Checking: instCoeHTCOfCoeHeadOfCoeOTC... ok
Checking: MonadFinally.ctorIdx... ok
Checking: seq_eq_bind... ok
Checking: List.elem_eq_mem... ok
Checking: Inv.ctorIdx... ok
Checking: Lean.Syntax.instCoeArraySepArray... ok
Checking: Lean.setLibrarySuggestionsCmd... ok
Checking: Lean.Grind.Config.matchEqs... ok
Checking: Nat.add_mod_left... ok
Checking: Lean.Grind.Config.lookahead... ok
Checking: Option.max_join_left._proof_1... ok
Checking: Option.max_join_left... ok
Checking: List.findM?_id... FAIL
Checking: _private.Init.Core.0.Subtype.eq.match_1_1... ok
Checking: Subtype.eq... ok
Checking: List.findSomeM?_cons... ok
Checking: Option.decidableExistsMem.match_1... ok
Checking: Option.decidableExistsMem._proof_1... ok
Checking: Option.decidableExistsMem._proof_2... ok
Checking: Option.decidableExistsMem._proof_3... ok
Checking: Option.decidableExistsMem... ok
Checking: Max.mk.noConfusion... ok
Checking: Lean.Elab.Tactic.Ext.ext... ok
Checking: Std.Asymm.recOn... ok
Checking: instReprProdOfReprTuple... ok
Checking: Lean.TSyntax.getString... ok
Checking: Bool.eq_not_self_or... ok
Checking: _private.Init.Core.0.Bool.of_not_eq_false.match_1_1... ok
Checking: Bool.of_not_eq_false... ok
Checking: Substring.Raw.Internal.front... ok
Checking: HAnd.ctorIdx... ok
Checking: Char.ext_iff... ok
Checking: Prod.eta... ok
Checking: List.elem_cons_self... ok
Checking: Iff.casesOn... ok
Checking: term_∨_... ok
Checking: Option.isSome_some... ok
Checking: Option.idempotentOp_merge... ok
Checking: StateCpsT.runK_pure... FAIL
Checking: ULift.down_up... ok
Checking: MonadExceptOf.mk.noConfusion... ok
Checking: Bool.not_and_eq_left_iff_and... ok
Checking: Lean.Syntax.Tactic... ok
Checking: HShiftRight.mk.noConfusion... ok
Checking: Bool.eq_not_of_ne... ok
Checking: Int.negSucc.sizeOf_spec... ok
Checking: Option.get_congr... ok
Checking: Lean.Parser.Tactic.showTermElab... ok
Checking: Bool.if_false_left... ok
Checking: List.term_<+:_... ok
Checking: beq_self_eq_true'... ok
Checking: Lean.ParserDescr.symbol.noConfusion... ok
Checking: getElem_congr... ok
Checking: WellFoundedRelation.mk.noConfusion... ok
Checking: Lean.Parser.Tactic.Conv.delta... ok
Checking: Lean.Parser.Tactic.DecideConfig.native... ok
Checking: Inv.inv... ok
Checking: Array.mem_toArray... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.isIdOrAtom?._sparseCasesOn_1... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.isIdOrAtom?.match_1... ok
Checking: Lean.Syntax.isIdOrAtom?... ok
Checking: List.forM_eq_forM... ok
Checking: instMonadFinallyStateRefT'... ok
Checking: Std.Format.FlattenBehavior.toCtorIdx... ok
Checking: Option.pbind_eq_some_iff... ok
Checking: term_<<<_... ok
Checking: Nat.Linear.Poly.cancelAux.eq_4... ok
Checking: Lean.Meta.ExtractLetsConfig.merge... ok
Checking: Function.const_apply... ok
Checking: _private.Init.Data.List.Lemmas.0.List.getElem!_cons_succ._simp_1_1... ok
Checking: List.getElem!_cons_succ... ok
Checking: Option.bind_apply... ok
Checking: Lean.Parser.Tactic.Conv.dsimp... ok
Checking: Nat.mul_sub... ok
Checking: Iff.elim... ok
Checking: List.removeAll.eq_1... ok
Checking: if_false... ok
Checking: List.reverseAux.eq_def... ok
Checking: List.getElem_of_append._proof_1... ok
Checking: List.getElem_of_append... ok
Checking: Lean.Meta.CheckTactic.CheckGoalType.recOn... ok
Checking: Array.flatMap... ok
Checking: Nat.Linear.Expr.toNormPoly.eq_1... ok
Checking: List.getLast_of_mem_getLast?... ok
Checking: termΣ'_,_... ok
Checking: Nat.lt_of_le_pred... ok
Checking: _private.Init.Data.List.Lemmas.0.List.flatMap_eq_nil_iff._simp_1_1... ok
Checking: _private.Init.Data.List.Lemmas.0.List.flatMap_eq_nil_iff._simp_1_2... ok
Checking: _private.Init.Data.List.Lemmas.0.List.flatMap_eq_nil_iff._simp_1_3... ok
Checking: List.flatMap_eq_nil_iff... ok
Checking: tacticDeriving_LawfulEq_tactic... ok
Checking: Lean.Meta.Occurrences.all.sizeOf_spec... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.pred_lt_pred.match_1_1... ok
Checking: Nat.pred_lt_pred... ok
Checking: boolIfThenElse... ok
Checking: Option.or_eq_some_iff._simp_1... ok
Checking: Option.orElse_eq_some_iff... ok
Checking: List.contains_iff_exists_mem_beq... ok
Checking: List.leftpadTR.eq_1... ok
Checking: Bool.bne_self_right... TIMEOUT
Checking: List.any_eq_false... ok
Checking: Lean.Parser.Tactic.Conv.withAnnotateState... ok
Checking: Option.join_pfilter... ok
Checking: NonScalar._sizeOf_1... ok
Checking: NonScalar._sizeOf_inst... ok
Checking: NonScalar.mk.sizeOf_spec... ok
Checking: Lean.Syntax.TSepArray.push... ok
Checking: instTransEq... ok
Checking: term_<&>_... ok
Checking: List.filter_replicate_of_pos... ok
Checking: Lean.ParserDescr.cat.noConfusion... ok
Checking: Nat.Linear.Expr.toPoly.go.eq_5... ok
Checking: ReaderT.run_mapConst... FAIL
Checking: List.mapM... ok
Checking: instReprUInt8... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.toNat.match_1... ok
Checking: Lean.Syntax.toNat... ok
Checking: and_and_left... ok
Checking: Nat.Linear.instBEqPolyCnstr.beq_spec_2... ok
Checking: List.eq_getElem_of_length_eq_four._proof_1... ok
Checking: List.eq_getElem_of_length_eq_four._proof_2... ok
Checking: List.eq_getElem_of_length_eq_four._proof_3... ok
Checking: List.eq_getElem_of_length_eq_four._proof_4... ok
Checking: _private.Init.Data.List.Lemmas.0.List.eq_getElem_of_length_eq_four.match_1_1... ok
Checking: List.eq_getElem_of_length_eq_four... ok
Checking: Option.le.eq_1... ok
Checking: Option.pmap_some... ok
Checking: Lean.Grind.Config.trace... ok
Checking: Option.guard_eq_none_iff... ok
Checking: Lean.TSyntax.getScientific... ok
Checking: List.idRun_findSomeM?... FAIL
Checking: Function.true_comp... ok
Checking: Option.pmap_eq_map... ok
Checking: List.set_append_right... ok
Checking: instMonadFinallyST... ok
Checking: Lean.Parser.Tactic.Grind.showAsserted... ok
Checking: NonScalar.val... ok
Checking: Nat.shiftRight_le... ok
Checking: Lean.Parser.Tactic.Grind.exposeNames... ok
Checking: Nat.le.recOn... ok
Checking: instCoeTCOfCoe... ok
Checking: Monad.recOn... ok
Checking: let_val_congr... ok
Checking: StateCpsT.runK_modify... ok
Checking: List.getLast!_cons_eq_getLastD... ok
Checking: Classical.byContradiction... ok
Checking: Nat.toSuperscriptString... ok
Checking: Substring.Raw.recOn... ok
Checking: Nat.mul_mod_left... ok
Checking: Option.some.elim... ok
Checking: List.set_nil... ok
Checking: LE.recOn... ok
Checking: ite_cond_congr... ok
Checking: Lean.Parser.Tactic.DecideConfig.kernel... ok
Checking: and_not_self_iff... ok
Checking: dbgStackTrace... ok
Checking: List.Perm.casesOn... ok
Checking: instCoeT... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.pred_le_iff_le_succ.match_1_1... ok
Checking: Nat.pred_le_iff_le_succ... ok
Checking: Bool.or_eq_decide... ok
Checking: EST.Out.ok.inj... ok
Checking: not_iff_self... ok
Checking: Lean.Parser.Tactic.rotateLeft... ok
Checking: Array.ctorIdx... ok
Checking: Subtype.eta... ok
Checking: Option.isSome_none... ok
Checking: Option.merge.eq_2... ok
Checking: Lean.Loop.noConfusion... ok
Checking: AndThen.mk.noConfusion... ok
Checking: Lean.Parser.Tactic.grind... ok
Checking: List.utf8Encode.eq_1... ok
Checking: List.get_eq_getElem... ok
Checking: Lean.Module.mk.injEq... ok
Checking: Option.min_join_left... ok
Checking: List.mem_concat_self... ok
Checking: Bool.and_or_inj_left... ok
Checking: Except.instMonad.eq_1... ok
Checking: Decidable.peirce... ok
Checking: Lean.Elab.Tactic.Ext.applyExtTheorem... ok
Checking: List.headD_eq_head?_getD... ok
Checking: _private.Init.Data.Nat.Linear.0.Nat.Linear.Poly.denote_cons.match_1_1... ok
Checking: Nat.Linear.Poly.denote_cons... ok
Checking: instSMulOfMul... ok
Checking: PNonScalar.recOn... ok
Checking: List.tail_eq_tail?... ok
Checking: tryFinally... ok
Checking: _private.Init.Data.List.Basic.0.List.replicateTR.loop.match_1.splitter... ok
Checking: List.replicateTR.loop.eq_def... ok
Checking: Bool.not_or_self... ok
Checking: List.getElem_mem._simp_1... ok
Checking: List.mem_of_getElem... ok
Checking: Lean.Parser.Tactic.tacticExact_mod_cast_... ok
Checking: Not.imp... ok
Checking: _private.Init.Data.List.Basic.0.List.length_eq_lengthTR._simp_1_2... ok
Checking: List.length_eq_lengthTR... ok
Checking: Bool.toInt_true... ok
Checking: List.mem_ite_nil_right... ok
Checking: Option.bind_map... ok
Checking: List.eraseDupsBy.eq_1... ok
Checking: UInt32.ofBitVec.sizeOf_spec... ok
Checking: List.min... ok
Checking: Array.filterRevM... ok
Checking: ShiftRight.mk.noConfusion... ok
Checking: Unit.sizeOf... FAIL
Checking: _private.Init.Data.List.Lemmas.0.List.head?_eq_getElem?.match_1_1... ok
Checking: List.head?_eq_getElem?... ok
Checking: LawfulMonad.map_map... ok
Checking: List.some_eq_getElem?_iff... ok
Checking: Nat.le_succ_of_pred_le... ok
Checking: Int.blt'... ok
Checking: Std.Commutative.casesOn... ok
Checking: and_and_right... ok
Checking: List.flatten_concat... ok
Checking: Lean.Parser.Tactic.Grind.done... ok
Checking: List.getElem_cons_zero... ok
Checking: Lean.Parser.Tactic.applyAssumption... ok
Checking: List.head_tail... ok
Checking: Nat.Linear.Expr.add.injEq... ok
Checking: binderNameHint.eq_1... ok
Checking: List.zipWith_nil_left... ok
Checking: CoeT.recOn... ok
Checking: Nat.instTransLt... ok
Checking: _private.Init.Data.Nat.Bitwise.Basic.0.Nat.shiftLeft_eq.match_1_1... ok
Checking: Nat.shiftLeft_eq... ok
Checking: Option.isEqSome.eq_1... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.or_exists_add_one.match_1_1... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.or_exists_add_one.match_1_5... ok
Checking: _private.Init.Data.Nat.Basic.0.Nat.or_exists_add_one.match_1_3... ok
Checking: Nat.or_exists_add_one... ok
Checking: HShiftLeft.recOn... ok
Checking: Nat.instAntisymmNotLt... ok
Checking: BitVec.instOfNat... ok
Checking: List.unzip_eq_unzipTR... FAIL
Checking: Nat.zero_lt_two... ok
Checking: lt_of_eq_of_lt... ok
Checking: Option.any_guard... ok
Checking: List.filterMap_replicate_of_none... ok
Checking: HSMul.mk.noConfusion... ok
Checking: ite_true... ok
Checking: List.intersperse.eq_3... ok
Checking: _private.Init.Meta.Defs.0.Lean.Syntax.unsetTrailing.match_1... ok
Checking: Lean.Syntax.unsetTrailing... ok
Checking: unexpandMkArray1... ok
Checking: instInhabitedForInStep... ok
Checking: Lean.Meta.Simp.NormCastConfig._sizeOf_1... ok
Checking: Lean.Meta.Simp.NormCastConfig._sizeOf_inst... ok
Checking: Lean.Meta.Simp.NormCastConfig.mk.sizeOf_spec... ok
Checking: Lean.Meta.Simp.Config.mk.injEq... ok
Checking: Lean.Parser.Tactic.injection... ok
Checking: List.all_flatMap... ok
Checking: instInhabitedExceptTOfMonad... ok
Checking: Lean.Parser.Tactic.Grind.grind·._... ok
Checking: List.getLast_append_right._proof_1... ok
Checking: List.getLast_append_right... ok
Checking: Array.filterM... ok
Checking: List.reverseAux_cons... ok
Checking: Inhabited.mk.noConfusion... ok
Checking: MonadFunctorT.recOn... ok
Checking: DoResultPR.return.sizeOf_spec... ok
Checking: DoResultPRBC.recOn... ok
Checking: ExceptCpsT.instInhabited... ok
Checking: Lean.Meta.ExtractLetsConfig.implicits... ok
Checking: List.range'TR.go.eq_1... ok
Checking: Id.finally... ok
Checking: Nat.lt_sub_of_add_lt... ok
Checking: Lean.Meta.EtaStructMode.none.elim... ok
Checking: StateT.instAlternative... ok
Checking: Nat.le_step... ok
Checking: Lean.Parser.Tactic.clear... ok
Checking: XorOp.ctorIdx... ok
Checking: Lean.Parser.commandUnseal__... ok
Checking: term_×'__1... ok
Checking: Option.filter_eq_none_iff._simp_1... ok
Checking: Option.filter_some_eq_none... ok
Checking: term__[_]_?... ok
Checking: Bind.kleisliLeft... ok
Checking: List.foldl_filter... ok
Checking: NatCast.recOn... ok
Checking: List.foldl_flip_append_eq_append... ok
Checking: List.erase_nil... ok
Checking: Std.Antisymm.recOn... ok
Checking: Array.findRev?... ok
Checking: instMonadExceptOfEST... ok
Checking: Option.isSome_of_eq_some... ok
Checking: Array.filter... ok
Checking: instHashableSubtype... ok
Checking: List.tail_nil... ok
Checking: Option.min_eq_left... ok
Checking: Lean.Module.mk.inj... ok
Checking: MonadEvalT.recOn... ok
Checking: Sum.nonemptyRight... ok
Checking: List.head?_tail... ok
Checking: StateCpsT.runK_lift... ok
Checking: Nat.toSubscriptString... ok
Checking: Std.Format.MonadPrettyFormat.pushNewline... ok
Checking: HEq.recOn... ok
Checking: Lean.Parser.Tactic.tacDepIfThenElse... ok
Checking: CoeFun.recOn... ok
Checking: StateCpsT.runK_get... ok
Checking: USize.toFin... ok
Checking: Bool.cond_eq_true_distrib... ok
Checking: Lean.Parser.Tactic.Conv.enter... ok
Checking: Bool.eq_and_not_self... ok
Checking: Lean.Parser.Tactic.by?... ok
Checking: instAssociativeBoolAnd... ok
Checking: ReaderT.run.eq_1... ok
Checking: ReaderT.run_pure... FAIL
Checking: HasSubset.recOn... ok
Checking: not_exists_of_forall_not... ok
Checking: Option.any_eq_false... ok
Checking: Option.any_none... ok
Checking: Nat.Linear.instBEqPolyCnstr.beq_spec... TIMEOUT
Checking: List.eq_nil_of_map_eq_nil... ok
Checking: Std.Irrefl.recOn... ok

TOTAL 10953 OK 10757 FAIL 147 TIMEOUT 49 CACHED 0 OK% 98.2
Type error (use -v to see details)
